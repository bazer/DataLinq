This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*.cs, **/*.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
docs/Metadata Structure.md
docs/Project Specification.md
docs/Query Translator.md
docs/Source Generator.md
docs/Technical documentation.md
README.md
src/DataLinq.Benchmark/BenchmarkSetup.cs
src/DataLinq.Benchmark/Program.cs
src/DataLinq.Benchmark/Tests.cs
src/DataLinq.Blazor/Code/DL.cs
src/DataLinq.Blazor/Code/RandomTableData.cs
src/DataLinq.Blazor/Program.cs
src/DataLinq.CLI/Program.cs
src/DataLinq.Core/Attributes/AutoIncrementAttribute.cs
src/DataLinq.Core/Attributes/CacheCleanupAttribute.cs
src/DataLinq.Core/Attributes/CacheLimitAttribute.cs
src/DataLinq.Core/Attributes/ColumnAttribute.cs
src/DataLinq.Core/Attributes/DatabaseAttribute.cs
src/DataLinq.Core/Attributes/DefaultAttribute.cs
src/DataLinq.Core/Attributes/DefinitionAttribute.cs
src/DataLinq.Core/Attributes/EnumAttribute.cs
src/DataLinq.Core/Attributes/ForeignKeyAttribute.cs
src/DataLinq.Core/Attributes/IndexAttribute.cs
src/DataLinq.Core/Attributes/IndexCacheAttribute.cs
src/DataLinq.Core/Attributes/InterfaceAttribute.cs
src/DataLinq.Core/Attributes/NullableAttribute.cs
src/DataLinq.Core/Attributes/PrimaryKeyAttribute.cs
src/DataLinq.Core/Attributes/RelationAttribute.cs
src/DataLinq.Core/Attributes/TableAttribute.cs
src/DataLinq.Core/Attributes/TypeAttribute.cs
src/DataLinq.Core/Attributes/UseCacheAttribute.cs
src/DataLinq.Core/Attributes/ViewAttribute.cs
src/DataLinq.Core/ErrorHandling/DLOptionFailure.cs
src/DataLinq.Core/Extensions/Helpers/LinqExtensions.cs
src/DataLinq.Core/Extensions/Helpers/StringExtensions.cs
src/DataLinq.Core/Factories/Generator/GeneratorFileFactory.cs
src/DataLinq.Core/Factories/Generator/MetadataFromModelsFactory.cs
src/DataLinq.Core/Factories/MetadataFactory.cs
src/DataLinq.Core/Factories/MetadataTransformer.cs
src/DataLinq.Core/Factories/MetadataTypeConverter.cs
src/DataLinq.Core/Factories/Models/MetadataFromFileFactory.cs
src/DataLinq.Core/Factories/Models/ModelFileFactory.cs
src/DataLinq.Core/Factories/SyntaxParser.cs
src/DataLinq.Core/Interfaces/IDataSourceAccess.cs
src/DataLinq.Core/Interfaces/IDefinition.cs
src/DataLinq.Core/Interfaces/IModel.cs
src/DataLinq.Core/Interfaces/IView.cs
src/DataLinq.Core/Metadata/ColumnDefinition.cs
src/DataLinq.Core/Metadata/ColumnIndex.cs
src/DataLinq.Core/Metadata/CsFileDeclaration.cs
src/DataLinq.Core/Metadata/CsTypeDeclaration.cs
src/DataLinq.Core/Metadata/DatabaseDefinition.cs
src/DataLinq.Core/Metadata/ModelDefinition.cs
src/DataLinq.Core/Metadata/PropertyDefinition.cs
src/DataLinq.Core/Metadata/RelationDefinition.cs
src/DataLinq.Core/Metadata/RelationPart.cs
src/DataLinq.Core/Metadata/TableDefinition.cs
src/DataLinq.Core/Metadata/TableModel.cs
src/DataLinq.Core/Types/DatabaseType.cs
src/DataLinq.Generators.Tests/Extensions/Helpers/LinqExtensions.cs
src/DataLinq.Generators.Tests/Extensions/Helpers/QueryExtensions.cs
src/DataLinq.Generators.Tests/Extensions/Helpers/StringExtensions.cs
src/DataLinq.Generators.Tests/SourceGeneratorTests.cs
src/DataLinq.Generators/ModelGenerator.cs
src/DataLinq.MySql/Extensions/Helpers/LinqExtensions.cs
src/DataLinq.MySql/Extensions/Helpers/QueryExtensions.cs
src/DataLinq.MySql/Extensions/Helpers/StringExtensions.cs
src/DataLinq.MySql/MetadataFromMySqlFactory.cs
src/DataLinq.MySql/Models/information_schema/information_schema.cs
src/DataLinq.MySql/Models/information_schema/Views/COLUMNS.cs
src/DataLinq.MySql/Models/information_schema/Views/KEY_COLUMN_USAGE.cs
src/DataLinq.MySql/Models/information_schema/Views/STATISTICS.cs
src/DataLinq.MySql/Models/information_schema/Views/TABLES.cs
src/DataLinq.MySql/Models/information_schema/Views/VIEWS.cs
src/DataLinq.MySql/MySqlDatabase.cs
src/DataLinq.MySql/MySqlDatabaseTransaction.cs
src/DataLinq.MySql/MySqlDataLinqDataReader.cs
src/DataLinq.MySql/MySqlDataLinqDataWriter.cs
src/DataLinq.MySql/MySqlDbAccess.cs
src/DataLinq.MySql/MySQLProvider.cs
src/DataLinq.MySql/SqlFromMetadataFactory.cs
src/DataLinq.SQLite/Extensions/Helpers/LinqExtensions.cs
src/DataLinq.SQLite/Extensions/Helpers/QueryExtensions.cs
src/DataLinq.SQLite/Extensions/Helpers/StringExtensions.cs
src/DataLinq.SQLite/MetadataFromSQLiteFactory.cs
src/DataLinq.SQLite/SqlFromMetadataFactory.cs
src/DataLinq.SQLite/SQLiteDatabase.cs
src/DataLinq.SQLite/SQLiteDatabaseTransaction.cs
src/DataLinq.SQLite/SQLiteDataLinqDataReader.cs
src/DataLinq.SQLite/SQLiteDataLinqDataWriter.cs
src/DataLinq.SQLite/SQLiteDbAccess.cs
src/DataLinq.SQLite/SQLiteProvider.cs
src/DataLinq.Tests.Models/Allround/AllroundBenchmark.cs
src/DataLinq.Tests.Models/Allround/AllroundBenchmarkBogusData.cs
src/DataLinq.Tests.Models/Allround/Tables/Discount.cs
src/DataLinq.Tests.Models/Allround/Tables/Inventory.cs
src/DataLinq.Tests.Models/Allround/Tables/Location.cs
src/DataLinq.Tests.Models/Allround/Tables/Locationhistory.cs
src/DataLinq.Tests.Models/Allround/Tables/Manufacturer.cs
src/DataLinq.Tests.Models/Allround/Tables/Order.cs
src/DataLinq.Tests.Models/Allround/Tables/Orderdetail.cs
src/DataLinq.Tests.Models/Allround/Tables/Payment.cs
src/DataLinq.Tests.Models/Allround/Tables/Product.cs
src/DataLinq.Tests.Models/Allround/Tables/Productcategory.cs
src/DataLinq.Tests.Models/Allround/Tables/Productimage.cs
src/DataLinq.Tests.Models/Allround/Tables/Productreview.cs
src/DataLinq.Tests.Models/Allround/Tables/Producttag.cs
src/DataLinq.Tests.Models/Allround/Tables/Shippingcompany.cs
src/DataLinq.Tests.Models/Allround/Tables/User.cs
src/DataLinq.Tests.Models/Allround/Tables/Usercontact.cs
src/DataLinq.Tests.Models/Allround/Tables/Userfeedback.cs
src/DataLinq.Tests.Models/Allround/Tables/Userhistory.cs
src/DataLinq.Tests.Models/Allround/Tables/Userprofile.cs
src/DataLinq.Tests.Models/employees/gen/EmployeesDb.cs
src/DataLinq.Tests.Models/employees/gen/Tables/Department.cs
src/DataLinq.Tests.Models/employees/gen/Tables/dept_emp.cs
src/DataLinq.Tests.Models/employees/gen/Tables/Employee.cs
src/DataLinq.Tests.Models/employees/gen/Tables/Manager.cs
src/DataLinq.Tests.Models/employees/gen/Tables/Salaries.cs
src/DataLinq.Tests.Models/employees/gen/Tables/titles.cs
src/DataLinq.Tests.Models/employees/gen/Views/current_dept_emp.cs
src/DataLinq.Tests.Models/employees/gen/Views/dept_emp_latest_date.cs
src/DataLinq.Tests.Models/employees/partials/IDepartmentWithChangedName.cs
src/DataLinq.Tests.Models/employees/partials/IEmployee.cs
src/DataLinq.Tests.Models/employees/src/Tables/IDepartment.cs
src/DataLinq.Tests.Models/employees/src/Tables/IEmployee.cs
src/DataLinq.Tests.Models/employees/src/Tables/IManager.cs
src/DataLinq.Tests/BaseTests.cs
src/DataLinq.Tests/CacheTests.cs
src/DataLinq.Tests/CoreTests.cs
src/DataLinq.Tests/DatabaseFixture.cs
src/DataLinq.Tests/Extensions/Helpers/LinqExtensions.cs
src/DataLinq.Tests/Extensions/Helpers/QueryExtensions.cs
src/DataLinq.Tests/Extensions/Helpers/StringExtensions.cs
src/DataLinq.Tests/Helpers.cs
src/DataLinq.Tests/MutationTests.cs
src/DataLinq.Tests/QueryTests.cs
src/DataLinq.Tests/RelationTests.cs
src/DataLinq.Tests/SourceGeneratorTests.cs
src/DataLinq.Tests/SqlQueryTests.cs
src/DataLinq.Tests/SqlTests.cs
src/DataLinq.Tests/ThreadingTests.cs
src/DataLinq.Tests/TransactionTests.cs
src/DataLinq.Tools/DatabaseCreator.cs
src/DataLinq.Tools/Extensions/Helpers/LinqExtensions.cs
src/DataLinq.Tools/Extensions/Helpers/QueryExtensions.cs
src/DataLinq.Tools/Extensions/Helpers/StringExtensions.cs
src/DataLinq.Tools/ModelGenerator.cs
src/DataLinq.Tools/ModelReader.cs
src/DataLinq.Tools/SqlGenerator.cs
src/DataLinq/Cache/CacheHistory.cs
src/DataLinq/Cache/DatabaseCache.cs
src/DataLinq/Cache/DatabaseCacheSnapshot.cs
src/DataLinq/Cache/IndexCache.cs
src/DataLinq/Cache/KeyCache.cs
src/DataLinq/Cache/RowCache.cs
src/DataLinq/Cache/TableCache.cs
src/DataLinq/Cache/TableCacheSnapshot.cs
src/DataLinq/Config/ConfigFile.cs
src/DataLinq/Config/ConfigReader.cs
src/DataLinq/Config/ConfigWriter.cs
src/DataLinq/Config/DataLinqConfig.cs
src/DataLinq/Config/DataLinqConnectionString.cs
src/DataLinq/Database.cs
src/DataLinq/Database/DatabaseAccess.cs
src/DataLinq/Database/DatabaseProvider.cs
src/DataLinq/Database/DatabaseTransaction.cs
src/DataLinq/Database/DataReader.cs
src/DataLinq/Database/DataWriter.cs
src/DataLinq/DbRead.cs
src/DataLinq/Exceptions/InvalidMutationObjectException.cs
src/DataLinq/Exceptions/InvalidQueryException.cs
src/DataLinq/Exceptions/ModelLoadFailureException.cs
src/DataLinq/Extensions/Helpers/LinqExtensions.cs
src/DataLinq/Extensions/Helpers/QueryExtensions.cs
src/DataLinq/Extensions/Helpers/StringExtensions.cs
src/DataLinq/Extensions/IModelExtensions.cs
src/DataLinq/Instances/IKey.cs
src/DataLinq/Instances/Immutable.cs
src/DataLinq/Instances/ImmutableRelation.cs
src/DataLinq/Instances/InstanceFactory.cs
src/DataLinq/Instances/KeyFactory.cs
src/DataLinq/Instances/Mutable.cs
src/DataLinq/Instances/MutableRowData.cs
src/DataLinq/Instances/RowData.cs
src/DataLinq/Interfaces/IDatabaseProvider.cs
src/DataLinq/Interfaces/IDatabaseProviderConstants.cs
src/DataLinq/Interfaces/IDatabaseProviderRegister.cs
src/DataLinq/Linq/Evaluator.cs
src/DataLinq/Linq/Queryable.cs
src/DataLinq/Linq/QueryExecutor.cs
src/DataLinq/Linq/TypeSystem.cs
src/DataLinq/Linq/Visitors/OrderByVisitor.cs
src/DataLinq/Linq/Visitors/WhereVisitor.cs
src/DataLinq/Logging/DataLinqLoggingConfiguration.cs
src/DataLinq/Logging/DataLinqLogLevel.cs
src/DataLinq/Logging/EventIds.cs
src/DataLinq/Logging/Log.cs
src/DataLinq/Metadata/MetadataFromTypeFactory.cs
src/DataLinq/Metadata/PluginHook.cs
src/DataLinq/Metadata/SqlGeneration.cs
src/DataLinq/Mutation/DataSourceAccess.cs
src/DataLinq/Mutation/History.cs
src/DataLinq/Mutation/ReadOnlyAccess.cs
src/DataLinq/Mutation/State.cs
src/DataLinq/Mutation/StateChange.cs
src/DataLinq/Mutation/Transaction.cs
src/DataLinq/Query/Delete.cs
src/DataLinq/Query/Insert.cs
src/DataLinq/Query/IQueryPart.cs
src/DataLinq/Query/Join.cs
src/DataLinq/Query/Literal.cs
src/DataLinq/Query/OrderBy.cs
src/DataLinq/Query/QueryResult.cs
src/DataLinq/Query/QueryUtils.cs
src/DataLinq/Query/Select.cs
src/DataLinq/Query/Sql.cs
src/DataLinq/Query/SqlQuery.cs
src/DataLinq/Query/Update.cs
src/DataLinq/Query/Where.cs
src/DataLinq/Query/WhereGroup.cs
src/DataLinq/Utils/FileSizeFormatProvider.cs
src/DataLinq/Utils/NonNegativeInt.cs
src/DataLinq/Utils/TypeUtils.cs
src/DataLinq/Workers/ThreadWorker.cs
src/DataLinq/Workers/WorkQueue.cs

================================================================
Files
================================================================

================
File: docs/Metadata Structure.md
================
## Metadata Structure

DataLinq’s source generator relies on a rich metadata model to describe both the database schema and the corresponding object models. This metadata serves as the foundation for generating the strongly typed immutable and mutable classes, as well as their related interfaces and extension methods. The key components of this metadata structure are outlined below.

### 1. **DatabaseDefinition**

- **Purpose:**  
  Represents an entire database, including its name, caching policies, and the collection of tables/views (encapsulated as TableModels).
  
- **Key Points:**
  - Holds global attributes (such as caching limits and cleanup settings) that apply to the database.
  - Contains a set of `TableModels` which tie together table definitions and their associated model definitions.
  - Maintains a C# type declaration that is used to generate the main database class.

### 2. **TableModel and TableDefinition**

- **TableModel:**  
  Acts as the bridge between the database and the model. It links:
  - **ModelDefinition:** The description of the C# model.
  - **TableDefinition:** The structure of the underlying table or view.
  - A designated property name (used in generated code) that represents the table within the database class.

- **TableDefinition:**  
  Describes a single database table or view.
  - Contains the database table name (`DbName`), a collection of `ColumnDefinition` objects, and an array of primary key columns.
  - Supports indices via a collection of `ColumnIndex` objects, which are later used for relation mapping and performance optimizations.
  - Indicates whether the definition represents a table or a view, and holds any caching configuration specific to the table.

### 3. **ColumnDefinition and ColumnIndex**

- **ColumnDefinition:**  
  Represents a single column in a table.
  - Specifies the column’s database name, the associated database types (through `DatabaseColumnType`), and flags such as whether the column is a primary key, auto-incremented, nullable, or part of a foreign key.
  - Links to a `ValueProperty` that holds the C# type information and additional attributes (e.g., default values).

- **ColumnIndex:**  
  Describes an index over one or more columns.
  - Records the index name, type (such as BTREE, FULLTEXT, etc.), and its characteristic (e.g., primary key, unique).
  - Aggregates columns that participate in the index and supports relation mapping by storing associated `RelationPart` objects.

### 4. **CsTypeDeclaration**

- **Purpose:**  
  Encapsulates C# type information for models and properties.
  
- **Key Points:**
  - Stores the type’s name, namespace, and categorizes it (e.g., Class, Record, Interface, Primitive).
  - Used extensively during source generation to ensure that generated code uses the correct type names and that interface prefixes are removed as needed.
  - Supports both runtime types (via reflection) and syntax-based types (from Roslyn), ensuring consistency between the defined models and the generated output.

### 5. **ModelDefinition and PropertyDefinition**

- **ModelDefinition:**  
  Captures the definition of a model class.
  - Includes its C# type declaration, a collection of using directives, and a list of properties.
  - Differentiates between value properties and relation properties, and records any model-level attributes.
  - Serves as the blueprint for generating the immutable and mutable classes.

- **PropertyDefinition:**  
  The base abstraction for model properties.
  - **ValueProperty:** Represents a simple column mapping, including type information, nullability, size, and any default values or enumeration details.
  - **RelationProperty:** Represents relationships between models (foreign key associations), holding a reference to a `RelationPart` that links the property to the corresponding column index and relation definition.

### 6. **RelationDefinition and RelationPart**

- **RelationDefinition:**  
  Defines a relationship between two tables.
  - Typically represents a one-to-many relationship, specifying the constraint name and linking the foreign key side to the candidate key side.
  
- **RelationPart:**  
  Describes one side of a relationship (either the foreign key or candidate key).
  - Associates with a `ColumnIndex` and includes a C# name that is used in the generated model to reference the relationship.
  - Provides helper methods to navigate to the “other side” of the relation, enabling bidirectional navigation in the ORM.

---

### Summary

The metadata structure in DataLinq forms a comprehensive representation of the database schema and its corresponding C# models. It is divided into:
- **Database and Table Definitions:** Which capture the overall database and its individual tables or views.
- **Column and Index Definitions:** Which detail the structure of each table and support the mapping of relations.
- **Model and Property Definitions:** Which describe the C# representations of the data, including type details, attributes, and relationships.
- **Relation Structures:** Which define how tables are linked through foreign keys and candidate keys.

This metadata is then consumed by the source generator to produce consistent, strongly typed model classes that adhere to DataLinq’s design principles of immutability, efficient caching, and seamless querying.

================
File: docs/Project Specification.md
================
# DataLinq Project Specification

## 1. Introduction

### 1.1 Purpose
DataLinq is designed to be a lightweight, high-performance Object-Relational Mapping (ORM) framework that leverages immutable objects and robust caching to optimize read-heavy scenarios. By focusing on minimal memory allocations and rapid data retrieval, DataLinq aims to provide a reliable and efficient solution for smaller projects and databases. Additionally, the framework is built to support multiple backend data sources—including traditional relational databases (like MariaDB and SQLite) as well as non-relational formats (such as JSON, CSV, and XML)—thus offering flexibility for diverse application requirements.

### 1.2 Scope
DataLinq encompasses:
- **Immutable Entity Management:** Utilizing a source generator, the framework automatically creates both immutable and mutable classes for each data model. Immutable objects ensure thread-safety and predictability during read operations.
- **Caching:** A dual-level caching strategy is implemented:
  - A **global cache** stores immutable entities for reuse across sessions and requests.
  - A **transaction-specific cache** holds objects undergoing updates to maintain consistency.
  - Cache invalidation is managed automatically during mutations, manually by the user, via time-based expiration, backend polling, or notifications (e.g., through Apache Kafka).
- **LINQ Integration:** The primary querying mechanism is LINQ, offering a concise and familiar interface for developers.
- **Backend Flexibility:** The design facilitates easy swapping of backend sources with minimal code changes. This is essential for projects that may need to switch data storage strategies over time.
- **Testability:** 
  - **Data Layer Testing:** DataLinq is designed to make it straightforward for developers to test the data layer of their projects by providing clear interfaces and dedicated mocking classes.
  - **ORM Test Suite:** In parallel, DataLinq itself includes a comprehensive suite of unit, integration, and benchmarking tests to ensure reliability and performance.

### 1.3 Audience
This document is primarily intended for:
- **Developers:** Who will be integrating DataLinq into their applications and need to understand its design, usage, and customization points.
- **Contributors:** Who are interested in extending or improving the framework, ensuring adherence to its architectural principles and performance targets.


## 2. Project Overview

### 2.1 Goals and Objectives
DataLinq is driven by several key objectives:
- **Performance:** Optimize read operations through aggressive caching and an immutable object model, with a target of zero memory allocations on cache hits.
- **Simplicity and Flexibility:** Provide a minimal yet powerful API modeled after Entity Framework, enabling seamless switching between different backend data sources with minimal code adjustments.
- **Extensibility:** Support various data sources including MariaDB, SQLite, JSON, CSV, and XML, thereby accommodating diverse application needs.
- **Testability:** 
  - Enable developers to easily test the data layers of their projects by offering clear interfaces and built-in mocking capabilities.
  - Maintain a robust internal test suite to validate the ORM's performance and correctness.
- **Scalability:** Cater primarily to heavy-read scenarios in small-to-medium projects while laying the groundwork for potential expansion.

### 2.2 High-Level Architecture
The architecture of DataLinq is organized around several core components:
- **Immutable Entity Model:**  
  - Data models are represented as immutable objects to ensure thread-safety and consistency.
  - Mutations are handled by converting immutable objects into new mutable instances for modification. Once updated, these changes are reflected back into the cache by generating a new immutable object.
- **Caching Mechanism:**  
  - A **global cache** holds immutable objects to maximize reusability across sessions.
  - A **transactional cache** manages updates within individual operations, ensuring that changes are consistently applied before synchronizing with the global cache.
  - Multiple cache invalidation strategies are employed, including automatic invalidation on mutation, manual refresh, timer-based expiry, backend polling, and external notifications.
- **LINQ-Based Querying:**  
  - The ORM leverages LINQ as its primary query language, providing a concise and familiar syntax for data retrieval and manipulation.
- **Backend Integration:**  
  - Initially, DataLinq supports MariaDB and SQLite.
  - Its modular design makes it straightforward to switch backends or add new ones, ensuring minimal impact on existing code when migrating between data sources.
- **Source Generation:**  
  - A source generator automates the creation of immutable and mutable classes for each model, reducing boilerplate code and enforcing consistency across the codebase.
- **Testability:**  
  - The framework is built with testability in mind, offering interfaces and mocking classes to facilitate both the testing of applications that use DataLinq and the rigorous internal testing of the ORM itself.


Below is the updated **System Architecture and Design** section incorporating your feedback:


## 3. System Architecture and Design

### 3.1 Immutable Entity Model
- **Immutable Objects:**  
  Data models in DataLinq are represented as immutable objects, ensuring thread-safety and consistency. Once created, the state of these objects cannot change.
  
- **Mutation Workflow:**  
  When an update is required, the framework provides a `Mutate()` method. This method converts the immutable object into a mutable version for modifications. After saving these changes to the backend within a transaction, a new immutable instance is generated to replace the previous version in the cache. Notably, mutable objects are only used transiently in user code and are never stored in any cache.

- **Source Generation:**  
  A source generator automates the creation of both immutable and mutable classes from abstract model classes. This minimizes boilerplate code and ensures consistency across the codebase.

### 3.2 Caching Mechanism
- **Global Cache:**  
  A static, application-wide cache holds immutable objects. These objects are shared across sessions and threads, allowing rapid access with zero memory allocations on cache hits.
  
- **Transactional Cache:**  
  During a transaction, any updated objects are read back as new immutable objects after being saved to the backend. These new immutable objects are stored in a dedicated transaction cache to maintain consistency until the transaction is complete.

- **Cache Invalidation Strategies:**  
  Cache consistency is maintained through several mechanisms:
  - **Automatic Invalidation:** Cache entries are automatically updated when objects are mutated within the library.
  - **Manual Refresh:** Developers can explicitly refresh cache entries when necessary.
  - **Time-Based Expiry:** Entries can expire based on a configurable timer.
  - **Backend Polling:** The system may poll the backend using lightweight techniques (e.g., hash or timestamp comparisons) to detect changes.
  - **Event-Driven Updates:** External notifications (such as through Apache Kafka) can trigger immediate cache invalidation upon data modifications.

### 3.3 LINQ-Based Querying
- **Primary Query Interface:**  
  DataLinq uses LINQ as its core querying language, offering a concise, expressive, and familiar syntax for data retrieval and manipulation.
  
- **Query Translation:**  
  LINQ queries are translated into the appropriate backend-specific commands, abstracting the underlying data source so that the same syntax works regardless of whether data comes from MariaDB, SQLite, or other supported formats.

### 3.4 Backend Integration and Modularity
- **Pluggable Architecture:**  
  DataLinq is designed with a modular architecture that allows developers to easily swap one backend for another with minimal code changes. Backend interactions are abstracted behind interfaces and adapter patterns.
  
- **Initial and Future Backends:**  
  While initial support is focused on MariaDB and SQLite, the architecture is readily extendable to additional data sources such as JSON, CSV, and XML.

### 3.5 Concurrency and Thread-Safety
- **Immutability Benefits:**  
  The immutable design reduces the need for complex synchronization since immutable objects can be safely shared across threads.
  
- **Thread-Safe Collections:**  
  For mutable scenarios, such as managing the transactional cache, thread-safety is ensured using locking mechanisms and thread-safe collections like `ConcurrentDictionary`.
  
- **Minimized Locking:**  
  The overall design minimizes locking by isolating mutable operations and leveraging immutable data structures, which enhances performance in concurrent environments.

### 3.6 Source Generation and Code Consistency
- **Automated Code Generation:**  
  The source generator creates both immutable and mutable classes automatically from abstract model definitions. This enforces a consistent pattern across data models and reduces the need for repetitive code.
  
- **Reduction of Boilerplate:**  
  Automating the generation of model classes allows developers to focus on business logic, leading to more maintainable and readable code.

### 3.7 Testability and Mocking
- **Clear Interfaces:**  
  The architecture is built around well-defined interfaces, making it simple to substitute real implementations with mocks during testing.
  
- **Mocking Capabilities:**  
  Dedicated mocking classes are provided, enabling developers to write comprehensive tests for their applications without needing a live backend connection.
  
- **Internal Test Suite:**  
  DataLinq includes a robust internal test suite with unit tests, integration tests, and performance benchmarks to ensure both correctness and efficiency.

### 3.8 CLI Tool and Code Generation
- **Model Class Generation:**  
  DataLinq provides a CLI tool that reads the database structure and generates abstract model classes. These abstract classes serve as the basis from which immutable and mutable classes are generated via the source generator.
  
- **Database Script Generation:**  
  The CLI tool can also generate a SQL script to create the database schema based on the model classes. This feature ensures consistency between the codebase and the actual database structure, facilitating smoother migrations and initial setups.


## 4. Functional Requirements

### 4.1 Data Access Operations
- **CRUD Support:**  
  - **Create:** Developers can insert new records by creating a new mutable instance derived from the abstract model. Once the instance is saved to the backend, a corresponding immutable object is generated and added to the global cache.
  - **Read:** LINQ serves as the primary interface for querying data. Immutable objects are fetched from the global cache when available, ensuring minimal memory allocations and rapid retrieval.
  - **Update:** Updates are initiated by calling the `Mutate()` method on an immutable object to obtain a mutable version. After modifications are saved to the backend within a transaction, a new immutable instance is created and cached.
  - **Delete:** Deletion operations remove records from the backend. Upon successful deletion, the relevant immutable object is removed from both the global and transactional caches.

- **Transaction Management:**  
  - Each operation that involves mutations takes place within a transactional context. This ensures that all updates within a transaction are managed consistently. The transactional cache holds the new immutable objects after successful backend writes until the transaction is complete.

### 4.2 Query Processing and LINQ Integration
- **LINQ-Based Queries:**  
  - Developers write queries using LINQ syntax, which is then translated into backend-specific commands (e.g., SQL for MariaDB or SQLite). This translation layer abstracts away backend details, allowing a unified querying experience.
  - Advanced query capabilities, including filtering, ordering, grouping, and joining across entities, are supported through standard LINQ expressions.

- **Query Translation Layer:**  
  - The translation component maps LINQ expressions to the specific SQL dialect or other query languages supported by the backend. This ensures that queries are both efficient and compatible with the targeted data source.

### 4.3 Data Mapping and Model Management
- **Model Class Generation:**  
  - A CLI tool is provided to generate abstract model classes by reading the database schema. These abstract classes serve as the blueprint for both immutable and mutable classes produced by the source generator.
  - This process ensures that the generated model accurately reflects the structure of the underlying database, reducing manual coding and potential errors.

- **Database Schema Generation:**  
  - The CLI tool can also generate SQL scripts that create the database schema based on the model classes. This ensures consistency between the data models in the code and the actual database structure, simplifying initial setup and migrations.

### 4.4 Caching Behavior
- **Global Cache Operations:**  
  - When a read operation is performed, the system first checks the global cache for an immutable object. If present, the object is returned immediately without additional allocations.
  - Cache misses trigger a backend query, after which the retrieved data is converted into an immutable object and stored in the global cache.

- **Transactional Cache Operations:**  
  - Updated objects within a transaction are handled by storing their newly generated immutable versions in a transactional cache. This cache isolates changes until the transaction is fully committed, after which the global cache is updated accordingly.

- **Cache Invalidation:**  
  - The system supports multiple invalidation strategies to ensure data consistency. These include:
    - **Automatic Invalidation:** Upon mutation, affected cache entries are immediately refreshed.
    - **Manual Refresh:** Developers can explicitly trigger a cache update.
    - **Time-Based Expiry:** Cache entries can be configured to expire after a set period.
    - **Backend Polling and Notifications:** Lightweight checks (via hash or timestamp) or external notifications (e.g., Apache Kafka) ensure the cache reflects the current state of the backend.

### 4.5 Backend Flexibility
- **Seamless Backend Switching:**  
  - DataLinq’s architecture abstracts backend-specific details through interfaces and adapter patterns. This allows developers to switch from one data source to another (e.g., from MariaDB to SQLite) with minimal or no changes to the application code.
  - The modular design ensures that backend-specific optimizations or query translations can be implemented independently without affecting the overall API.

### 4.6 Error Handling and Logging
- **Robust Exception Management:**  
  - All CRUD and query operations include error handling to manage scenarios like connection failures, query timeouts, or data inconsistencies.
  - Detailed logging mechanisms are integrated to capture the sequence of operations, errors, and any cache invalidation events, aiding in troubleshooting and performance tuning.


## 5. Non-Functional Requirements

### 5.1 Performance
- **Optimized Read Operations:**  
  DataLinq is designed for heavy-read scenarios, with a target of zero memory allocations when fetching immutable objects from the cache. This is achieved through aggressive caching and careful management of object creation.
  
- **Efficient Query Translation:**  
  LINQ queries are translated into backend-specific commands with minimal overhead, ensuring that query execution remains fast and efficient across different data sources.

- **Benchmarking:**  
  A suite of performance benchmarks will be maintained to measure key metrics such as query latency, cache hit rates, and overall system throughput. These benchmarks will guide ongoing optimizations and ensure that performance targets are met.

### 5.2 Scalability
- **Designed for Small-to-Medium Projects:**  
  While DataLinq is optimized for projects with smaller databases and heavy-read operations, the architecture is modular enough to be extended to larger datasets if needed.
  
- **Modular Backend Integration:**  
  The ability to switch backends with minimal code changes ensures that the system can scale horizontally by integrating with more powerful data sources or distributed systems as project demands grow.

- **Concurrent Access:**  
  The use of immutable objects and thread-safe collections minimizes the need for locks and supports high levels of concurrent access without significant performance degradation.

### 5.3 Maintainability and Extensibility
- **Automated Code Generation:**  
  The use of a source generator to create both immutable and mutable classes from abstract model definitions reduces boilerplate code, leading to a more maintainable and consistent codebase.
  
- **Clear Separation of Concerns:**  
  By abstracting backend interactions behind interfaces and adapter patterns, DataLinq allows developers to add or update components without affecting the overall system. This design simplifies future enhancements and troubleshooting.

- **Comprehensive Documentation:**  
  Detailed documentation, including this specification, usage guides, and API references, will be maintained to ensure that developers and contributors can quickly understand and work with the framework.

### 5.4 Reliability and Robustness
- **Robust Error Handling:**  
  All operations, including CRUD actions and query processing, are designed with robust exception management and logging. This ensures that failures are handled gracefully, and sufficient diagnostic information is available for troubleshooting.

- **Internal Test Suite:**  
  A comprehensive suite of unit tests, integration tests, and performance benchmarks will be continually run to ensure that any changes maintain the expected behavior and performance characteristics of DataLinq.

### 5.5 Security Considerations
- **Data Integrity:**  
  Mechanisms such as transactional caches and backend polling help maintain data consistency, reducing the risk of stale or inconsistent data being served.
  
- **Secure Access:**  
  Although DataLinq focuses primarily on read performance, care is taken to ensure that backend connections and query executions adhere to security best practices, including proper exception handling and input validation.


## 6. API Design and Query Interface

### 6.1 Overview
DataLinq’s API is designed to be both intuitive and powerful, drawing inspiration from established ORM frameworks like Entity Framework. The API is primarily built around LINQ, ensuring that developers can use a familiar and expressive syntax for data access and manipulation while benefiting from DataLinq’s high-performance caching and immutable data structures.

### 6.2 LINQ-Based Querying
- **Unified Query Syntax:**  
  Developers write queries using standard LINQ expressions. DataLinq translates these queries into the appropriate backend-specific commands (e.g., SQL for MariaDB or SQLite), abstracting the underlying complexity and allowing the same query syntax to work across different data sources.
  
- **Advanced Query Capabilities:**  
  The query interface supports advanced LINQ operations, including filtering, ordering, grouping, and joining, to cater to a wide range of data retrieval scenarios. This flexibility empowers developers to construct complex queries while keeping the code concise and readable.

- **Query Translation Layer:**  
  A dedicated translation layer interprets LINQ expressions and optimizes them for the target backend. This ensures efficient query execution and allows for backend-specific optimizations without requiring changes to the developer’s query code.

### 6.3 Fluent Interface and API Methods
- **Fluent API Design:**  
  DataLinq’s API incorporates a fluent interface for constructing queries and data operations. This design promotes readability and a natural coding style, enabling developers to chain methods together in a clear and coherent manner.
  
- **Core Methods and Operations:**  
  - **Query Initialization:** Methods for initiating LINQ queries that automatically check the global cache before executing a backend query.
  - **CRUD Operations:**  
    - **Create:** Methods to generate new mutable instances from abstract model definitions, followed by saving these instances to the backend and updating the global cache with a new immutable object.
    - **Read:** Methods that prioritize fetching immutable objects from the cache for read operations, falling back to backend queries as needed.
    - **Update:** A `Mutate()` method to create a mutable copy of an immutable object for modifications. After saving changes within a transaction, a new immutable instance is produced and stored.
    - **Delete:** Methods to remove records from the backend along with corresponding cache updates.
  - **Transaction Management:** Methods that allow developers to execute a group of operations within a transactional context, ensuring that all updates are isolated and consistent until the transaction is committed.

### 6.4 Extensibility and Backend Switching
- **Backend Abstraction:**  
  The API is designed with clear separation between the data access layer and backend-specific implementations. This is achieved through well-defined interfaces and adapter patterns, which enable developers to switch between different backends (e.g., MariaDB to SQLite) with minimal code changes.
  
- **Custom Extensions:**  
  Developers can extend the API by implementing custom adapters or overriding default behaviors. This modular design ensures that DataLinq can evolve to support additional backends and specialized query optimizations without altering the core API.

### 6.5 Integration with Testing and Mocking
- **Mocking Capabilities:**  
  To support robust testing of applications using DataLinq, the API exposes interfaces and provides dedicated mocking classes. This allows developers to simulate data layer interactions without requiring a live backend connection.
  
- **Seamless Data Layer Testing:**  
  The API is designed to facilitate the testing of data access code. Clear and consistent interfaces ensure that unit tests can easily substitute real implementations with mocks, enabling comprehensive testing of both query logic and transactional behaviors.

Below is a draft for the remaining sections of the DataLinq specification document:


## 7. Data Models and Backend Integration

### 7.1 Data Models
- **Entity Definitions:**  
  DataLinq’s data models are defined via abstract base classes that represent the schema of the underlying data. These abstract classes are used by a source generator to automatically create both immutable and mutable concrete classes.
  
- **Relationship Mapping:**  
  The framework supports various types of relationships—such as one-to-one, one-to-many, and many-to-many. These relationships are defined within the abstract models and are translated into the corresponding database relationships (foreign keys, join tables, etc.) during the model generation process.

- **Schema Synchronization:**  
  A CLI tool is provided to read the database schema and generate the corresponding abstract model classes. Conversely, the same tool can generate SQL scripts to create or update the database schema based on the current model definitions, ensuring consistency between code and database.

### 7.2 Backend Integration
- **Adapter Pattern:**  
  DataLinq abstracts backend-specific details using well-defined interfaces and adapter patterns. Each supported backend (e.g., MariaDB, SQLite) implements a common interface for CRUD operations and query execution, allowing the core framework to remain agnostic of the underlying data source.

- **Modular Integration:**  
  The modular design facilitates the easy addition of new backends. Developers can implement additional adapters for other data sources (such as JSON, CSV, or XML) without altering the main codebase. This separation of concerns ensures that backend optimizations or changes do not affect the API or core logic.

- **Configuration and Switching:**  
  Configuration options allow developers to specify the desired backend with minimal changes to the application code. The architecture is designed so that switching between supported data sources is a streamlined process.


## 8. Testing and Benchmarking Strategy

### 8.1 Testing Methodology
- **Unit Testing:**  
  Each component of DataLinq, from the immutable model generation to cache management and query translation, is covered by comprehensive unit tests. These tests validate the correctness of individual functions and modules.
  
- **Integration Testing:**  
  Integration tests are used to ensure that the various components work seamlessly together. This includes testing the end-to-end process of data retrieval, manipulation, and caching across different backends.
  
- **Data Layer Testing for Client Applications:**  
  The framework provides clear interfaces and mocking capabilities so that developers can write tests for the data layer of their own projects without needing a live backend connection.

### 8.2 Benchmarking
- **Performance Benchmarks:**  
  A dedicated suite of performance benchmarks is maintained to measure:
  - Query latency and throughput
  - Cache hit rates and memory allocation metrics (with a focus on achieving zero allocations for cache hits)
  - Transaction processing times
  
- **Continuous Integration:**  
  Benchmark tests are integrated into the CI/CD pipeline to ensure that performance regressions are caught early. Regular reporting of benchmark results helps guide ongoing optimizations.

- **Monitoring and Logging:**  
  Detailed logging mechanisms capture performance-related metrics and cache events. These logs provide insights for performance tuning and troubleshooting.


## 9. Future Enhancements and Roadmap

### 9.1 Planned Features
- **Expanded Backend Support:**  
  Future releases may include native support for additional data sources, such as NoSQL databases or distributed storage systems.
  
- **Advanced Query Optimizations:**  
  Enhancements to the LINQ query translation layer could include more sophisticated optimizations, such as query caching and dynamic query planning tailored to specific backends.
  
- **Enhanced Caching Strategies:**  
  Further improvements in caching may involve more granular invalidation policies, adaptive cache sizing, and integration with external cache providers.
  
- **Developer Tooling:**  
  Additional CLI features and graphical tools could be introduced to assist developers in model management, schema migration, and performance monitoring.

### 9.2 Roadmap and Community Involvement
- **Release Phases:**  
  The project roadmap outlines incremental release phases that focus on core functionality first, followed by performance optimizations and expanded backend integrations.
  
- **Community Contributions:**  
  DataLinq welcomes community involvement. Clear contribution guidelines, a roadmap for feature requests, and regular community updates will be provided to foster an active development community.
  
- **Documentation and Support:**  
  Ongoing efforts will be made to enhance documentation and provide comprehensive usage guides, tutorials, and API references to support both new and experienced developers.


## 10. Appendices

### 10.1 Glossary
- **ORM (Object-Relational Mapping):** A programming technique for converting data between incompatible type systems in object-oriented programming languages.
- **LINQ (Language Integrated Query):** A querying syntax integrated into .NET languages for working with data in a consistent manner.
- **Immutable Object:** An object whose state cannot be modified after it is created.
- **Mutable Object:** An object that can be modified after creation.
- **Cache:** A storage layer used to temporarily store frequently accessed data for faster retrieval.
- **Adapter Pattern:** A design pattern that allows incompatible interfaces to work together.
- **CRUD:** An acronym for Create, Read, Update, Delete—basic operations for persistent storage.

### 10.2 References
- **Entity Framework Documentation:** Provides context for LINQ-based querying and ORM design patterns.
- **Design Patterns Literature:** Sources on the adapter pattern, immutability, and caching strategies that inform DataLinq’s architecture.
- **Performance Benchmarking Tools:** Documentation for the benchmarking tools and techniques used within the project.

================
File: docs/Query Translator.md
================
## Query Translation and Execution

DataLinq’s query translation subsystem transforms LINQ expressions into SQL commands tailored to the underlying database. This process is multi-staged, ensuring that the query is both optimized and fully parameterized before execution. The following subsections describe the key components and their roles.

### 1. Expression Simplification and Evaluation

**Evaluator.cs**  
- **Purpose:** Before translation begins, DataLinq partially evaluates the expression tree to simplify constant sub-expressions.  
- **Key Components:**
  - **Nominator:** Traverses the tree to determine which nodes can be evaluated locally. Parameters are explicitly excluded so that only independent expressions are replaced.
  - **SubtreeEvaluator:** Replaces nominated subtrees with constant expressions by compiling and invoking them.  
- **Outcome:** This reduces the complexity of the expression tree and ensures that only the relevant, variable-dependent parts are translated into SQL.

### 2. Queryable Interface and Integration

**Queryable.cs**  
- **Role:** This class provides the entry point for LINQ queries on DataLinq. It integrates with Remotion.Linq—a powerful query parsing framework—to interpret the LINQ expression trees.  
- **Mechanism:**  
  - The default query parser is used to generate a QueryModel.
  - The Queryable then hands off the QueryModel to our custom query executor.

### 3. Query Execution via QueryExecutor

**QueryExecutor.cs**  
- **Overview:**  
  - The QueryExecutor is central to transforming a QueryModel (obtained from Remotion.Linq) into a complete SQL statement.
- **Steps in Query Translation:**
  - **Extract QueryModel:**  
    - The executor recursively examines the expression tree to extract the QueryModel, handling subqueries, member accesses, method calls, and unary expressions.
  - **Parse Body Clauses:**  
    - Iterates over the query’s body clauses (such as `WhereClause` and `OrderByClause`).
    - Uses specialized visitors (described below) to translate these clauses into SQL fragments.
  - **Result Operators:**  
    - Recognizes operators such as `Take`, `Skip`, `First()`, `Single()`, etc.
    - These operators adjust the SQL query by setting LIMIT, OFFSET, or ensuring only a specific number of rows are returned.
  - **Projection:**  
    - The method `GetSelectFunc<T>` builds a selector function from the QueryModel’s `SelectClause`, handling both simple member accesses and more complex constructions (via anonymous types).
- **Execution:**  
  - After building the SQL query using the translator, the QueryExecutor calls the provider’s execution methods to retrieve data.
  - Retrieved rows are mapped back to immutable model instances using the `InstanceFactory`.

### 4. Type System and Dynamic Determination

**TypeSystem.cs**  
- **Function:**  
  - Determines the element type of a sequence, especially when dealing with generic `IEnumerable<T>` types.
  - This utility is critical when processing LINQ queries that return collections, ensuring that the correct model type is used during projection.

### 5. Clause Visitors

**OrderByVisitor.cs**  
- **Functionality:**  
  - Walks through the expression tree for `OrderBy` clauses.
  - Extracts column information from member expressions and instructs the SQL query to apply ordering (ascending or descending) accordingly.
  
**WhereVisitor.cs**  
- **Responsibilities:**  
  - Traverses the expression tree representing a `Where` clause.
  - Handles binary expressions (e.g., comparisons), method calls (for operations such as `Contains`, `StartsWith`, etc.), and logical operators (AND, OR, NOT).
  - Converts each operation into its SQL equivalent by invoking helper methods that add SQL predicates.

### 6. Building WHERE Clauses

**Where.cs and WhereGroup.cs**  
- **Where.cs:**  
  - Represents individual conditions.  
  - Supports operations like equality, inequality, LIKE, IN, and range comparisons.
  - Generates parameterized SQL snippets to ensure safety and performance.
- **WhereGroup.cs:**  
  - Allows grouping of multiple conditions using Boolean logic (AND/OR).
  - Provides methods to combine conditions, add parentheses, and support nested groups.
  - Works in tandem with the WhereVisitor to build the full WHERE clause.

### 7. SQL Query Construction

**SqlQuery.cs**  
- **Purpose:**  
  - Aggregates the different parts of a query—SELECT, FROM, JOIN, WHERE, ORDER BY, LIMIT, and OFFSET—into a complete SQL statement.
- **Features:**  
  - Handles aliasing, table naming, and column selection.
  - Delegates parts of the SQL construction to helper methods and visitors.
  - Integrates with the provider to ensure that database-specific syntax is respected (e.g., escape characters, parameter prefixes).

**Sql.cs**  
- **Role:**  
  - Acts as a mutable string builder for SQL commands.
  - Maintains a list of parameters and manages parameter indexing.
  - Provides methods to add text, format strings, join multiple clauses, and produce the final SQL command text.

### 8. DML Operations: Insert, Update, and Delete

- **Insert.cs:**  
  - Constructs an `INSERT INTO` command using values from the mutable model.
  - Parameterizes the values and, if required, appends a command to retrieve the last inserted ID.
- **Update.cs:**  
  - Builds an `UPDATE` command with a `SET` clause derived from the model’s changed properties.
  - Appends a WHERE clause to target specific rows.
- **Delete.cs:**  
  - Constructs a `DELETE FROM` command, leveraging the WHERE clause to specify which row(s) to remove.

### 9. JOIN Clauses

**Join.cs**  
- **Functionality:**  
  - Represents JOIN operations (inner, left outer, right outer).
  - Provides an `On` method to specify join conditions, which are internally represented as a nested WhereGroup.
  - Generates the appropriate JOIN clause in SQL, including table names, aliases, and ON conditions.

### 10. Miscellaneous Utilities

- **Literal.cs:**  
  - Represents literal SQL strings that can be embedded directly into queries.  
  - Useful for scenarios where a raw SQL fragment needs to be incorporated.
  
- **QueryUtils.cs:**  
  - Contains helper methods for parsing table and column names and extracting aliases.
  - Simplifies the handling of name formats, ensuring consistency across queries.

- **OrderBy.cs:**  
  - Encapsulates details for ordering, including the column, alias, and direction (ascending or descending).
  - Formats the ORDER BY clause using the database provider’s escape characters.

- **IQueryPart.cs and QueryResult.cs:**  
  - Define abstractions for parts of a query and for representing query results.
  - Though `QueryResult` is minimal, it serves as a placeholder for future enhancements in result handling.

---

### Summary

The Query Translator in DataLinq represents a cohesive system that:
- **Simplifies and partially evaluates LINQ expression trees** to isolate variable-dependent components.
- **Integrates with Remotion.Linq** to produce a QueryModel from high-level LINQ queries.
- **Uses specialized visitors** (WhereVisitor, OrderByVisitor) to convert LINQ clauses into SQL predicates.
- **Builds complete SQL commands** by assembling SELECT, FROM, JOIN, WHERE, ORDER BY, and LIMIT/OFFSET clauses.
- **Handles DML operations** (Insert, Update, Delete) with full parameterization.
- **Leverages dynamic type determination and projection** to convert SQL results back into immutable model instances.

================
File: docs/Source Generator.md
================
## Source Generator Overview

The DataLinq source generator automates the creation of immutable and mutable model classes, along with associated interfaces and extension methods. Its primary goal is to eliminate boilerplate code while ensuring that the generated models accurately reflect the underlying database schema and developer-defined attributes. The source generator accomplishes this by analyzing existing source code to build a comprehensive metadata representation, then using that metadata to produce additional source files that are incorporated into the compilation.

---

## Key Components and Workflow

### 1. **Model and Syntax Collection**

- **Syntax Provider:**  
  The generator starts by scanning the source code using Roslyn’s syntax provider.  
  - It identifies candidate model declarations by checking for classes that implement one of the key model interfaces (e.g., `ITableModel`, `IViewModel`, or custom variants).
  - The predicate function (`IsModelDeclaration`) quickly filters out irrelevant syntax nodes, while a transformation function extracts the corresponding `TypeDeclarationSyntax` for further analysis.

### 2. **Metadata Extraction**

- **SyntaxParser:**  
  Processes the collected syntax trees to extract model information.
  - It parses class declarations to create a `ModelDefinition` that includes C# type details, properties, attributes, and using directives.
  - It distinguishes between value properties and relation properties, building a detailed blueprint for each model.

- **Metadata Factories:**  
  Two primary factories convert syntax into metadata:
  - **MetadataFromModelsFactory:**  
    Consumes the `TypeDeclarationSyntax` nodes to produce a `DatabaseDefinition` that aggregates all model definitions, table definitions, and relational mappings.
  - **MetadataFromFileFactory:**  
    Offers an alternative approach by reading source files from specified directories, enabling external models to be integrated into the metadata.

- **MetadataFactory and Transformers:**  
  - The **MetadataFactory** converts `ModelDefinition` instances into `TableDefinition` or `ViewDefinition` objects, applying attributes such as `[Table]`, `[UseCache]`, and caching limits.
  - The **MetadataTransformer** further refines the metadata, for example, by removing interface prefixes and updating constraint names as needed.
  - **MetadataTypeConverter** assists by mapping C# type names to their database equivalents and calculating sizes and nullability.

### 3. **File Generation**

- **GeneratorFileFactory:**  
  This component is responsible for producing the output files based on the extracted metadata.
  - It defines options such as namespace, tab indentation, and whether to generate records or use file-scoped namespaces.
  - The factory constructs file headers (including using directives and namespace declarations), generates the body of the file by combining model properties, attributes, and method definitions, and then appends footers.
  - It produces files for both the main database definition and each individual table or view model.

- **ModelFileFactory:**  
  Further refines the file generation for individual models.
  - It creates files that include generated interfaces, immutable class definitions, mutable class definitions, and extension methods.
  - This component ensures that all aspects of a model (from column mapping to relation handling) are represented in the generated code.

### 4. **Integration into Compilation**

- **ModelGenerator (IIncrementalGenerator):**  
  The entry point for the source generator.
  - It registers the syntax provider to continuously monitor changes in the source code.
  - The generator combines the collected syntax nodes with the overall compilation and then passes them to the metadata factories.
  - Generated files are then added to the compilation context via `context.AddSource`, ensuring that they become part of the project without requiring manual inclusion.

- **Configuration and Options:**  
  The generator checks compilation options (such as nullable reference types) and applies settings accordingly. This ensures that generated code aligns with the project’s language version and coding standards.

---

## Summary

The DataLinq source generator operates in four key phases:

1. **Collection:**  
   It scans the codebase for model declarations using Roslyn’s syntax provider.

2. **Metadata Extraction:**  
   It transforms syntax nodes into rich metadata representations, capturing database schema, column definitions, relations, and model attributes.

3. **File Generation:**  
   Using the metadata, it generates source files that define immutable and mutable models, interfaces, and extension methods. These files include all necessary attributes, property definitions, and helper methods for CRUD operations.

4. **Compilation Integration:**  
   The generated files are seamlessly added to the compilation, ensuring that the ORM remains in sync with the underlying model definitions.

This modular approach minimizes boilerplate, enforces consistency, and allows developers to focus on business logic rather than repetitive code. The source generator’s design also facilitates easy customization and extension, making it a core strength of the DataLinq project.

================
File: docs/Technical documentation.md
================
Below is a draft of the technical documentation for DataLinq. This document covers the architectural overview, core components, caching and mutation subsystems, query handling, and testing strategies. It’s intended to help developers and contributors understand how the library works internally and to serve as a reference for future improvements.

---

# DataLinq Technical Documentation

## 1. Overview

DataLinq is a lightweight, high-performance ORM designed primarily for read-heavy scenarios in small to medium projects. The library emphasizes immutability, efficient caching, and seamless backend integration. Its core features include:

- **Immutable Models:**  
  Models are represented as immutable objects to ensure thread-safety and minimize side effects during data reads. When updates are necessary, the system creates a mutable copy via a defined mutation workflow.
  
- **Source Generation:**  
  A source generator produces both immutable and mutable classes from abstract model definitions. This reduces boilerplate and enforces a consistent pattern across the codebase.
  
- **LINQ Integration:**  
  Queries are written using standard LINQ expressions, which are translated into backend-specific commands, allowing a unified querying experience.
  
- **Robust Caching:**  
  A multi-layered caching subsystem—including row, index, and key caches—ensures that repeated data accesses incur minimal overhead.

- **Backend Flexibility:**  
  The architecture abstracts backend details behind interfaces and adapters, enabling easy switching between data sources (e.g., MariaDB, SQLite, JSON, CSV).

---

## 2. Architecture

DataLinq is organized into several interconnected layers that work together to deliver its performance and flexibility:

- **Model Layer:**  
  Consists of abstract model classes decorated with attributes (e.g., `[Table]`, `[Column]`, `[PrimaryKey]`) that describe how classes map to database tables. These definitions are used by the source generator to create concrete immutable and mutable classes (see *Department.cs* citeturn0file0, *Employee.cs* citeturn0file2).

- **Instance Creation and Mutation:**  
  Immutable objects are created dynamically based on `RowData` provided by data readers. When mutation is required, methods like `Mutate()` generate a mutable version, which can be updated and then saved back to the backend. The mutation workflow ensures that only immutable instances are stored in caches, preserving thread-safety and performance (see *Immutable.cs* citeturn1file2 and *Mutable.cs* citeturn1file6).

- **Caching Subsystem:**  
  The caching mechanism is divided into several parts:
  - **RowCache:** Caches immutable row objects keyed by their primary keys, tracking insertion ticks and sizes for eviction based on time, row count, or memory limits (see *RowCache.cs* citeturn2file2).
  - **IndexCache and KeyCache:** Manage mappings between foreign keys and primary keys, and cache key instances for fast lookups (see *IndexCache.cs* citeturn2file0 and *KeyCache.cs* citeturn2file1).
  - **TableCache:** Aggregates the various caches for an entire table, provides methods to update or remove rows based on changes, and supports preloading indices for faster query responses (see *TableCache.cs* citeturn2file3).

- **Query Engine:**  
  DataLinq uses LINQ as the primary query language. LINQ expressions are parsed and translated into backend-specific SQL (or other query languages), with support for filtering, ordering, grouping, and pagination. The query system leverages caching to avoid unnecessary database round trips, as demonstrated in the extensive unit tests (see *QueryTests.cs* citeturn2file9).

- **Testing Infrastructure:**  
  The library is accompanied by a comprehensive suite of unit and integration tests. These tests verify everything from model instantiation and mutation to complex LINQ query operations and cache behavior (see *CacheTests.cs* citeturn2file5, *MutationTests.cs* citeturn2file8, and *CoreTests.cs* citeturn2file6).

---

## 3. Core Components

### 3.1 Model and Source Generation

- **Abstract Models:**  
  Developers define models using abstract classes and decorate them with attributes to specify table names, column types, and relationships. For example, the *Department* class declares properties like `DeptNo` and `Name`, and defines relations to employees and managers.
  
- **Source-Generated Classes:**  
  A source generator processes these abstract definitions to generate:
  - **Immutable classes:** Provide read-only access to data, with lazy loading of related objects.
  - **Mutable classes:** Allow modification of model properties via a `Mutate()` method, and support transactional updates.
  - **Interfaces:** Generated interfaces (e.g., `IDepartmentWithChangedName`) ensure consistency and facilitate mocking in tests.

### 3.2 Instance Management and Mutation

- **Immutable Base Class:**  
  The base class for immutable models handles:
  - Retrieving values from underlying `RowData`.
  - Lazy evaluation of properties.
  - Managing relations through helper methods that load related entities only when needed.
  
- **Mutable Wrapper:**  
  The `Mutable<T>` class encapsulates changes in a separate `MutableRowData` structure. This ensures that modifications are isolated until explicitly committed, after which a new immutable instance is generated to update the cache.

- **Factory Methods:**  
  The `InstanceFactory` provides methods to create immutable instances dynamically. Reflection is used to instantiate models based on metadata extracted from attributes.

### 3.3 Caching Mechanisms

- **RowCache:**  
  Stores immutable instances keyed by their primary keys. Tracks insertion ticks and sizes to enforce eviction policies based on time, count, or memory usage. This ensures repeated reads return cached objects without additional allocations.
  
- **IndexCache and KeyCache:**  
  - **IndexCache:** Maps foreign keys to arrays of primary keys and maintains a tick queue to remove old entries.
  - **KeyCache:** Caches key instances to prevent redundant key creation, enhancing lookup performance.
  
- **TableCache:**  
  Combines row and index caches for a given table. Handles state changes such as inserts, updates, and deletions by updating the caches accordingly. It also supports methods for preloading indices and retrieving rows with or without ordering.

### 3.4 Query Handling

- **LINQ Integration:**  
  Queries are written in LINQ, and the query engine translates them into backend-specific SQL commands. The translation layer is capable of handling various operations such as:
  - Filtering using standard where clauses.
  - Ordering, grouping, and pagination (using methods like `OrderBy`, `Skip`, and `Take`).
  - Joins and relation traversals by leveraging the relation properties defined in models.
  
- **Cache-Aware Query Execution:**  
  When a query is executed, the system first checks the cache (via `TableCache` and `RowCache`) for existing rows. If a row is missing, it retrieves the row data from the database, creates an immutable instance, and adds it to the cache.

### 3.5 Testing and Examples

- **Unit Tests:**  
  The testing suite covers all aspects of the library:
  - **Cache Tests:** Validate that duplicate rows are not created, and that eviction policies based on time, row count, and memory size work as expected.
  - **Mutation Tests:** Ensure that mutable instances correctly capture changes, can be reset, and that saving changes properly updates the backend and cache.
  - **Query Tests:** Provide extensive examples of LINQ query usage, demonstrating filtering, ordering, grouping, and handling of unsupported operations.
  
- **Integration Tests:**  
  The `DatabaseFixture` sets up real database connections (e.g., to MariaDB and SQLite) and uses generated test data (via Bogus) to ensure that the entire flow—from data retrieval and caching to mutation and query execution—operates correctly.

---

## 4. Detailed Caching Workflow

The caching subsystem is critical for achieving the zero-allocation goal in read-heavy scenarios. Here’s a closer look at the workflow:

1. **Insertion into Cache:**  
   When a new row is fetched from the database, its corresponding immutable instance is created using the `InstanceFactory`. This instance is then stored in the `RowCache` along with metadata (insertion ticks, size). Simultaneously, the `IndexCache` is updated to map foreign keys to this row’s primary key (see *RowCache.cs* citeturn2file2 and *IndexCache.cs* citeturn2file0).

2. **Cache Eviction:**  
   - **Time-Based Eviction:** The system can remove rows that were inserted before a specific tick value.
   - **Row Count/Size Limits:** Methods in `RowCache` allow the cache to enforce limits by removing the oldest rows until the count or total size is within the defined thresholds.
   - **Index Cache Maintenance:** The `IndexCache` similarly purges outdated entries using its tick queue mechanism.
   
3. **Cache Retrieval:**  
   Before executing a query, the system checks the `RowCache` for the required rows. If a row is found, it’s returned directly. Otherwise, the query system retrieves the missing rows from the database and updates the cache.

4. **Transaction Awareness:**  
   The `TableCache` can maintain separate caches for transaction-specific data. This ensures that updates within a transaction do not affect the global cache until the transaction is committed.

---

## 5. Mutation and Data Consistency

DataLinq ensures data consistency while allowing mutations through a well-defined process:

1. **Immutable to Mutable Conversion:**  
   The generated `Mutate()` methods (see source-generated *Department* file) allow conversion from an immutable instance to a mutable one. This is achieved using pattern matching, ensuring the proper type is returned regardless of whether the object is already mutable or not.

2. **Tracking Changes:**  
   The `MutableRowData` class tracks modifications in a dictionary. Methods such as `Reset()` allow reverting changes to the original state, while `HasChanges()` reports whether any properties have been modified.

3. **Saving Changes:**  
   When a mutable instance is saved, the updated data is written back to the backend. Upon successful commit, a new immutable instance is created to replace the old one in the cache. Extension methods in the generated code (e.g., `Save`, `Update`, `InsertOrUpdate`) abstract these operations, providing a seamless developer experience.

---

## 6. Future Directions and Developer Notes

- **Additional Backends:**  
  Although initial support focuses on MariaDB and SQLite, the modular design facilitates easy addition of new data sources (e.g., NoSQL, JSON files).

- **Enhanced Query Optimizations:**  
  Future enhancements could include query caching, more advanced translation strategies, and support for more complex LINQ expressions.

- **Developer Contributions:**  
  Clear guidelines and extensive test coverage make it easier for contributors to understand and extend the library. Developers are encouraged to review both the generated code and supporting subsystems (caching, mutation, and query translation) for insights.

- **Documentation Updates:**  
  This technical documentation is intended to evolve with the project. Feedback from developers and contributors is welcomed to ensure that the documentation remains accurate and helpful.

---

## 7. Conclusion

DataLinq’s design centers on immutability, efficient caching, and flexible querying, making it an ideal ORM for heavy-read applications with a focus on performance. The separation of concerns between model mapping, caching, mutation, and query translation ensures that each component can be optimized independently while maintaining a consistent developer experience.

================
File: README.md
================
# DataLinq

DataLinq is a state-of-the-art database interfacing library uniquely designed with an emphasis on immutability. This approach ensures data integrity, consistency, and superior performance. Whether you're performing basic CRUD actions, handling complex relationships, caching data, executing parallel processes, or utilizing the project's Command-Line Interface (CLI), DataLinq streamlines your operations with unmatched efficiency.

## Getting Started

Starting with DataLinq is a breeze. Here's a step-by-step guide to get you up and running:

1. **Installation**: Begin by installing the DataLinq package via your package manager.
2. **Configuration**: Set up your database connection details. Currently, DataLinq supports MySQL (including MariaDB) and SQLite. Support for additional database engines is planned for future releases.
3. **Model Creation**: Utilize DataLinq's CLI or API to generate data models based on your database schema.
4. **Operations**: Dive into querying, CRUD operations, relationship management, and more using DataLinq's intuitive methods.

For a detailed guide, refer to the [official documentation](#).

## Key Features

- **Metadata Handling**: Seamlessly retrieve and manage database metadata. DataLinq intelligently interprets metadata to facilitate operations like relationship management and caching.
- **Query Operations**: Perform SQL-like query operations with ease. Methods such as `ToList()`, `Count()`, `Where()`, and more simplify your querying process. For example:

    ```csharp
    var activeUsers = usersDb.Query().Users.Where("status").EqualTo("active").ToList();
    ```

- **Relationship Management**: Effortlessly manage table relationships. DataLinq supports features like lazy loading, ensuring efficient data retrieval without overloading your system.

    ```csharp
    var department = employeesDb.Query().Departments.Single(x => x.DeptNo == "d005");
    Assert.NotEmpty(department.Managers);
    ```

- **Caching**: Enhance performance with built-in caching mechanisms. DataLinq's unique approach to immutable data allows for efficient caching, reducing database hits and ensuring swift data retrieval.

- **Threading Support**: Execute concurrent database operations with DataLinq's robust parallel processing capabilities. This ensures that your application remains responsive even under heavy load.

- **Command-Line Interface (CLI)**: Interact with DataLinq directly from the command line. Use commands like `create-database`, `create-sql`, and `create-models` to manage your database setup.

## Handling Immutable and Mutable Data

DataLinq's philosophy revolves around the principle of immutability, ensuring data consistency and reducing potential pitfalls in application development. With immutable data, once a record is created, it remains unchanged. However, when updates are needed, DataLinq provides a seamless transition from immutable to mutable data, ensuring flexibility without compromising integrity.

### Immutable Data

- **Immutable By Default**: All data loaded from the database is inherently immutable. This ensures data integrity, consistency, and thread safety across the application.
- **Immutable Checks & Caching**: Verify a model's immutability using the `IsImmutable` extension. Given their unchangeable nature, immutable objects are cached efficiently, ensuring faster data retrieval and reducing database overhead.
- **Mutation**: The `Mutate()` extension facilitates transitions. When an update is needed, retrieve a mutable copy of the immutable model, make modifications, and save it back to the database.

### Mutable Data

- **Mutable When Needed**: While DataLinq emphasizes immutability, it recognizes the necessity of change. Models can be made mutable when updates are required.
- **Mutable Checks & Database Operations**: Check a model's mutability using the `IsMutable` extension. Direct database operations, such as `Insert()`, `Update()`, and `Delete()`, can be performed on mutable models.
- **Change Detection**: Before committing changes, review them with the `GetChanges()` method. This ensures that only intended modifications are saved.

## Caching and Performance

DataLinq's caching mechanism is intricately tied to its emphasis on immutability. By leveraging immutable data, the system ensures efficient caching, which in turn, boosts performance.

### Database & Table-Level Caching

- **Efficient Data Retrieval**: DataLinq employs both database and table-level caching. The former manages cache for the entire database, while the latter focuses on individual tables. Together, they ensure swift data retrieval without repeated database hits.
- **Thread Safety**: With the use of concurrent data structures, DataLinq's caching mechanism is thread-safe. This ensures data consistency even in high-concurrency scenarios.
- **Cache Management**: Periodic cache cleanups are performed to ensure optimal memory usage. Old and redundant data is efficiently pruned, ensuring the cache remains lean and efficient.

### Performance Enhancements

By reducing direct database interactions and leveraging cached data, DataLinq significantly reduces application latency. Whether you're querying data, managing relationships, or performing CRUD operations, expect swift responses and a streamlined user experience.

## Advanced Features

DataLinq is not just about basic database operations. Beneath the surface, it employs advanced techniques and mechanisms that set it apart.

### Dynamic Proxy Mechanism

One of DataLinq's standout features is its use of dynamic proxies for data models. This mechanism allows DataLinq to intercept calls to the models, enabling unique functionalities like immutability and change tracking. Whether you're working with an immutable model and transitioning to a mutable one or vice versa, the dynamic proxy mechanism ensures a seamless experience.

### Integrated Caching & Parallel Processing

DataLinq's approach to caching is deeply integrated with its parallel processing capabilities. By caching immutable data, the system can efficiently handle concurrent operations without the risk of data corruption. This ensures that your application remains responsive and data-consistent even under heavy load.

## Querying

DataLinq simplifies the querying process with a SQL-like interface. Whether you're fetching a single record or filtering through thousands, DataLinq's methods make it straightforward.

```csharp
// Fetch all records from the 'Users' table
var allUsers = usersDb.Query().Users.ToList();

// Filter records based on conditions
var activeUsers = usersDb.Query().Users.Where("status").EqualTo("active").ToList();
```

For complex queries and advanced filtering options, refer to the [querying guide](#).

## Relationship Operations

Handling relationships between tables is a central feature of DataLinq. From one-to-many to many-to-many relations, DataLinq has got you covered.

```csharp
// Fetch a department and its associated managers
var department = employeesDb.Query().Departments.Single(x => x.DeptNo == "d005");
var associatedManagers = department.Managers;
```

For more on relationship operations, including lazy loading and eager loading, check out the [relationships guide](#).

## CLI Operations

DataLinq's Command-Line Interface (CLI) is a powerful tool that lets you manage your database setup, generate models, and more, all from the command line.

- `datalinq create-database`: Set up a new database.
- `datalinq create-sql -o [output_file]`: Generate SQL scripts.
- `datalinq create-models`: Produce data models based on your database schema.
- `datalinq list`: View all available databases in your configuration.

For a comprehensive list of CLI commands and their usage, refer to the [CLI documentation](#).

## Testing

Ensuring DataLinq's reliability and robustness is paramount. The library comes equipped with a comprehensive set of unit tests that cover a wide range of scenarios, from basic CRUD operations to complex relationship handling and concurrency tests. Before any release, these tests are rigorously executed to guarantee that DataLinq remains bug-free and performs optimally. Users can also run these tests to verify the library's compatibility with specific environments or configurations.

## Contributing

DataLinq thrives on community contributions. Whether you're a seasoned developer or someone just starting out, your input is valuable. We welcome:

- Code contributions: Enhancements, bug fixes, or new features.
- Documentation: Updates, corrections, or translations.
- Feature suggestions: Ideas for new functionalities or improvements.

Before making a contribution, please check out our [Contributing Guide](#) for guidelines and best practices.

## License

DataLinq is licensed under the MIT License. This license allows for free use, modification, and distribution of the software, provided that the copyright notice and disclaimer are retained. For more details and the full license text, refer to the [LICENSE](#) file.

================
File: src/DataLinq.Benchmark/BenchmarkSetup.cs
================
using BenchmarkDotNet.Attributes;
using DataLinq.Config;
using DataLinq.Metadata;
using DataLinq.MySql;
using DataLinq.SQLite;
using DataLinq.Tests.Models.Allround;
using Microsoft.Extensions.Logging;
using Serilog;

namespace DataLinq.Benchmark;

public class BenchmarkSetup
{
    private Database<AllroundBenchmark> db;
    private DataLinqDatabaseConnection conn;

    public BenchmarkSetup()
    {
        MySQLProvider.RegisterProvider();
        SQLiteProvider.RegisterProvider();

        // Configure Serilog
        Log.Logger = new LoggerConfiguration()
            .MinimumLevel.Warning()
            .WriteTo.File("D:\\git\\DataLinq\\logs\\benchmark.txt", rollingInterval: RollingInterval.Day, flushToDiskInterval: TimeSpan.FromSeconds(1))
            .CreateLogger();

        // Set up logging with Serilog
        var loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.ClearProviders();
            builder.AddSerilog();
        });

        //var logger = loggerFactory.CreateLogger<Program>();

        //var loggerFactory = LoggerFactory.Create(builder => builder.AddDebug().SetMinimumLevel(LogLevel.Debug));
        DataLinqConfig config = DataLinqConfig.FindAndReadConfigs("D:\\git\\DataLinq\\src\\DataLinq.Tests.Models\\datalinq.json", Console.WriteLine);
        conn = config.Databases.Single(x => x.Name == "AllroundBenchmark").Connections.Single(x => x.Type == DatabaseType.MySQL);
        db = new MySqlDatabase<AllroundBenchmark>(conn.ConnectionString.Original, conn.DataSourceName, loggerFactory);
    }

    [GlobalSetup]
    public void Setup()
    {
        if (!db.FileOrServerExists() || !db.Exists())
        {
            PluginHook.CreateDatabaseFromMetadata(conn.Type,
                db.Provider.Metadata, conn.DataSourceName, conn.ConnectionString.Original, true);
        }

        // Check if the database has already been populated
        if (!IsDatabasePopulated())
        {
            AllroundBenchmarkBogusData.FillAllroundBenchmarkWithBogusData(db);
        }
    }

    private bool IsDatabasePopulated()
    {
        // This is a simple check to see if the Users table has any data
        // You can expand this check to other primary tables if desired
        return db.Query().Users.Any();
    }

    [Benchmark]
    public void LoadAllUsers()
    {
        for (int i = 0; i < 1000; i++)
        {
            var reviews = db.Query().Productreviews.Take(1000).ToArray();

            foreach (var user in reviews.Select(x => x.users))
            {
                var orders = user.orders.ToList();
                //Console.WriteLine($"Num orders for user {user.UserName}: {user.orders.Count()}");
            }
        }
    }

    [Benchmark]
    public void YourBenchmarkMethod()
    {
        var users = db.Query().Users.Where(x => x.UserName.StartsWith("John")).ToList();
        var orders = db.Query().Orders.Where(x => x.OrderTimestamp < DateTime.Now).ToList();

        Console.WriteLine($"{users.Count} users");
        Console.WriteLine($"{orders.Count} orders");

    }

    // ... Your benchmarking methods ...

    // And the rest of your FillAllroundBenchmarkWithBogusData method ...
}

================
File: src/DataLinq.Benchmark/Program.cs
================
using System.Security.Cryptography;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

namespace DataLinq.Benchmark;

public class Md5VsSha256
{
    private const int N = 10000;
    private readonly byte[] data;

    private readonly SHA256 sha256 = SHA256.Create();
    private readonly MD5 md5 = MD5.Create();

    public Md5VsSha256()
    {
        data = new byte[N];
        new Random(42).NextBytes(data);
    }

    [Benchmark]
    public byte[] Sha256() => sha256.ComputeHash(data);

    [Benchmark]
    public byte[] Md5() => md5.ComputeHash(data);
}

public class Program
{
    public static void Main(string[] args)
    {
        var setup = new BenchmarkSetup();
        setup.Setup();
        setup.LoadAllUsers();


        //var summary = BenchmarkRunner.Run<BenchmarkSetup>();

    }
}

================
File: src/DataLinq.Benchmark/Tests.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using BenchmarkDotNet.Attributes;

namespace DataLinq.Benchmark;
internal static class Tests
{
    //[Benchmark]
    //public void LoadAllUsers()
    //{
    //    var users = db.Query().Users.ToList();
    //}

    //[Benchmark]
    //public void YourBenchmarkMethod()
    //{
    //    var users = db.Query().Users.Where(x => x.UserName.StartsWith("John")).ToList();
    //    var orders = db.Query().Orders.Where(x => x.OrderTimestamp < DateTime.Now).ToList();

    //    Console.WriteLine($"{users.Count} users");
    //    Console.WriteLine($"{orders.Count} orders");

    //}
}

================
File: src/DataLinq.Blazor/Code/DL.cs
================
using DataLinq.MySql;
using DataLinq.SQLite;
using DataLinq.Tests.Models;
using DataLinq.Tests.Models.Employees;

namespace DataLinq.Blazor.Code;

public static class DL
{
    public static MySqlDatabase<EmployeesDb> Employees { get; set; }

    public static void Initialize(IConfiguration configuration)
    {
        MySQLProvider.RegisterProvider();
        SQLiteProvider.RegisterProvider();
        Employees = new MySqlDatabase<EmployeesDb>(configuration.GetConnectionString("employees"));
    }
}

================
File: src/DataLinq.Blazor/Code/RandomTableData.cs
================
using DataLinq.MySql;
using DataLinq.Tests.Models;
using DataLinq.Tests.Models.Employees;

namespace DataLinq.Blazor.Code;
public class RandomTableData
{
    private readonly MySqlDatabase<EmployeesDb> _db;
    private static Random _random = new Random();

    public RandomTableData(MySqlDatabase<EmployeesDb> db)
    {
        _db = db;
    }

    public IEnumerable<object> GetRandomData()
    {
        var tables = new List<Func<IEnumerable<object>>>
        {
            () => _db.Query().current_dept_emp.Skip(RandomNumber(0,1000)).Take(RandomNumber(1, 1000)).ToList().Cast<object>(),
            () => _db.Query().Departments.Skip(RandomNumber(0,10)).Take(RandomNumber(1, 1000)).ToList().Cast<object>(),
            () => _db.Query().DepartmentEmployees.Skip(RandomNumber(0, 10000)).Take(RandomNumber(1, 1000)).ToList().Cast<object>(),
            () => _db.Query().dept_emp_latest_date.Skip(RandomNumber(0, 10000)).Take(RandomNumber(1, 1000)).ToList().Cast<object>(),
            () => _db.Query().Managers.Skip(RandomNumber(0, 1000)).Take(RandomNumber(1, 1000)).ToList().Cast<object>(),
            () => _db.Query().Employees.Skip(RandomNumber(0, 1000)).Take(RandomNumber(1, 1000)).ToList().Cast<object>(),
            () => _db.Query().salaries.Skip(RandomNumber(0, 1000)).Take(RandomNumber(1, 1000)).ToList().Cast<object>(),
            () => _db.Query().titles.Skip(RandomNumber(0, 1000)).Take(RandomNumber(1, 1000)).ToList().Cast<object>(),
        };

        var selectedTableIndex = _random.Next(tables.Count);
        return tables[selectedTableIndex]();
    }

    private static int RandomNumber(int min, int max)
    {
        return _random.Next(min, max);
    }
}

================
File: src/DataLinq.Blazor/Program.cs
================
using DataLinq.Blazor.Code;
using DataLinq.Blazor.Components;

var builder = WebApplication.CreateBuilder(args);

var configuration = builder.Configuration;
DL.Initialize(configuration);

// Add services to the container.
builder.Services.AddRazorComponents()
    .AddInteractiveServerComponents();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error", createScopeForErrors: true);
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

app.UseHttpsRedirection();

app.UseStaticFiles();
app.UseAntiforgery();

app.MapRazorComponents<App>()
    .AddInteractiveServerRenderMode();

app.Run();

================
File: src/DataLinq.CLI/Program.cs
================
using CommandLine;
using DataLinq.Config;
using DataLinq.MySql;
using DataLinq.SQLite;
using DataLinq.Tools;
using ThrowAway;

namespace DataLinq.CLI;

static class Program
{
    [Verb("create-database", HelpText = "Create selected database")]
    public class CreateDatabaseOptions : CreateOptions
    {
    }

    [Verb("create-sql", HelpText = "Create SQL for selected database")]
    public class CreateSqlOptions : CreateOptions
    {
        [Option('o', "output", HelpText = "Path to output file", Required = true)]
        public string OutputFile { get; set; }
    }

    [Verb("create-models", HelpText = "Create models for selected database")]
    public class CreateModelsOptions : CreateOptions
    {
        [Option('s', "skip-source", HelpText = "Skip reading from source models", Required = false)]
        public bool SkipSource { get; set; }
    }

    public class CreateOptions : Options
    {
        [Option('d', "datasource", HelpText = "Name of the database instance on the server or file on disk, depending on the connection type", Required = false)]
        public string DataSource { get; set; }

        [Option('n', "name", HelpText = "Name in the DataLinq config file", Required = false)]
        public string Name { get; set; }

        [Option('t', "type", HelpText = "Which database connection type to create the database for", Required = false)]
        public string ConnectionType { get; set; }
    }


    [Verb("list", HelpText = "List all databases in config.")]
    public class ListOptions : Options
    {
    }

    public class Options
    {
        [Option('v', "verbose", Required = false, HelpText = "Set output to verbose messages.")]
        public bool Verbose { get; set; }

        [Option('c', "config", Required = false, HelpText = "Path to config file")]
        public string ConfigPath { get; set; }
    }

    static bool Verbose;
    static string ConfigPath = $"{Directory.GetCurrentDirectory()}{Path.DirectorySeparatorChar}datalinq.json";
    static DataLinqConfig ConfigFile;
    static string ConfigBasePath => ConfigFile.BasePath;

    static public bool ReadConfig()
    {
        var config = DataLinqConfig.FindAndReadConfigs(ConfigPath, Console.WriteLine);

        if (config.HasFailed)
        {
            Console.WriteLine(config.Failure);
            return false;
        }

        Console.WriteLine();
        ConfigFile = config.Value;

        return true;
    }

    static void Main(string[] args)
    {
        MySQLProvider.RegisterProvider();
        SQLiteProvider.RegisterProvider();


        var parserResult = Parser.Default
            .ParseArguments<Options, CreateModelsOptions, CreateSqlOptions, CreateDatabaseOptions, ListOptions>(args);

        parserResult
            .WithParsed<Options>(options =>
            {
                if (options.Verbose)
                {
                    Verbose = true;
                    Console.WriteLine($"Verbose output enabled.");
                }

                if (options.ConfigPath != null)
                {
                    ConfigPath = Path.GetFullPath(options.ConfigPath);
                    //Console.WriteLine($"Reading config from {ConfigPath}");
                }
            })
            .WithParsed<ListOptions>(options =>
            {
                if (ReadConfig() == false)
                    return;


                Console.WriteLine($"Databases in config:");
                foreach (var db in ConfigFile.Databases)
                {
                    Console.WriteLine($"{db.Name}");
                    Console.WriteLine("Connections:");
                    foreach (var connection in db.Connections)
                    {
                        Console.WriteLine($"{connection.Type} ({connection.DataSourceName})");
                    }

                    Console.WriteLine();

                    var reader = new ModelReader(Console.WriteLine);
                    var result = reader.Read(ConfigFile, ConfigBasePath);

                    if (result.HasFailed)
                    {
                        Console.WriteLine(result.Failure);
                        return;
                    }

                    //Console.WriteLine();
                }
            })
            .WithParsed<CreateModelsOptions>(options =>
            {
                if (ReadConfig() == false)
                    return;

                var result = ConfigFile.GetConnection(options.Name, ConfigReader.ParseDatabaseType(options.ConnectionType));
                if (result.HasFailed)
                {
                    Console.WriteLine(result.Failure);
                    return;
                }

                var (db, connection) = result.Value;
                var generator = new ModelGenerator(Console.WriteLine, new ModelGeneratorOptions
                {
                    OverwriteExistingModels = true,
                    ReadSourceModels = !options.SkipSource,
                    CapitalizeNames = db.CapitalizeNames,
                    Tables = db.Tables,
                    Views = db.Views
                });

                var databaseMetadata = generator.CreateModels(connection, ConfigBasePath, options.DataSource ?? connection.DataSourceName ?? options.Name);

                if (databaseMetadata.HasFailed)
                {
                    Console.WriteLine(databaseMetadata.Failure);
                    return;
                }
            })
            .WithParsed<CreateSqlOptions>(options =>
            {
                if (ReadConfig() == false)
                    return;

                var result = ConfigFile.GetConnection(options.Name, ConfigReader.ParseDatabaseType(options.ConnectionType));
                if (result.HasFailed)
                {
                    Console.WriteLine(result.Failure);
                    return;
                }

                var (db, connection) = result.Value;
                var generator = new SqlGenerator(Console.WriteLine, new SqlGeneratorOptions
                {
                });

                var sql = generator.Create(connection, ConfigBasePath, options.OutputFile);

                if (sql.HasFailed)
                {
                    Console.WriteLine(sql.Failure);
                    return;
                }
            })
            .WithParsed<CreateDatabaseOptions>(options =>
            {
                if (ReadConfig() == false)
                    return;

                var result = ConfigFile.GetConnection(options.Name, ConfigReader.ParseDatabaseType(options.ConnectionType));
                if (result.HasFailed)
                {
                    Console.WriteLine(result.Failure);
                    return;
                }

                var (db, connection) = result.Value;
                var generator = new DatabaseCreator(Console.WriteLine, new DatabaseCreatorOptions
                {
                });

                generator.Create(connection, ConfigBasePath, options.DataSource ?? connection.DataSourceName ?? options.Name);
            })
            .WithNotParsed(options =>
            {
                Console.WriteLine($"Usage: datalinq [command] -n name");
                //Console.WriteLine(HelpText.AutoBuild(parserResult, _ => _, _ => _));
            });
    }
}

================
File: src/DataLinq.Core/Attributes/AutoIncrementAttribute.cs
================
using System;

namespace DataLinq.Attributes;

[AttributeUsage(AttributeTargets.Property, Inherited = true, AllowMultiple = false)]
public sealed class AutoIncrementAttribute : Attribute
{
    public AutoIncrementAttribute()
    {

    }
}

================
File: src/DataLinq.Core/Attributes/CacheCleanupAttribute.cs
================
using System;

namespace DataLinq.Attributes;

public enum CacheCleanupType
{
    Seconds,
    Minutes,
    Hours,
    Days
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, Inherited = true, AllowMultiple = false)]
public sealed class CacheCleanupAttribute : Attribute
{
    public CacheCleanupAttribute(CacheCleanupType limitType, long amount)
    {
        LimitType = limitType;
        Amount = amount;
    }

    public CacheCleanupType LimitType { get; }
    public long Amount { get; }
}

================
File: src/DataLinq.Core/Attributes/CacheLimitAttribute.cs
================
using System;

namespace DataLinq.Attributes;

public enum CacheLimitType
{
    Rows,
    Ticks,
    Seconds,
    Minutes,
    Hours,
    Days,
    Bytes,
    Kilobytes,
    Megabytes,
    Gigabytes
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Property, Inherited = true, AllowMultiple = true)]
public sealed class CacheLimitAttribute : Attribute
{
    public CacheLimitAttribute(CacheLimitType limitType, long amount)
    {
        LimitType = limitType;
        Amount = amount;
    }

    public CacheLimitType LimitType { get; }
    public long Amount { get; }
}

================
File: src/DataLinq.Core/Attributes/ColumnAttribute.cs
================
using System;

namespace DataLinq.Attributes;

[AttributeUsage(AttributeTargets.Property, Inherited = true, AllowMultiple = false)]
public sealed class ColumnAttribute : Attribute
{
    public ColumnAttribute(string name)
    {
        Name = name;
    }

    public string Name { get; }
}

================
File: src/DataLinq.Core/Attributes/DatabaseAttribute.cs
================
using System;

namespace DataLinq.Attributes;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, Inherited = true, AllowMultiple = false)]
public sealed class DatabaseAttribute : Attribute
{
    public DatabaseAttribute(string name)
    {
        Name = name;
    }

    public string Name { get; }
}

================
File: src/DataLinq.Core/Attributes/DefaultAttribute.cs
================
using System;

namespace DataLinq.Attributes;

public enum DynamicFunctions
{
    /// <summary>
    /// Use the current date and time.
    /// MySQL/MariaDB: maps to CURRENT_TIMESTAMP.
    /// SQLite: maps to CURRENT_TIMESTAMP.
    /// </summary>
    CurrentTimestamp
}


[AttributeUsage(AttributeTargets.Property, Inherited = true, AllowMultiple = false)]
public class DefaultAttribute(object value) : Attribute
{
    public object Value { get; } = value ?? throw new ArgumentNullException(nameof(value));
}

[AttributeUsage(AttributeTargets.Property, Inherited = true, AllowMultiple = false)]
public class DefaultAttribute<T>(T value) : DefaultAttribute(value ?? throw new ArgumentNullException(nameof(value)))
{
    public new T Value => (T)base.Value;
}

[AttributeUsage(AttributeTargets.Property, Inherited = true, AllowMultiple = false)]
public class DefaultCurrentTimestampAttribute() : DefaultAttribute(DynamicFunctions.CurrentTimestamp)
{
    public DynamicFunctions DateTimeDefault => (DynamicFunctions)Value;
}

================
File: src/DataLinq.Core/Attributes/DefinitionAttribute.cs
================
using System;

namespace DataLinq.Attributes;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, Inherited = true, AllowMultiple = false)]
public sealed class DefinitionAttribute : Attribute
{
    public DefinitionAttribute(string sql)
    {
        Sql = sql;
    }

    public string Sql { get; }
}

================
File: src/DataLinq.Core/Attributes/EnumAttribute.cs
================
using System;

namespace DataLinq.Attributes;

[AttributeUsage(AttributeTargets.Property, Inherited = true, AllowMultiple = false)]
public sealed class EnumAttribute : Attribute
{
    public EnumAttribute(params string[] values)
    {
        Values = values;
    }

    public string[] Values { get; }
}

================
File: src/DataLinq.Core/Attributes/ForeignKeyAttribute.cs
================
using System;

namespace DataLinq.Attributes;

[AttributeUsage(AttributeTargets.Property, Inherited = true, AllowMultiple = true)]
public sealed class ForeignKeyAttribute : Attribute
{
    public ForeignKeyAttribute(string table, string column, string name)
    {
        Table = table;
        Column = column;
        Name = name;
    }

    public string Table { get; }
    public string Column { get; }
    public string Name { get; }
}

================
File: src/DataLinq.Core/Attributes/IndexAttribute.cs
================
using System;

namespace DataLinq.Attributes;

/// <summary>
/// Represents the underlying data structure or algorithm used by the index.
/// </summary>
public enum IndexType
{
    /// <summary>
    /// Standard B-tree based index common across MySQL, MSSQL, SQLite, and PostgreSQL.
    /// </summary>
    BTREE,

    /// <summary>
    /// Represents full-text search capabilities across MySQL, MSSQL, and SQLite.
    /// </summary>
    FULLTEXT,

    /// <summary>
    /// Represents hash-based index common to MySQL and PostgreSQL.
    /// </summary>
    HASH,

    /// <summary>
    /// Represents spatial index in MySQL.
    /// </summary>
    RTREE,

    /// <summary>
    /// Represents the clustered index in MSSQL, determining the physical order of data.
    /// </summary>
    CLUSTERED,

    /// <summary>
    /// Represents spatial indices across MySQL and MSSQL.
    /// </summary>
    SPATIAL,

    /// <summary>
    /// Represents MSSQL's columnstore index, storing data in a column-wise manner.
    /// </summary>
    COLUMNSTORE,

    /// <summary>
    /// Represents PostgreSQL's general inverted index, used for arrays, full-text search, etc.
    /// </summary>
    GIN,

    /// <summary>
    /// Represents PostgreSQL's generalized search tree.
    /// </summary>
    GIST,

    /// <summary>
    /// Represents PostgreSQL's Block Range INdexes, suitable for large tables with a natural sort order.
    /// </summary>
    BRIN
}

/// <summary>
/// Represents the logical or constraint-related characteristic of the index.
/// </summary>
public enum IndexCharacteristic
{
    /// <summary>
    /// Represents primary key constraint ensuring uniqueness and serving as a main identifier.
    /// </summary>
    PrimaryKey,

    /// <summary>
    /// Represents a foreign key constraint ensuring uniqueness and referencing another table.
    /// </summary>
    ForeignKey,

    /// <summary>
    /// Represents unique constraint ensuring all values in the index are distinct.
    /// </summary>
    Unique,

    /// <summary>
    /// Represents a standard non-unique index.
    /// </summary>
    Simple,

    /// <summary>
    /// Represents MSSQL's filtered index, which can be seen as a partial index.
    /// </summary>
    FILTERED,

    /// <summary>
    /// Represents PostgreSQL's exclusion constraint, ensuring specific non-overlapping properties.
    /// </summary>
    EXCLUSION,

    /// <summary>
    /// Represents an index that only exists internally in Datalinq.
    /// </summary>
    VirtualDataLinq
}

/// <summary>
/// Represents an index attribute for a database column.
/// </summary>
[AttributeUsage(AttributeTargets.Property, Inherited = true, AllowMultiple = true)]
public sealed class IndexAttribute : Attribute
{
    /// <summary>
    /// Initializes a new instance of the <see cref="IndexAttribute"/> class with the specified name, characteristic, type, and columns.
    /// </summary>
    /// <param name="name">The name of the index.</param>
    /// <param name="characteristic">The characteristic of the index.</param>
    /// <param name="type">The type of the index.</param>
    /// <param name="columns">The columns associated with the index.</param>
    public IndexAttribute(string name, IndexCharacteristic characteristic, IndexType type, params string[] columns)
    {
        if (string.IsNullOrWhiteSpace(name)) throw new ArgumentException("Index name cannot be empty.", nameof(name));
        //if (columns == null || columns.Length == 0) throw new ArgumentException("An index must have at least one column.", nameof(columns));

        Name = name;
        Type = type;
        Characteristic = characteristic;
        Columns = columns;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="IndexAttribute"/> class with the specified name, characteristic, and columns. The type defaults to BTREE.
    /// </summary>
    /// <param name="name">The name of the index.</param>
    /// <param name="characteristic">The characteristic of the index.</param>
    /// <param name="columns">The columns associated with the index.</param>
    public IndexAttribute(string name, IndexCharacteristic characteristic, params string[] columns)
        : this(name, characteristic, IndexType.BTREE, columns) { }

    /// <summary>
    /// Gets the name of the index.
    /// </summary>
    public string Name { get; }

    /// <summary>
    /// Gets the type of the index.
    /// </summary>
    public IndexType Type { get; }

    /// <summary>
    /// Gets the characteristic of the index.
    /// </summary>
    public IndexCharacteristic Characteristic { get; }

    /// <summary>
    /// Gets the columns associated with the index.
    /// </summary>
    public string[] Columns { get; }
}

================
File: src/DataLinq.Core/Attributes/IndexCacheAttribute.cs
================
using System;

namespace DataLinq.Attributes;

public enum IndexCacheType
{
    None,
    All,
    MaxAmountRows,
}

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Property, Inherited = true, AllowMultiple = true)]
public sealed class IndexCacheAttribute : Attribute
{
    public IndexCacheAttribute(IndexCacheType type)
    {
        Type = type;
    }

    public IndexCacheAttribute(IndexCacheType type, int amount)
    {
        Type = type;
        Amount = amount;
    }

    public IndexCacheType Type { get; }
    public int? Amount { get; }
}

================
File: src/DataLinq.Core/Attributes/InterfaceAttribute.cs
================
using System;

namespace DataLinq.Attributes;

[AttributeUsage(AttributeTargets.Class, Inherited = true, AllowMultiple = false)]
public class InterfaceAttribute : Attribute
{
    public InterfaceAttribute(bool generateInterface = true)
    {
        GenerateInterface = generateInterface;
    }

    public InterfaceAttribute(string name)
    {
        Name = name;
        GenerateInterface = true;
    }

    public InterfaceAttribute(string name, bool generateInterface = true)
    {
        Name = name;
        GenerateInterface = generateInterface;
    }

    public string? Name { get; }
    public bool GenerateInterface { get; }
}

public class InterfaceAttribute<T> : InterfaceAttribute
{
    public InterfaceAttribute(bool generateInterface = true) : base(typeof(T).Name, generateInterface) { }
}

================
File: src/DataLinq.Core/Attributes/NullableAttribute.cs
================
using System;

namespace DataLinq.Attributes;

[AttributeUsage(AttributeTargets.Property, Inherited = true, AllowMultiple = false)]
public sealed class NullableAttribute : Attribute
{
    public NullableAttribute()
    {

    }
}

================
File: src/DataLinq.Core/Attributes/PrimaryKeyAttribute.cs
================
using System;

namespace DataLinq.Attributes;

[AttributeUsage(AttributeTargets.Property, Inherited = true, AllowMultiple = false)]
public sealed class PrimaryKeyAttribute : Attribute
{
    public PrimaryKeyAttribute()
    {

    }
}

================
File: src/DataLinq.Core/Attributes/RelationAttribute.cs
================
using System;

namespace DataLinq.Attributes;

[AttributeUsage(AttributeTargets.Property, Inherited = true, AllowMultiple = true)]
public sealed class RelationAttribute : Attribute
{
    public RelationAttribute(string table, string column, string? name = null)
    {
        Table = table;
        Columns = [column];
        Name = name;
    }

    public RelationAttribute(string table, string[] column, string? name = null)
    {
        Table = table;
        Columns = column;
        Name = name;
    }

    public string Table { get; }
    public string[] Columns { get; }
    public string? Name { get; }
}

================
File: src/DataLinq.Core/Attributes/TableAttribute.cs
================
using System;

namespace DataLinq.Attributes;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, Inherited = true, AllowMultiple = false)]
public sealed class TableAttribute : Attribute
{
    public TableAttribute(string name)
    {
        Name = name;
    }

    public string Name { get; }
}

================
File: src/DataLinq.Core/Attributes/TypeAttribute.cs
================
using System;
using DataLinq.Metadata;

namespace DataLinq.Attributes;

[AttributeUsage(AttributeTargets.Property, Inherited = true, AllowMultiple = true)]
public sealed class TypeAttribute : Attribute
{
    public TypeAttribute(string name)
    {
        DatabaseType = DatabaseType.Default;
        Name = name;
    }

    public TypeAttribute(string name, long length)
    {
        DatabaseType = DatabaseType.Default;
        Name = name;
        Length = length;
    }

    public TypeAttribute(string name, bool signed)
    {
        DatabaseType = DatabaseType.Default;
        Name = name;
        Signed = signed;
    }

    public TypeAttribute(string name, long length, bool signed)
    {
        DatabaseType = DatabaseType.Default;
        Name = name;
        Length = length;
        Signed = signed;
    }

    public TypeAttribute(string name, long length, int decimals, bool signed)
    {
        DatabaseType = DatabaseType.Default;
        Name = name;
        Length = length;
        Decimals = decimals;
        Signed = signed;
    }

    public TypeAttribute(DatabaseType databaseType, string name)
    {
        DatabaseType = databaseType;
        Name = name;
    }

    public TypeAttribute(DatabaseType databaseType, string name, long length)
    {
        DatabaseType = databaseType;
        Name = name;
        Length = length;
    }

    public TypeAttribute(DatabaseType databaseType, string name, long length, int decimals)
    {
        DatabaseType = databaseType;
        Name = name;
        Length = length;
        Decimals = decimals;
    }

    public TypeAttribute(DatabaseType databaseType, string name, bool signed)
    {
        DatabaseType = databaseType;
        Name = name;
        Signed = signed;
    }

    public TypeAttribute(DatabaseType databaseType, string name, long length, bool signed)
    {
        DatabaseType = databaseType;
        Name = name;
        Length = length;
        Signed = signed;
    }

    public TypeAttribute(DatabaseType databaseType, string name, long length, int decimals, bool signed)
    {
        DatabaseType = databaseType;
        Name = name;
        Length = length;
        Decimals = decimals;
        Signed = signed;
    }

    public TypeAttribute(DatabaseType databaseType, string name, long? length, int? decimals, bool? signed)
    {
        DatabaseType = databaseType;
        Name = name;
        Length = length;
        Decimals = decimals;
        Signed = signed;
    }

    public TypeAttribute(DatabaseColumnType dbType)
    {
        DatabaseType = dbType.DatabaseType;
        Name = dbType.Name;
        Length = dbType.Length;
        Signed = dbType.Signed;
    }

    public long? Length { get; }
    public int? Decimals { get; }
    public DatabaseType DatabaseType { get; }
    public string Name { get; }
    public bool? Signed { get; }
}

================
File: src/DataLinq.Core/Attributes/UseCacheAttribute.cs
================
using System;

namespace DataLinq.Attributes;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Property, Inherited = true, AllowMultiple = false)]
public sealed class UseCacheAttribute : Attribute
{
    public UseCacheAttribute(bool useCache = true)
    {
        UseCache = useCache;
    }

    public bool UseCache { get; }
}

================
File: src/DataLinq.Core/Attributes/ViewAttribute.cs
================
using System;

namespace DataLinq.Attributes;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, Inherited = true, AllowMultiple = false)]
public sealed class ViewAttribute : Attribute
{
    public ViewAttribute(string name)
    {
        Name = name;
    }

    public string Name { get; }
}

================
File: src/DataLinq.Core/ErrorHandling/DLOptionFailure.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Extensions.Helpers;
using DataLinq.Interfaces;

namespace DataLinq.ErrorHandling;

public enum DLFailureType
{
    Unspecified,
    Exception,
    NotImplemented,
    InvalidArgument,
    UnexpectedNull,
    InvalidType,
    Aggregation,
    FileNotFound
}

public class FailureWithDefinition<T>
{
    public IDefinition Definition { get; }
    public T Failure { get; }
    public FailureWithDefinition(T failure, IDefinition definition)
    {
        Failure = failure;
        Definition = definition ?? throw new ArgumentNullException(nameof(definition));
    }
    public override string ToString()
    {
        if (Definition.CsFile == null)
            return $"{Failure} in {Definition}";

        return $"{Failure} in {Definition}, {Definition.CsFile?.FullPath}";
    }
}

public abstract class IDLOptionFailure
{
    public static implicit operator string(IDLOptionFailure optionFailure) =>
        optionFailure.ToString();

    public static implicit operator IDLOptionFailure(string failure) =>
        DLOptionFailure.Fail(failure);

    public static implicit operator IDLOptionFailure(List<IDLOptionFailure> optionFailures) =>
        DLOptionFailure.AggregateFail(optionFailures);

    //public static implicit operator Option<T, IDLOptionFailure>(List<IDLOptionFailure> optionFailures) =>
    //    Option.Fail<T, IDLOptionFailure>(DLOptionFailure.AggregateFail(optionFailures));
}

public static class DLOptionFailure
{
    public static DLOptionFailure<T> Fail<T>(T failure) =>
        new(failure);

    public static DLOptionFailure<FailureWithDefinition<T>> Fail<T>(T failure, IDefinition definition) =>
        new(new FailureWithDefinition<T>(failure, definition));

    public static DLOptionFailure<T> Fail<T>(DLFailureType type, T failure) =>
        new(type, failure);

    public static DLOptionFailure<FailureWithDefinition<T>> Fail<T>(DLFailureType type, T failure, IDefinition definition) =>
        new(type, new FailureWithDefinition<T>(failure, definition));

    public static DLOptionFailure<T> Fail<T>(T failure, IEnumerable<IDLOptionFailure> innerFailures) =>
        new(failure, innerFailures);

    public static DLOptionFailure<FailureWithDefinition<T>> Fail<T>(T failure, IDefinition definition, IEnumerable<IDLOptionFailure> innerFailures) =>
        new(new FailureWithDefinition<T>(failure, definition), innerFailures);

    public static DLOptionFailure<T> Fail<T>(DLFailureType type, T failure, IEnumerable<IDLOptionFailure> innerFailures) =>
        new(type, failure, innerFailures);

    public static DLOptionFailure<FailureWithDefinition<T>> Fail<T>(DLFailureType type, T failure, IDefinition definition, IEnumerable<IDLOptionFailure> innerFailures) =>
        new(type, new FailureWithDefinition<T>(failure, definition), innerFailures);

    public static DLOptionFailure<string> AggregateFail(IEnumerable<IDLOptionFailure> innerFailures) =>
        new("", innerFailures);
}

public class DLOptionFailure<T> : IDLOptionFailure
{
    public DLFailureType Type { get; }
    public T Failure { get; }
    public IDLOptionFailure[] InnerFailures { get; } = [];

    public DLOptionFailure(T failure)
    {
        Type = failure is Exception ? DLFailureType.Exception : DLFailureType.Unspecified;
        Failure = failure;
    }

    public DLOptionFailure(DLFailureType type, T failure)
    {
        Type = type;
        Failure = failure;
    }

    public DLOptionFailure(T failure, IEnumerable<IDLOptionFailure> innerFailure)
    {
        Type = failure is Exception ? DLFailureType.Exception : DLFailureType.Aggregation;
        Failure = failure;
        InnerFailures = [.. innerFailure];
    }

    public DLOptionFailure(DLFailureType type, T failure, IEnumerable<IDLOptionFailure> innerFailure)
    {
        Type = type;
        Failure = failure;
        InnerFailures = [.. innerFailure];
    }

    public override string ToString()
    {
        if (InnerFailures.Length == 0)
            return $"[{Type}] {Failure?.ToString()}";

        var innerFailureOutput = InnerFailures.ToJoinedString("\n");

        if (Failure is string sFailure && string.IsNullOrEmpty(sFailure))
            return $"{innerFailureOutput}";
        else
            return $"{innerFailureOutput}\n  {Failure?.ToString()}";
    }

    public static implicit operator T(DLOptionFailure<T> optionFailure) =>
        optionFailure.Failure;

    public static implicit operator DLOptionFailure<T>(T failure) =>
        DLOptionFailure.Fail(failure);
}

================
File: src/DataLinq.Core/Extensions/Helpers/LinqExtensions.cs
================
using System;
using System.Collections.Generic;

namespace DataLinq.Extensions.Helpers;

internal static class LinqExtensions
{
    internal static string ToJoinedString<T>(this IEnumerable<T> source, string separator = "\n") =>
        string.Join(separator, source);

    //https://stackoverflow.com/a/11463800
    internal static IEnumerable<List<T>> SplitList<T>(this List<T> locations, int nSize = 30)
    {
        for (int i = 0; i < locations.Count; i += nSize)
        {
            yield return locations.GetRange(i, Math.Min(nSize, locations.Count - i));
        }
    }

    internal static IEnumerable<T> Yield<T>(this T item)
    {
#pragma warning disable RCS1165 // Unconstrained type parameter checked for null.
        if (item != null)
#pragma warning restore RCS1165 // Unconstrained type parameter checked for null.
            yield return item;
    }
}

================
File: src/DataLinq.Core/Extensions/Helpers/StringExtensions.cs
================
using System;

namespace DataLinq.Extensions.Helpers;

internal static class StringExtensions
{
    //https://stackoverflow.com/a/4405876
    internal static string FirstCharToUpper(this string input) =>
        input switch
        {
            null => throw new ArgumentNullException(nameof(input)),
            "" => throw new ArgumentException($"{nameof(input)} cannot be empty", nameof(input)),
            _ => string.Concat(input[0].ToString().ToUpper(), input.Substring(1))
        };
}

================
File: src/DataLinq.Core/Factories/Generator/GeneratorFileFactory.cs
================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using DataLinq.Attributes;
using DataLinq.Core.Factories;
using DataLinq.Extensions.Helpers;
using Microsoft.CodeAnalysis;

namespace DataLinq.Metadata;

public class GeneratorFileFactoryOptions
{
    public string? NamespaceName { get; set; } = null;
    public string Tab { get; set; } = "    ";
    public bool UseRecords { get; set; } = false;
    public bool UseFileScopedNamespaces { get; set; } = false;
    public bool UseNullableReferenceTypes { get; set; } = false;
    public bool SeparateTablesAndViews { get; set; } = false;
    public List<string> Usings { get; set; } = new List<string> { "System", "System.Diagnostics.CodeAnalysis", "DataLinq", "DataLinq.Interfaces", "DataLinq.Attributes", "DataLinq.Mutation" };
}

public class GeneratorFileFactory
{
    private string namespaceTab;
    private string tab;

    public GeneratorFileFactoryOptions Options { get; }

    public GeneratorFileFactory(GeneratorFileFactoryOptions options)
    {
        this.Options = options;
        this.Options.UseRecords = false;

        namespaceTab = options.UseFileScopedNamespaces ? "" : options.Tab;
        tab = options.Tab;
    }

    public IEnumerable<(string path, string contents)> CreateModelFiles(DatabaseDefinition database)
    {
        var dbCsTypeName = database.TableModels.Any(x => x.Model.CsType.Name == database.CsType.Name)
            ? $"{database.CsType.Name}Db"
            : database.CsType.Name;

        foreach (var table in database.TableModels.Where(x => !x.IsStub))
        {
            var namespaceName = Options.NamespaceName ?? table.Model.CsType.Namespace;
            if (namespaceName == null)
                throw new Exception($"Namespace is null for '{table.Model.CsType.Name}'");

            var usings = Options.Usings
                .Concat(table.Model.Usings?.Select(x => x.FullNamespaceName) ?? new List<string>())
                .Concat(table.Model.RelationProperties.Values
                    .Where(x => x.RelationPart.Type == RelationPartType.CandidateKey)
                    .Select(x => "System.Collections.Generic"))
                .Distinct()
                .Where(x => x != null)
                .Where(name => name != namespaceName)
                .Select(name => (name.StartsWith("System"), name))
                .OrderByDescending(x => x.Item1)
                .ThenBy(x => x.name)
                .Select(x => x.name);


            var file =
                FileHeader(namespaceName, Options.UseFileScopedNamespaces, usings)
                .Concat(ModelFileContents(table.Model, Options))
                .Concat(FileFooter(Options.UseFileScopedNamespaces))
                .ToJoinedString("\n");

            var path = GetFilePath(table);

            yield return (path, file);
        }
    }

    private IEnumerable<string> ModelFileContents(ModelDefinition model, GeneratorFileFactoryOptions options)
    {
        var valueProps = model.ValueProperties.Values
            .OrderBy(x => x.Type)
            .ThenByDescending(x => x.Attributes.Any(x => x is PrimaryKeyAttribute))
            .ThenByDescending(x => x.Attributes.Any(x => x is ForeignKeyAttribute))
            .ThenBy(x => x.PropertyName)
            .ToList();

        var relationProps = model.RelationProperties.Values
            .OrderBy(x => x.Type)
            .ThenByDescending(x => x.Attributes.Any(x => x is PrimaryKeyAttribute))
            .ThenByDescending(x => x.Attributes.Any(x => x is ForeignKeyAttribute))
            .ThenBy(x => x.PropertyName)
            .ToList();

        if (model.ModelInstanceInterface != null)
            foreach (var row in WriteInterface(model, model.ModelInstanceInterface.Value, options, valueProps))
                yield return row;

        foreach (var row in WriteBaseClassPartial(model, options))
            yield return row;

        foreach (var row in ImmutableModelFileContents(model, Options, valueProps, relationProps))
            yield return row;

        if (model.Table.Type == TableType.Table)
        {
            foreach (var row in MutableModelFileContents(model, Options, valueProps, relationProps))
                yield return row;

            foreach (var row in ExtensionMethodsFileContents(model, Options))
                yield return row;
        }
    }

    private string GetFilePath(TableModel table)
    {
        var path = $"{table.Model.CsType.Name}.cs";

        if (Options.SeparateTablesAndViews)
            return table.Table.Type == TableType.Table
                ? $"Tables{Path.DirectorySeparatorChar}{path}"
                : $"Views{Path.DirectorySeparatorChar}{path}";

        return path;
    }

    private IEnumerable<string> WriteInterface(ModelDefinition model, CsTypeDeclaration modelInterface, GeneratorFileFactoryOptions options, List<ValueProperty> valueProps)
    {
        yield return $"{namespaceTab}public partial interface {modelInterface.Name}: IModelInstance<{model.Database.CsType.Name}>";
        yield return namespaceTab + "{";

        foreach (var valueProperty in valueProps)
        {
            var prefix = valueProperty.EnumProperty != null && valueProperty.EnumProperty.Value.DeclaredInClass
                ? $"{model.CsType.Name}."
                : "";

            yield return $"{namespaceTab}{tab}{prefix}{valueProperty.CsType.Name}{GetInterfacePropertyNullable(valueProperty)} {valueProperty.PropertyName} {{ get; }}";
        }

        if (model.Table.Type == TableType.Table)
        {
            yield return "";
            yield return $"{namespaceTab}{tab}Mutable{model.CsType.Name} Mutate() => this switch";
            yield return $"{namespaceTab}{tab}{{";
            yield return $"{namespaceTab}{tab}{tab}Mutable{model.CsType.Name} mutable => mutable,";
            yield return $"{namespaceTab}{tab}{tab}Immutable{model.CsType.Name} immutable => immutable.Mutate(),";
            yield return $"{namespaceTab}{tab}{tab}_ => throw new NotSupportedException($\"Call to 'Mutate' not supported for type '{{GetType()}}'\")";
            yield return $"{namespaceTab}{tab}}};";
            yield return "";
            yield return $"{namespaceTab}{tab}Mutable{model.CsType.Name} Mutate(Action<Mutable{model.CsType.Name}> changes) => this switch";
            yield return $"{namespaceTab}{tab}{{";
            yield return $"{namespaceTab}{tab}{tab}Mutable{model.CsType.Name} mutable => mutable.Mutate(changes),";
            yield return $"{namespaceTab}{tab}{tab}Immutable{model.CsType.Name} immutable => immutable.Mutate(changes),";
            yield return $"{namespaceTab}{tab}{tab}_ => throw new NotSupportedException($\"Call to 'Mutate' not supported for type '{{GetType()}}'\")";
            yield return $"{namespaceTab}{tab}}};";
        }

        yield return namespaceTab + "}";
        yield return "";
    }

    private IEnumerable<string> WriteBaseClassPartial(ModelDefinition model, GeneratorFileFactoryOptions options)
    {
        yield return $"{namespaceTab}public abstract partial {(options.UseRecords ? "record" : "class")} {model.CsType.Name}{(model.ModelInstanceInterface != null ? $": {model.ModelInstanceInterface.Value.Name}" : "")}";
        yield return namespaceTab + "{";

        if (model.Table.Type == TableType.Table)
        {
            var requiredProps = GetRequiredValueProperties(model);

            if (requiredProps.Any())
            {
                var constructorParams = requiredProps.Select(GetConstructorParam).ToJoinedString(", ");
                var constructorArgs = requiredProps.Select(v => ToCamelCase(v.Column.ValueProperty.PropertyName)).ToJoinedString(", ");

                yield return $"{namespaceTab}{tab}public static Mutable{model.CsType.Name} Mutate({constructorParams}) => new({constructorArgs});";
                yield return $"{namespaceTab}{tab}public static Mutable{model.CsType.Name} Mutate({constructorParams}, Action<Mutable{model.CsType.Name}> changes) => new Mutable{model.CsType.Name}({constructorArgs}).Mutate(changes);";
            }
            else
            {
                yield return $"{namespaceTab}{tab}public static Mutable{model.CsType.Name} Mutate() => new();";
                yield return $"{namespaceTab}{tab}public static Mutable{model.CsType.Name} Mutate(Action<Mutable{model.CsType.Name}> changes) => new Mutable{model.CsType.Name}().Mutate(changes);";
            }

            yield return $"{namespaceTab}{tab}public static Mutable{model.CsType.Name} Mutate({model.CsType.Name} model) => new Mutable{model.CsType.Name}(model);";
            yield return $"{namespaceTab}{tab}public static Mutable{model.CsType.Name} Mutate({model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes) => new Mutable{model.CsType.Name}(model).Mutate(changes);";

            if (model.ModelInstanceInterface != null)
            {
                yield return $"{namespaceTab}{tab}public static Mutable{model.CsType.Name} Mutate({model.ModelInstanceInterface.Value.Name} model) => model.Mutate();";
                yield return $"{namespaceTab}{tab}public static Mutable{model.CsType.Name} Mutate({model.ModelInstanceInterface.Value.Name} model, Action<Mutable{model.CsType.Name}> changes) => model.Mutate(changes);";
            }
        }

        yield return namespaceTab + "}";
        yield return "";
    }

    private IEnumerable<string> ImmutableModelFileContents(ModelDefinition model, GeneratorFileFactoryOptions options, List<ValueProperty> valueProps, List<RelationProperty> relationProps)
    {
        yield return $"{namespaceTab}public partial {(options.UseRecords ? "record" : "class")} Immutable{model.CsType.Name}(RowData rowData, DataSourceAccess dataSource) : {model.CsType.Name}(rowData, dataSource)";
        yield return namespaceTab + "{";

        foreach (var valueProperty in valueProps)
        {
            var c = valueProperty.Column;

            yield return $"{namespaceTab}{tab}private {GetCsTypeName(c.ValueProperty)}{GetImmutableFieldNullable(c.ValueProperty)} _{c.ValueProperty.PropertyName};";
            yield return $"{namespaceTab}{tab}public override {GetCsTypeName(c.ValueProperty)}{GetImmutablePropertyNullable(c.ValueProperty)} {c.ValueProperty.PropertyName} => _{c.ValueProperty.PropertyName} ??= ({GetCsTypeName(c.ValueProperty)}{GetImmutablePropertyNullable(c.ValueProperty)}){(IsImmutableGetterNullable(valueProperty) ? "GetNullableValue" : "GetValue")}(nameof({c.ValueProperty.PropertyName}));";
            yield return $"";
        }

        foreach (var relationProperty in relationProps)
        {
            var otherPart = relationProperty.RelationPart.GetOtherSide();

            if (relationProperty.RelationPart.Type == RelationPartType.ForeignKey)
            {
                yield return $"{namespaceTab}{tab}public override {otherPart.ColumnIndex.Table.Model.CsType.Name} {relationProperty.PropertyName} => GetForeignKey<{otherPart.ColumnIndex.Table.Model.CsType.Name}>(nameof({relationProperty.PropertyName}));";
            }
            else
            {
                yield return $"{namespaceTab}{tab}private IImmutableRelation<{otherPart.ColumnIndex.Table.Model.CsType.Name}>{GetUseNullableReferenceTypes()} _{relationProperty.PropertyName};";
                yield return $"{namespaceTab}{tab}public override IImmutableRelation<{otherPart.ColumnIndex.Table.Model.CsType.Name}> {relationProperty.PropertyName} => _{relationProperty.PropertyName} ??= GetImmutableRelation<{otherPart.ColumnIndex.Table.Model.CsType.Name}>(nameof({relationProperty.PropertyName}));";
            }

            yield return $"";
        }

        //if (model.Table.Type == TableType.Table)
        //    yield return $"{namespaceTab}{tab}public Mutable{model.CsType.Name} Mutate() => new(this);";

        yield return namespaceTab + "}";
    }

    private IEnumerable<string> MutableModelFileContents(ModelDefinition model, GeneratorFileFactoryOptions options, List<ValueProperty> valueProps, List<RelationProperty> relationProps)
    {
        List<string> interfaces = [$"IMutableInstance<{model.Database.CsType.Name}>"];

        if (model.ModelInstanceInterface != null)
            interfaces.Add(model.ModelInstanceInterface.Value.Name);

        yield return $"{namespaceTab}public partial {(options.UseRecords ? "record" : "class")} Mutable{model.CsType.Name} : Mutable<{model.CsType.Name}>, {interfaces.ToJoinedString(", ")}";
        yield return namespaceTab + "{";

        var defaultProps = GetDefaultValueProperties(model);

        // Parameterless constructor for users who prefer setting properties via setters.
        yield return $"{namespaceTab}{tab}public Mutable{model.CsType.Name}() : base()";
        yield return $"{namespaceTab}{tab}" + "{";

        foreach (var v in defaultProps)
            yield return $"{namespaceTab}{tab}{tab}this.{v.PropertyName} = {v.GetDefaultValue()};";

        yield return $"{namespaceTab}{tab}" + "}";

        // Constructor with required properties.
        var requiredProps = GetRequiredValueProperties(model);
        if (requiredProps.Any())
        {
            var paramList = requiredProps.Select(GetConstructorParam).ToJoinedString(", ");

            // Decorate this constructor with the SetsRequiredMembers attribute.
            yield return $"";
            yield return $"{namespaceTab}{tab}[SetsRequiredMembers]";
            yield return $"{namespaceTab}{tab}public Mutable{model.CsType.Name}({paramList}) : this()";
            yield return $"{namespaceTab}{tab}" + "{";

            foreach (var v in defaultProps)
                yield return $"{namespaceTab}{tab}{tab}this.{v.PropertyName} = {v.GetDefaultValue()};";

            // For each required property, assign the passed parameter to the property.
            foreach (var v in requiredProps)
                yield return $"{namespaceTab}{tab}{tab}this.{v.PropertyName} = {ToCamelCase(v.PropertyName)};";

            yield return $"{namespaceTab}{tab}" + "}";
        }

        // Constructor that accepts an immutable instance.
        yield return $"";
        yield return $"{namespaceTab}{tab}[SetsRequiredMembers]";
        yield return $"{namespaceTab}{tab}public Mutable{model.CsType.Name}({model.CsType.Name} immutable{model.CsType.Name}) : base(immutable{model.CsType.Name}) {{}}";

        // Generate the properties as before.
        foreach (var valueProperty in valueProps)
        {
            var c = valueProperty.Column;
            yield return "";
            yield return $"{namespaceTab}{tab}public virtual {GetMutablePropertyRequired(c.ValueProperty)}{GetCsTypeName(c.ValueProperty)}{GetMutablePropertyNullable(c.ValueProperty)} {c.ValueProperty.PropertyName}";
            yield return $"{namespaceTab}{tab}" + "{";
            yield return $"{namespaceTab}{tab}{tab}get => ({GetCsTypeName(c.ValueProperty)}{GetMutablePropertyNullable(c.ValueProperty)})GetValue(nameof({c.ValueProperty.PropertyName}));";
            yield return $"{namespaceTab}{tab}{tab}set => SetValue(nameof({c.ValueProperty.PropertyName}), value);";
            yield return $"{namespaceTab}{tab}" + "}";
        }

        yield return namespaceTab + "}";
    }

    private IEnumerable<string> ExtensionMethodsFileContents(ModelDefinition model, GeneratorFileFactoryOptions options)
    {
        yield return $"{namespaceTab}public static class {model.CsType.Name}Extensions";
        yield return namespaceTab + "{";

        //Mutate
        yield return $"{namespaceTab}{tab}public static Mutable{model.CsType.Name} Mutate(this {model.CsType.Name} model) => model is null";
        yield return $"{namespaceTab}{tab}{tab}? throw new ArgumentNullException(nameof(model))";
        yield return $"{namespaceTab}{tab}{tab}: new(model);";
        yield return $"{namespaceTab}{tab}public static Mutable{model.CsType.Name} Mutate(this {model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes)";
        yield return $"{namespaceTab}{tab}{{";
        yield return $"{namespaceTab}{tab}{tab}if (model is null)";
        yield return $"{namespaceTab}{tab}{tab}{tab}throw new ArgumentNullException(nameof(model));";
        yield return $"{namespaceTab}{tab}{tab}";
        yield return $"{namespaceTab}{tab}{tab}var mutable = model.Mutate();";
        yield return $"{namespaceTab}{tab}{tab}changes(mutable);";
        yield return $"{namespaceTab}{tab}{tab}return mutable;";
        yield return $"{namespaceTab}{tab}}}";
        yield return $"{namespaceTab}{tab}public static Mutable{model.CsType.Name} Mutate(this Mutable{model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes)";
        yield return $"{namespaceTab}{tab}{{";
        yield return $"{namespaceTab}{tab}{tab}changes(model);";
        yield return $"{namespaceTab}{tab}{tab}return model;";
        yield return $"{namespaceTab}{tab}}}";

        // First, compute the required constructor parameters and argument list.
        var requiredProps = GetRequiredValueProperties(model);

        // MutateOrNew
        if (requiredProps.Any())
        {
            var constructorParams = requiredProps.Select(GetConstructorParam).ToJoinedString(", ");
            var constructorArgs = requiredProps.Select(v => ToCamelCase(v.Column.ValueProperty.PropertyName)).ToJoinedString(", ");

            yield return $"{namespaceTab}{tab}public static Mutable{model.CsType.Name} MutateOrNew(this {model.CsType.Name} model, {constructorParams}) => model is null ? new Mutable{model.CsType.Name}({constructorArgs}) : model.Mutate(x =>";
            yield return $"{namespaceTab}{tab}{{";
            foreach (var v in requiredProps)
                yield return $"{namespaceTab}{tab}{tab}x.{v.PropertyName} = {ToCamelCase(v.Column.ValueProperty.PropertyName)};";
            yield return $"{namespaceTab}{tab}}});";
            yield return $"{namespaceTab}{tab}public static Mutable{model.CsType.Name} MutateOrNew(this {model.CsType.Name} model, {constructorParams}, Action<Mutable{model.CsType.Name}> changes) => model.MutateOrNew({constructorArgs}).Mutate(changes);";
        }
        else
        {
            yield return $"{namespaceTab}{tab}public static Mutable{model.CsType.Name} MutateOrNew(this {model.CsType.Name} model) => model is null ? new() : new(model);";
            yield return $"{namespaceTab}{tab}public static Mutable{model.CsType.Name} MutateOrNew(this {model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes) => model is null ? new Mutable{model.CsType.Name}().Mutate(changes) : new Mutable{model.CsType.Name}(model).Mutate(changes);";
        }

        //Insert
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Insert<T>(this Mutable{model.CsType.Name} model, Database<T> database) where T : class, IDatabaseModel =>";
        yield return $"{namespaceTab}{tab}{tab}database.Commit(transaction => model.Insert(transaction));";
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Insert(this Mutable{model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes, Transaction transaction) =>";
        yield return $"{namespaceTab}{tab}{tab}transaction.Insert(model.Mutate(changes));";
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Insert<T>(this Mutable{model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes, Database<T> database) where T : class, IDatabaseModel =>";
        yield return $"{namespaceTab}{tab}{tab}database.Commit(transaction => model.Insert(changes, transaction));";
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Insert(this Transaction transaction, Mutable{model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes) =>";
        yield return $"{namespaceTab}{tab}{tab}model.Insert(changes, transaction);";

        //Update
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Update(this {model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes) =>";
        yield return $"{namespaceTab}{tab}{tab}model.GetDataSource().Provider.Commit(transaction => model.Update(changes, transaction));";
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Update(this {model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes, Transaction transaction) =>";
        yield return $"{namespaceTab}{tab}{tab}transaction.Update(model.Mutate(changes));";
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Update<T>(this Database<T> database, {model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes) where T : class, IDatabaseModel =>";
        yield return $"{namespaceTab}{tab}{tab}database.Commit(transaction => model.Update(changes, transaction));";
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Update(this Transaction transaction, {model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes) =>";
        yield return $"{namespaceTab}{tab}{tab}model.Update(changes, transaction);";
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Update<T>(this Mutable{model.CsType.Name} model, Database<T> database) where T : class, IDatabaseModel =>";
        yield return $"{namespaceTab}{tab}{tab}database.Commit(transaction => model.Update(transaction));";

        //Save
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Save(this {model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes) =>";
        yield return $"{namespaceTab}{tab}{tab}model.Update(changes);";
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Save(this {model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes, Transaction transaction) =>";
        yield return $"{namespaceTab}{tab}{tab}model.Update(changes, transaction);";
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Save<T>(this Database<T> database, {model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes) where T : class, IDatabaseModel =>";
        yield return $"{namespaceTab}{tab}{tab}database.Update(model, changes);";
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Save(this Transaction transaction, {model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes) =>";
        yield return $"{namespaceTab}{tab}{tab}model.Update(changes, transaction);";
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Save<T>(this {model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes, Database<T> database) where T : class, IDatabaseModel =>";
        yield return $"{namespaceTab}{tab}{tab}database.Commit(transaction => model.Save(changes, transaction));";

        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Save<T>(this Mutable{model.CsType.Name} model, Database<T> database) where T : class, IDatabaseModel =>";
        yield return $"{namespaceTab}{tab}{tab}database.Commit(transaction => model.Save(transaction));";
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Save(this Mutable{model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes, Transaction transaction) =>";
        yield return $"{namespaceTab}{tab}{tab}transaction.Save(model.Mutate(changes));";
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Save<T>(this Mutable{model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes, Database<T> database) where T : class, IDatabaseModel =>";
        yield return $"{namespaceTab}{tab}{tab}database.Commit(transaction => model.Save(changes, transaction));";
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Save(this Mutable{model.CsType.Name} model, Transaction transaction) =>";
        yield return $"{namespaceTab}{tab}{tab}transaction.Save(model);";
        yield return $"{namespaceTab}{tab}public static {model.CsType.Name} Save(this Transaction transaction, Mutable{model.CsType.Name} model, Action<Mutable{model.CsType.Name}> changes) =>";
        yield return $"{namespaceTab}{tab}{tab}model.Save(changes, transaction);";

        yield return namespaceTab + "}";
    }

    private string GetConstructorParam(ValueProperty property)
    {
        var typeName = GetCsTypeName(property);
        var nullable = GetMutablePropertyNullable(property);
        var paramName = ToCamelCase(property.PropertyName);

        return $"{typeName}{nullable} {paramName}";
    }

    private List<ValueProperty> GetRequiredValueProperties(ModelDefinition model)
    {
        // Gather the required value properties for the mutable constructor.
        return model.ValueProperties.Values
            .OrderBy(x => x.Type)
            .ThenByDescending(x => x.Attributes.Any(a => a is PrimaryKeyAttribute))
            .ThenByDescending(x => x.Attributes.Any(a => a is ForeignKeyAttribute))
            .ThenBy(x => x.PropertyName)
            .Where(v => IsMutablePropertyRequired(v.Column.ValueProperty))
            .ToList();
    }

    private List<ValueProperty> GetDefaultValueProperties(ModelDefinition model)
    {
        // Gather the required value properties for the mutable constructor.
        return model.ValueProperties.Values
            .OrderBy(x => x.Type)
            .ThenByDescending(x => x.Attributes.Any(a => a is PrimaryKeyAttribute))
            .ThenByDescending(x => x.Attributes.Any(a => a is ForeignKeyAttribute))
            .ThenBy(x => x.PropertyName)
            .Where(x => x.Column.ValueProperty.Attributes.Any(a => a is DefaultAttribute))
            .ToList();
    }

    private string ToCamelCase(string s)
    {
        if (string.IsNullOrEmpty(s))
            return s;

        // Check if the string is all uppercase
        if (s.ToUpperInvariant() == s)
            return s.ToLowerInvariant();

        // Regular camel casing for mixed-case strings
        return char.ToLowerInvariant(s[0]) + s.Substring(1);
    }

    private string GetCsTypeName(ValueProperty property)
    {
        string name = string.Empty;

        if (property.EnumProperty?.DeclaredInClass == true)
            name += $"{property.Model.CsType.Name}.";

        name += property.CsType.Name;

        return name;
    }

    private string GetImmutablePropertyNullable(ValueProperty property)
    {
        return IsImmutablePropertyNullable(property) ? "?" : "";
    }

    private string GetMutablePropertyNullable(ValueProperty property)
    {
        return IsInterfacePropertyNullable(property) ? "?" : "";
    }

    private string GetMutablePropertyRequired(ValueProperty property)
    {
        return IsMutablePropertyRequired(property) ? "required " : "";
    }

    private string GetImmutableFieldNullable(ValueProperty property)
    {
        return IsImmutableFieldNullable(property) ? "?" : "";
    }

    private string GetUseNullableReferenceTypes()
    {
        return Options.UseNullableReferenceTypes ? "?" : "";
    }

    private string GetInterfacePropertyNullable(ValueProperty property)
    {
        return IsInterfacePropertyNullable(property) ? "?" : "";
    }

    private bool IsInterfacePropertyNullable(ValueProperty property)
    {
        return (Options.UseNullableReferenceTypes || property.CsNullable) &&
            (property.Column.Nullable || property.Column.AutoIncrement || property.HasDefaultValue());
    }

    private bool IsMutablePropertyRequired(ValueProperty property)
    {
        return !property.CsNullable &&
               !property.Column.Nullable &&
               !property.Column.AutoIncrement &&
               !property.Column.ForeignKey &&
               !property.HasDefaultValue();
    }

    private bool IsImmutablePropertyNullable(ValueProperty property)
    {
        return property.CsNullable || property.Column.AutoIncrement;
    }

    private bool IsImmutableGetterNullable(ValueProperty property)
    {
        return !Options.UseNullableReferenceTypes || IsImmutablePropertyNullable(property);
    }

    private bool IsImmutableFieldNullable(ValueProperty property)
    {
        return Options.UseNullableReferenceTypes
            || property.CsNullable
            || property.EnumProperty.HasValue
            || MetadataTypeConverter.IsCsTypeNullable(property.CsType.Name)
            || !MetadataTypeConverter.IsKnownCsType(property.CsType.Name);
    }

    private IEnumerable<string> FileHeader(string namespaceName, bool useFileScopedNamespaces, IEnumerable<string> usings)
    {
        foreach (var row in usings)
            yield return $"using {row};";

        yield return "";
        yield return $"namespace {namespaceName}{(useFileScopedNamespaces ? ";" : "")}";


        if (useFileScopedNamespaces)
            yield return "";
        else
            yield return "{";
    }

    private IEnumerable<string> FileFooter(bool useFileScopedNamespaces)
    {
        if (!useFileScopedNamespaces)
            yield return "}";
    }
}

================
File: src/DataLinq.Core/Factories/Generator/MetadataFromModelsFactory.cs
================
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using DataLinq.ErrorHandling;
using DataLinq.Metadata;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ThrowAway;
using ThrowAway.Extensions;

namespace DataLinq.Core.Factories.Models;

public enum MetadataFromInterfacesFactoryError
{
    CompilationError,
    TypeNotFound,
    FileNotFound,
    CouldNotLoadAssembly
}

public class MetadataFromInterfacesFactoryOptions
{
    public Encoding FileEncoding { get; set; } = new UTF8Encoding(false);
    public bool RemoveInterfacePrefix { get; set; } = true;
}

public class MetadataFromModelsFactory
{
    private readonly MetadataFromInterfacesFactoryOptions options;
    public Action<string>? Log { get; }

    public MetadataFromModelsFactory(MetadataFromInterfacesFactoryOptions options, Action<string>? log = null)
    {
        this.options = options;
        Log = log;
    }

    public List<Option<DatabaseDefinition, IDLOptionFailure>> ReadSyntaxTrees(ImmutableArray<TypeDeclarationSyntax> modelSyntaxes)
    {
        var syntaxParser = new SyntaxParser(modelSyntaxes);

        // Identify classes implementing the interfaces of interest
        var dbModelClasses = modelSyntaxes
            .Where(cls => cls.BaseList != null && cls.BaseList.Types
                .Any(baseType => baseType.ToString() == "IDatabaseModel"))
            .ToList();

        return ParseDatabaseModels(modelSyntaxes, syntaxParser, dbModelClasses).ToList();
    }

    private static IEnumerable<Option<DatabaseDefinition, IDLOptionFailure>> ParseDatabaseModels(ImmutableArray<TypeDeclarationSyntax> modelSyntaxes, SyntaxParser syntaxParser, List<TypeDeclarationSyntax> dbModelClasses)
    {
        foreach (var dbType in dbModelClasses)
            yield return ParseDatabaseModel(modelSyntaxes, syntaxParser, dbType);
    }

    private static Option<DatabaseDefinition, IDLOptionFailure> ParseDatabaseModel(ImmutableArray<TypeDeclarationSyntax> modelSyntaxes, SyntaxParser syntaxParser, TypeDeclarationSyntax dbType)
    {
        if (dbType == null)
            return DLOptionFailure.Fail("Database model class not found");

        if (dbType.Identifier.Text == null)
            return DLOptionFailure.Fail("Database model class must have a name");

        var name = MetadataTypeConverter.RemoveInterfacePrefix(dbType.Identifier.Text);
        var database = new DatabaseDefinition(name, new CsTypeDeclaration(dbType));

        var modelClasses = modelSyntaxes
            .Where(cls => cls.BaseList != null && cls.BaseList.Types
                .Any(baseType => (baseType.ToString().StartsWith("ITableModel") || baseType.ToString().StartsWith("IViewModel"))))
            .Where(cls => cls.BaseList != null && cls.BaseList.Types
                .Any(baseType => baseType.ToString().Contains($"<{dbType.Identifier.Text}>")))
            .ToList();

        if (!dbType.Members.OfType<PropertyDeclarationSyntax>()
            .Where(prop => prop.Type is GenericNameSyntax genericType && genericType.Identifier.Text == "DbRead")
            .Select(prop => syntaxParser.GetTableType(prop, modelClasses))
            .Transpose()
            .Map(x => x.Select(t => syntaxParser.ParseTableModel(database, t.classSyntax, t.csPropertyName)))
            .FlatMap(x => x.Transpose())
            .TryUnwrap(out var models, out var modelFailures))
            return DLOptionFailure.AggregateFail(modelFailures);

        database.SetTableModels(models);

        if (!dbType.AttributeLists.SelectMany(attrList => attrList.Attributes).Select(x => syntaxParser.ParseAttribute(x))
            .Transpose()
            .TryUnwrap(out var attributes, out var attrFailures))
            return DLOptionFailure.AggregateFail(attrFailures);

        database.SetAttributes(attributes);
        database.ParseAttributes();

        MetadataFactory.ParseIndices(database);
        MetadataFactory.ParseRelations(database);

        if (database.TableModels.Any(x => x.CsPropertyName == database.CsType.Name))
            database.SetCsType(database.CsType.MutateName($"{database.CsType.Name}Db"));

        return database;
    }
}

================
File: src/DataLinq.Core/Factories/MetadataFactory.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Attributes;
using DataLinq.Extensions.Helpers;
using DataLinq.Metadata;

namespace DataLinq.Core.Factories;

public struct MetadataFromDatabaseFactoryOptions
{
    public bool CapitaliseNames { get; set; } = false;
    public bool DeclareEnumsInClass { get; set; } = false;
    public List<string> Tables { get; set; } = new List<string>();
    public List<string> Views { get; set; } = new List<string>();

    public MetadataFromDatabaseFactoryOptions()
    {
    }
}

public static class MetadataFactory
{
    public static void ParseInterfaces(DatabaseDefinition database)
    {
        foreach (var tableModel in database.TableModels)
        {
            var model = tableModel.Model;
            
            if (model.ModelInstanceInterface == null)
            {
                var interfaceName = $"I{model.CsType.Name}";
                model.SetModelInstanceInterface(new CsTypeDeclaration(interfaceName, model.CsType.Namespace, ModelCsType.Interface));
            }
        }
    }

    public static TableDefinition ParseTable(ModelDefinition model)
    {
        var table = model.OriginalInterfaces.Any(x => x.Name.StartsWith("ITableModel") || x.Name.StartsWith("ICustomTableModel"))
            ? new TableDefinition(model.CsType.Name)
            : new ViewDefinition(model.CsType.Name);

        foreach (var attribute in model.Attributes)
        {
            if (attribute is TableAttribute tableAttribute)
                table.SetDbName(tableAttribute.Name);

            if (attribute is UseCacheAttribute useCache)
                table.UseCache = useCache.UseCache;

            if (attribute is CacheLimitAttribute cacheLimit)
                table.CacheLimits.Add((cacheLimit.LimitType, cacheLimit.Amount));

            if (attribute is IndexCacheAttribute indexCache)
                table.IndexCache.Add((indexCache.Type, indexCache.Amount));

            if (table is ViewDefinition view && attribute is DefinitionAttribute definitionAttribute)
                view.SetDefinition(definitionAttribute.Sql);
        }

        table.SetColumns(model.ValueProperties.Values.Select(table.ParseColumn));

        return table;
    }

    public static void ParseIndices(DatabaseDefinition database)
    {
        var indices = database.TableModels
            .SelectMany(tableModel => tableModel.Table.Columns
                .Select(column => (column, indexAttributes: column.ValueProperty.Attributes.OfType<IndexAttribute>().ToList())))
            .Where(t => t.indexAttributes.Any());

        foreach (var (column, indexAttributes) in indices)
        {
            foreach (var indexAttribute in indexAttributes)
            {
                var existingIndex = column.Table.ColumnIndices.FirstOrDefault(x => x.Name == indexAttribute.Name);

                if (existingIndex != null)
                {
                    if (!existingIndex.Columns.Contains(column))
                        existingIndex.AddColumn(column);
                }
                else
                {
                    var columnsForIndex = indexAttribute.Columns.Any()
                        ? indexAttribute.Columns.Select(colName => column.Table.Columns.Single(c => c.DbName == colName)).ToList()
                        : new List<ColumnDefinition> { column };

                    column.Table.ColumnIndices.Add(new ColumnIndex(indexAttribute.Name, indexAttribute.Characteristic, indexAttribute.Type, columnsForIndex));
                }
            }
        }
    }

    public static void ParseRelations(DatabaseDefinition database)
    {
        foreach (var table in database.TableModels.Where(x => x.Table.Type == TableType.Table).Select(x => x.Table))
        {
            var columns = table.Columns.Where(x => x.PrimaryKey).ToList();

            if (!columns.Any())
                throw new Exception($"Table {table.DbName} is missing a primary key. Having a primary key for every table is a requirement for DataLinq.");

            table.ColumnIndices.Add(new ColumnIndex($"{table.DbName}_primary_key", IndexCharacteristic.PrimaryKey, IndexType.BTREE, columns));
        }

        foreach (var column in database.TableModels.Where(x => x.Table.Type == TableType.Table).SelectMany(x => x.Table.Columns.Where(y => y.ForeignKey)))
        {
            foreach (var attribute in column.ValueProperty.Attributes.OfType<ForeignKeyAttribute>())
            {
                var relation = new RelationDefinition
                {
                    ConstraintName = attribute.Name,
                    Type = RelationType.OneToMany
                };

                var candidateColumn = database
                    .TableModels.FirstOrDefault(x => x.Table.DbName == attribute.Table)
                    ?.Table.Columns.FirstOrDefault(x => x.DbName == attribute.Column);

                if (candidateColumn == null)
                    continue;

                if (!column.ColumnIndices.Any(x => x.Characteristic == IndexCharacteristic.ForeignKey))
                    column.Table.ColumnIndices.Add(
                        new ColumnIndex(column.DbName, IndexCharacteristic.ForeignKey, IndexType.BTREE, [column]));

                if (!candidateColumn.ColumnIndices.Any())
                    candidateColumn.Table.ColumnIndices.Add(
                        new ColumnIndex(candidateColumn.DbName, IndexCharacteristic.VirtualDataLinq, IndexType.BTREE, [candidateColumn]));

                var foreignKeyIndex = column.ColumnIndices.Last();
                var candidateKeyIndex = candidateColumn.ColumnIndices.First();

                relation.ForeignKey = CreateRelationPart(relation, foreignKeyIndex, RelationPartType.ForeignKey);
                relation.CandidateKey = CreateRelationPart(relation, candidateKeyIndex, RelationPartType.CandidateKey);

                var candidateProperty = GetRelationProperty(relation.ForeignKey, candidateColumn);
                var columnProperty = GetRelationProperty(relation.CandidateKey, column);

                if (candidateProperty != null && columnProperty != null)
                {
                    foreignKeyIndex.RelationParts.Add(relation.ForeignKey);
                    candidateKeyIndex.RelationParts.Add(relation.CandidateKey);

                    candidateProperty.RelationPart = relation.ForeignKey;
                    columnProperty.RelationPart = relation.CandidateKey;
                }
            }
        }
    }

    private static RelationPart CreateRelationPart(RelationDefinition relation, ColumnIndex column, RelationPartType type)
    {
        return new RelationPart
        {
            Relation = relation,
            ColumnIndex = column,
            Type = type,
            CsName = column.Table.Model.CsType.Name
        };
    }

    private static RelationProperty? GetRelationProperty(RelationPart relationPart, ColumnDefinition column)
    {
        return relationPart.ColumnIndex.Table.Model
            .RelationProperties.Values.SingleOrDefault(x =>
                x.Attributes.Any(y =>
                    y is RelationAttribute relationAttribute
                    && relationAttribute.Table == column.Table.DbName
                    && relationAttribute.Columns[0] == column.DbName
                    && (relationAttribute.Name == null || relationAttribute.Name == relationPart.Relation.ConstraintName)));
    }

    public static RelationProperty AddRelationProperty(ColumnDefinition column, ColumnDefinition referencedColumn, string constraintName)
    {
        var propertyName = referencedColumn.Table.DbName;
        var i = 2;
        while (column.Table.Model.RelationProperties.ContainsKey(propertyName))
            propertyName = propertyName + "_" + i++;

        var relationProperty = new RelationProperty(propertyName, referencedColumn.Table.Model.CsType, column.Table.Model, [new RelationAttribute(referencedColumn.Table.DbName, referencedColumn.DbName, constraintName)]);
        relationProperty.RelationName = constraintName;
        relationProperty.Model.AddProperty(relationProperty);

        return relationProperty;
    }

    public static ValueProperty AttachValueProperty(ColumnDefinition column, string csTypeName, bool capitaliseNames)
    {
        var name = capitaliseNames
            ? column.DbName.FirstCharToUpper()
            : column.DbName;

        var type = MetadataTypeConverter.GetType(csTypeName);

        CsTypeDeclaration csType;

        if (type == null)
        {
            if (csTypeName == "enum")
                csType = new CsTypeDeclaration(csTypeName, "", ModelCsType.Enum);
            else
                throw new Exception($"Type {csTypeName} not found.");
        }
        else
        {
            csType = new CsTypeDeclaration(type);
        }


        var property = new ValueProperty(name, csType, column.Table.Model, GetAttributes(column));
        property.SetCsSize(MetadataTypeConverter.CsTypeSize(csTypeName));
        property.SetCsNullable(column.Nullable && MetadataTypeConverter.IsCsTypeNullable(csTypeName));
        //property.SetAttributes(GetAttributes(property));
        property.SetColumn(column);

        column.SetValueProperty(property);
        column.Table.Model.AddProperty(column.ValueProperty);

        return property;
    }

    public static void AttachEnumProperty(ValueProperty property, IEnumerable<(string name, int value)> enumValues, IEnumerable<(string name, int value)> csEnumValues, bool declaredInClass)
    {
        property.SetEnumProperty(new EnumProperty(enumValues.ToList(), csEnumValues.ToList(), declaredInClass));
    }

    public static IEnumerable<Attribute> GetAttributes(ColumnDefinition column)
    {
        if (column.PrimaryKey)
            yield return new PrimaryKeyAttribute();

        if (column.AutoIncrement)
            yield return new AutoIncrementAttribute();

        if (column.Nullable)
            yield return new NullableAttribute();

        yield return new ColumnAttribute(column.DbName);

        foreach (var dbType in column.DbTypes)
        {
            yield return new TypeAttribute(dbType);
        }
    }

    public static void ParseAttributes(this DatabaseDefinition database)
    {
        foreach (var attribute in database.Attributes)
        {
            if (attribute is DatabaseAttribute databaseAttribute)
                database.SetName(databaseAttribute.Name);

            if (attribute is UseCacheAttribute useCache)
                database.SetCache(useCache.UseCache);

            if (attribute is CacheLimitAttribute cacheLimit)
                database.CacheLimits.Add((cacheLimit.LimitType, cacheLimit.Amount));

            if (attribute is IndexCacheAttribute indexCache)
                database.IndexCache.Add((indexCache.Type, indexCache.Amount));

            if (attribute is CacheCleanupAttribute cacheCleanup)
                database.CacheCleanup.Add((cacheCleanup.LimitType, cacheCleanup.Amount));
        }
    }

    public static ColumnDefinition ParseColumn(this TableDefinition table, ValueProperty property)
    {
        var column = new ColumnDefinition(property.PropertyName, table);
        column.SetValueProperty(property);

        foreach (var attribute in property.Attributes)
        {
            if (attribute is ColumnAttribute columnAttribute)
                column.SetDbName(columnAttribute.Name);

            if (attribute is NullableAttribute)
                column.SetNullable();

            //if (attribute is DefaultAttribute defaultAttribute)
            //    column.AddDefaultValue(defaultAttribute.Value);

            if (attribute is AutoIncrementAttribute)
                column.SetAutoIncrement();

            if (attribute is PrimaryKeyAttribute)
                column.SetPrimaryKey();

            if (attribute is ForeignKeyAttribute)
                column.SetForeignKey();

            if (attribute is TypeAttribute t)
                column.AddDbType(new DatabaseColumnType(t.DatabaseType, t.Name, t.Length, t.Decimals, t.Signed));
        }

        return column;
    }
}

================
File: src/DataLinq.Core/Factories/MetadataTransformer.cs
================
using System.Linq;
using DataLinq.Attributes;
using DataLinq.Metadata;

namespace DataLinq.Core.Factories;

public struct MetadataTransformerOptions
{
    public bool RemoveInterfacePrefix { get; set; } = true;
    public bool UpdateConstraintNames { get; } = true;

    public MetadataTransformerOptions(bool removeInterfacePrefix = true, bool updateConstraintNames = true)
    {
        RemoveInterfacePrefix = removeInterfacePrefix;
        UpdateConstraintNames = updateConstraintNames;
    }
}

public class MetadataTransformer
{
    //private readonly Action<string> log;
    private readonly MetadataTransformerOptions options;

    public MetadataTransformer(MetadataTransformerOptions options)
    {
        //this.log = log;
        this.options = options;
    }

    private static CsTypeDeclaration TransformCsType(CsTypeDeclaration srcCsType, CsTypeDeclaration destCsType, bool removeInterfacePrefix = true)
    {
        var modelCsTypeName = srcCsType.Name;

        if (removeInterfacePrefix && srcCsType.ModelCsType == ModelCsType.Interface)
        {
            if (modelCsTypeName.StartsWith("I") && !char.IsLower(modelCsTypeName[1]))
                modelCsTypeName = modelCsTypeName.Substring(1);
        }

        if (destCsType.Name != modelCsTypeName)
            return destCsType.MutateName(modelCsTypeName);

        return destCsType;
    }

    public void TransformDatabase(DatabaseDefinition srcMetadata, DatabaseDefinition destMetadata)
    {
        destMetadata.SetAttributes(srcMetadata.Attributes);
        destMetadata.SetCache(srcMetadata.UseCache);
        destMetadata.CacheLimits.Clear();
        destMetadata.CacheLimits.AddRange(srcMetadata.CacheLimits);
        destMetadata.IndexCache.Clear();
        destMetadata.IndexCache.AddRange(srcMetadata.IndexCache);
        destMetadata.CacheCleanup.Clear();
        destMetadata.CacheCleanup.AddRange(srcMetadata.CacheCleanup);

        destMetadata.SetCsType(TransformCsType(srcMetadata.CsType, destMetadata.CsType));

        foreach (var srcTable in srcMetadata.TableModels)
        {
            var destTable = destMetadata.TableModels.FirstOrDefault(x => x.Table.DbName == srcTable.Table.DbName);

            if (destTable == null)
            {
                //log($"Couldn't find table with name '{srcTable.Table.DbName}' in {nameof(destMetadata)}");
                continue;
            }

            TransformTable(srcTable, destTable);
            destTable.SetCsPropertyName(srcTable.CsPropertyName);
        }
    }

    public void TransformTable(TableModel srcTable, TableModel destTable)
    {
        destTable.Model.SetCsType(TransformCsType(srcTable.Model.CsType, destTable.Model.CsType));

        if (srcTable.Model.ModelInstanceInterface != null)
            destTable.Model.SetModelInstanceInterface(srcTable.Model.ModelInstanceInterface);
        else
        {
            var interfaceName = $"I{destTable.Model.CsType.Name}";
            destTable.Model.SetModelInstanceInterface(new CsTypeDeclaration(interfaceName, destTable.Model.CsType.Namespace, ModelCsType.Interface));
        }


        //destTable.Model.SetInterfaces([srcTable.Model.CsType]); //TODO: Investigate if this is needed
        destTable.Model.SetUsings(srcTable.Model.Usings);

        foreach (var srcProperty in srcTable.Model.ValueProperties.Values)
        {
            var destProperty = destTable.Model.ValueProperties.Values.FirstOrDefault(x => x.Column?.DbName == srcProperty.Column?.DbName);

            if (destProperty == null)
            {
                //log($"Couldn't find property with name '{srcProperty.CsName}' in {destTable.Table.DbName}");
                continue;
            }

            if (srcProperty.EnumProperty != null)
            {
                destProperty.SetEnumProperty(srcProperty.EnumProperty.Value);
            }

            destProperty.SetPropertyName(srcProperty.PropertyName);
            destProperty.SetCsType(srcProperty.CsType);
            destProperty.SetCsNullable(srcProperty.CsNullable);
            destProperty.SetCsSize(srcProperty.CsSize);

            foreach (var srcAttribute in srcProperty.Attributes.OfType<TypeAttribute>())
            {
                if (!destProperty.Attributes.OfType<TypeAttribute>().Any(x => x.DatabaseType == srcAttribute.DatabaseType))
                    destProperty.AddAttribute(new TypeAttribute(srcAttribute.DatabaseType, srcAttribute.Name, srcAttribute.Length, srcAttribute.Decimals, srcAttribute.Signed));
            }

            foreach (var srcDbType in srcProperty.Column.DbTypes)
            {
                if (!destProperty.Column.DbTypes.Any(x => x.DatabaseType == srcDbType.DatabaseType))
                {
                    destProperty.Column.AddDbType(srcDbType.Clone());
                }
            }
        }

        foreach (var srcProperty in srcTable.Model.RelationProperties.Values)
        {
            var destProperty = destTable.Model.RelationProperties.Values.FirstOrDefault(x =>
                srcProperty.Attributes.OfType<RelationAttribute>().Any(y => x.RelationPart?.GetOtherSide().ColumnIndex.Table.DbName == y.Table) &&
                srcProperty.Attributes.OfType<RelationAttribute>().Any(y => x.RelationPart?.GetOtherSide().ColumnIndex.Columns.All(z => y.Columns.Contains(z.DbName)) == true));

            if (destProperty == null)
            {
                //log($"Couldn't find property with name '{srcProperty.CsName}' in {destTable.Table.DbName}");
                continue;
            }

            destProperty.SetPropertyName(srcProperty.PropertyName);

            if (!options.UpdateConstraintNames && srcProperty.RelationPart != null)
                destProperty.RelationPart.Relation.ConstraintName = srcProperty.RelationPart.Relation.ConstraintName;
        }
    }
}

================
File: src/DataLinq.Core/Factories/MetadataTypeConverter.cs
================
using System;
using System.Linq;

namespace DataLinq.Core.Factories;

public static class MetadataTypeConverter
{
    public static int? CsTypeSize(string csType) => csType switch
    {
        "sbyte" => sizeof(sbyte),
        "byte" => sizeof(byte),
        "short" => sizeof(short),
        "ushort" => sizeof(ushort),
        "int" => sizeof(int),
        "uint" => sizeof(uint),
        "long" => sizeof(long),
        "ulong" => sizeof(ulong),
        "char" => sizeof(char),
        "float" => sizeof(float),
        "double" => sizeof(double),
        "bool" => sizeof(bool),
        "decimal" => sizeof(decimal),
        "DateTime" => 8,
        "DateOnly" => sizeof(long),
        "Guid" => 16,
        "String" => null,
        "byte[]" => null,
        "enum" => sizeof(int),
        _ => null
    };

    public static string GetKeywordName(Type type) => type.IsGenericType
        ? GetFriendlyTypeName(type)
        : GetKeywordName(type.Name);

    public static string GetKeywordName(string typeName) => typeName switch
    {
        "SByte" => "sbyte",
        "Byte" => "byte",
        "Int16" => "short",
        "UInt16" => "ushort",
        "Int32" => "int",
        "UInt32" => "uint",
        "Int64" => "long",
        "UInt64" => "ulong",
        "Char" => "char",
        "Single" => "float",
        "Double" => "double",
        "Boolean" => "bool",
        "Decimal" => "decimal",
        "String" => "string",
        _ => typeName,
    };

    public static Type GetType(string typeName) => Type.GetType(GetFullTypeName(typeName));

    public static string GetFullTypeName(string typeName) => typeName.ToLower() switch
    {
        "sbyte" => "System.SByte",
        "byte" => "System.Byte",
        "short" => "System.Int16",
        "ushort" => "System.UInt16",
        "int" => "System.Int32",
        "uint" => "System.UInt32",
        "long" => "System.Int64",
        "ulong" => "System.UInt64",
        "char" => "System.Char",
        "float" => "System.Single",
        "double" => "System.Double",
        "bool" => "System.Boolean",
        "decimal" => "System.Decimal",
        "datetime" => "System.DateTime",
        "dateonly" => "System.DateOnly",
        "timeonly" => "System.TimeOnly",
        "guid" => "System.Guid",
        "string" => "System.String",
        "byte[]" => "System.Byte[]",
        _ => typeName,
    };

    public static bool IsCsTypeNullable(string csType) => csType switch
    {
        "int" => true,
        "string" => false,
        "bool" => true,
        "double" => true,
        "DateTime" => true,
        "DateOnly" => true,
        "TimeOnly" => true,
        "float" => true,
        "long" => true,
        "Guid" => true,
        "byte[]" => false,
        "decimal" => true,
        "enum" => true,
        "sbyte" => true,
        "byte" => true,
        "short" => true,
        "ushort" => true,
        "uint" => true,
        "ulong" => true,
        "char" => true,
        "String" => false,
        _ => false,
    };

    public static bool IsKnownCsType(string csType) => csType switch
    {
        "int" => true,
        "string" => true,
        "bool" => true,
        "double" => true,
        "DateTime" => true,
        "DateOnly" => true,
        "TimeOnly" => true,
        "float" => true,
        "long" => true,
        "Guid" => true,
        "byte[]" => true,
        "decimal" => true,
        "enum" => true,
        "sbyte" => true,
        "byte" => true,
        "short" => true,
        "ushort" => true,
        "uint" => true,
        "ulong" => true,
        "char" => true,
        "String" => true,
        _ => false,
    };

    public static bool IsPrimitiveType(string typeName) => GetKeywordName(typeName) switch
    {
        "bool" => true,
        "byte" => true,
        "char" => true,
        "decimal" => true,
        "double" => true,
        "float" => true,
        "int" => true,
        "long" => true,
        "sbyte" => true,
        "short" => true,
        "uint" => true,
        "ulong" => true,
        "ushort" => true,
        _ => false,
    };

    public static string RemoveInterfacePrefix(string interfaceName) =>
        interfaceName.StartsWith("I") && interfaceName.Length > 1 && char.IsUpper(interfaceName[1])
            ? interfaceName.Substring(1)
            : interfaceName;

    private static string GetFriendlyTypeName(Type type)
    {
        if (type.IsGenericType)
        {
            // Get the base name without the trailing `N part.
            var baseName = type.Name;
            int index = baseName.IndexOf('`');
            if (index > 0)
            {
                baseName = baseName.Substring(0, index);
            }
            // Process each generic argument recursively (if necessary)
            var genericArgs = type.GetGenericArguments();
            var genericArgNames = genericArgs.Select(GetFriendlyTypeName);
            return $"{baseName}<{string.Join(", ", genericArgNames)}>";
        }
        else
        {
            return type.Name;
        }
    }
}

================
File: src/DataLinq.Core/Factories/Models/MetadataFromFileFactory.cs
================
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using DataLinq.ErrorHandling;
using DataLinq.Extensions.Helpers;
using DataLinq.Metadata;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ThrowAway;
using ThrowAway.Extensions;

namespace DataLinq.Core.Factories.Models;

public enum MetadataFromFileFactoryError
{
    CompilationError,
    TypeNotFound,
    FileNotFound,
    CouldNotLoadAssembly
}

public class MetadataFromFileFactoryOptions
{
    public Encoding FileEncoding { get; set; } = new UTF8Encoding(false);
    public bool RemoveInterfacePrefix { get; set; } = true;
}

public class MetadataFromFileFactory
{
    private readonly MetadataFromFileFactoryOptions options;
    public Action<string>? Log { get; }

    public MetadataFromFileFactory(MetadataFromFileFactoryOptions options, Action<string>? log = null)
    {
        this.options = options;
        Log = log;
    }

    public Option<DatabaseDefinition, IDLOptionFailure> ReadFiles(string csType, IEnumerable<string> srcPaths)
    {
        var trees = new List<SyntaxTree>();

        foreach (var path in srcPaths)
        {
            try
            {
                // Process directories
                if (Directory.Exists(path))
                {
                    var directoryInfo = new DirectoryInfo(path);
                    var files = directoryInfo.EnumerateFiles("*.cs", SearchOption.AllDirectories);

                    foreach (var fileInfo in files)
                    {
                        // Use FileInfo.FullName to get the correct case-preserved path
                        var fullPath = fileInfo.FullName;
                        var sourceText = File.ReadAllText(fullPath, this.options.FileEncoding);

                        var syntaxTree = CSharpSyntaxTree.ParseText(
                            sourceText,
                            CSharpParseOptions.Default,
                            path: fullPath // Use the case-preserved file path
                        );

                        trees.Add(syntaxTree);
                        //Log?.Invoke($"Parsed file: {fullPath}");
                    }
                }
                // Process individual files
                else if (File.Exists(path))
                {
                    var fileInfo = new FileInfo(path);
                    var fullPath = fileInfo.FullName; // Get proper case
                    var sourceText = File.ReadAllText(fullPath, this.options.FileEncoding);

                    var syntaxTree = CSharpSyntaxTree.ParseText(
                        sourceText,
                        CSharpParseOptions.Default,
                        path: fullPath // Use the case-preserved file path
                    );

                    trees.Add(syntaxTree);
                    //Log?.Invoke($"Parsed file: {fullPath}");
                }
                else
                {
                    return DLOptionFailure.Fail(DLFailureType.FileNotFound, $"Path not found: {path}");
                }
            }
            catch (Exception ex)
            {
                return DLOptionFailure.Fail(DLFailureType.FileNotFound, $"Error processing path '{path}': {ex.Message}");
            }
        }

        var modelSyntaxes = trees
            .Where(x => x.HasCompilationUnitRoot)
            .SelectMany(x => x.GetCompilationUnitRoot().DescendantNodes().OfType<TypeDeclarationSyntax>()
                    .Where(cls => cls.BaseList?.Types.Any(baseType =>
                        SyntaxParser.IsModelInterface(baseType.ToString()) ||
                        SyntaxParser.IsCustomModelInterface(baseType.ToString())) == true))
            .ToImmutableArray();

        return ReadSyntaxTrees(modelSyntaxes);
    }

    public Option<DatabaseDefinition, IDLOptionFailure> ReadSyntaxTrees(ImmutableArray<TypeDeclarationSyntax> modelSyntaxes)
    {
        var syntaxParser = new SyntaxParser(modelSyntaxes);

        // Identify classes implementing the interfaces of interest
        var dbModelClasses = modelSyntaxes
            .Where(cls => cls.BaseList?.Types
                .Any(baseType => baseType.ToString() == "ICustomDatabaseModel" || baseType.ToString() == "IDatabaseModel") == true)
            .ToList();

        // Prioritize the classes implementing ICustomDatabaseModel
        var dbType = dbModelClasses
            .FirstOrDefault(cls => cls.BaseList?.Types
                .Any(baseType => baseType.ToString() == "ICustomDatabaseModel") == true)
            ??
            dbModelClasses.FirstOrDefault();

        var csType = dbType == null
            ? new CsTypeDeclaration("Unnamed", "Unnamed", ModelCsType.Class)
            : new CsTypeDeclaration(MetadataTypeConverter.RemoveInterfacePrefix(dbType.Identifier.Text), CsTypeDeclaration.GetNamespace(dbType), ModelCsType.Class);

        var database = new DatabaseDefinition(csType.Name, csType);

        if (!string.IsNullOrEmpty(dbType?.SyntaxTree.FilePath))
            database.SetCsFile(new CsFileDeclaration(dbType!.SyntaxTree.FilePath));

        var customModelClasses = modelSyntaxes
            .Where(cls => cls.BaseList?.Types
                .Any(baseType => baseType.ToString().StartsWith("ICustomTableModel") || baseType.ToString().StartsWith("ICustomViewModel")) == true)
            .ToList();

        if(!customModelClasses
            .Select(cls => syntaxParser.ParseTableModel(database, cls, cls.Identifier.Text))
            .Transpose()
            .TryUnwrap(out var customModels, out var customModelFailures))
            return DLOptionFailure.AggregateFail(customModelFailures);

        var modelClasses = modelSyntaxes
            .Where(cls => cls.BaseList?.Types
                .Any(baseType => baseType.ToString().StartsWith("ITableModel") || baseType.ToString().StartsWith("IViewModel")) ?? true)
            .ToList();

        if (dbType != null)
        {
            if (!dbType.Members.OfType<PropertyDeclarationSyntax>()
                .Where(prop => prop.Type is GenericNameSyntax genericType && genericType.Identifier.Text == "DbRead")
                .Select(prop => syntaxParser.GetTableType(prop, modelClasses))
                .Transpose()
                .FlatMap(x => 
                    x.Select(t => syntaxParser.ParseTableModel(database, t.classSyntax, t.csPropertyName))
                    .Transpose())
                .TryUnwrap(out var models, out var modelFailures))
                return DLOptionFailure.AggregateFail(modelFailures);

            database.SetTableModels(models);


            if (!dbType.AttributeLists
                .SelectMany(attrList => attrList.Attributes)
                .Select(x => syntaxParser.ParseAttribute(x))
                .Transpose()
                .TryUnwrap(out var attributes, out var attrFailures))
                return DLOptionFailure.AggregateFail(attrFailures);

            database.SetAttributes(attributes);
            database.ParseAttributes();
        }
        else
        {
            if (!modelClasses
                .Select(cls => syntaxParser.ParseTableModel(database, cls, cls.Identifier.Text))
                .Transpose()
                .TryUnwrap(out var models, out var modelFailures))
                return DLOptionFailure.AggregateFail(modelFailures);

            database.SetTableModels(models);
        }

        var transformer = new MetadataTransformer(new MetadataTransformerOptions(options.RemoveInterfacePrefix));

        foreach (var customModel in customModels)
        {
            var match = database.TableModels.FirstOrDefault(x => x.Table.DbName == customModel.Table.DbName);

            if (match != null)
                transformer.TransformTable(customModel, match);
            else
                database.SetTableModels(database.TableModels.Concat([customModel]));
        }

        MetadataFactory.ParseIndices(database);
        MetadataFactory.ParseRelations(database);

        if (database.TableModels.Any(x => x.Model.CsType.Name == database.CsType.Name))
            database.SetCsType(database.CsType.MutateName($"{database.CsType.Name}Db"));

        return database;
    }
}

================
File: src/DataLinq.Core/Factories/Models/ModelFileFactory.cs
================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using DataLinq.Attributes;
using DataLinq.Extensions.Helpers;
using DataLinq.Metadata;

namespace DataLinq.Core.Factories.Models;

public class ModelFileFactoryOptions
{
    public string? NamespaceName { get; set; } = null; //"Models";
    public string Tab { get; set; } = "    ";
    public bool UseRecords { get; set; } = true;
    //public bool UseCache { get; set; } = true;
    public bool UseFileScopedNamespaces { get; set; }
    public bool UseNullableReferenceTypes { get; set; }
    public bool SeparateTablesAndViews { get; set; } = false;
    public List<string> Usings { get; set; } = new List<string> { "System", "DataLinq", "DataLinq.Interfaces", "DataLinq.Attributes", "DataLinq.Instances", "DataLinq.Mutation" };
}

public enum ModelType
{
    classType,
    interfaceType
}

public class ModelFileFactory
{
    private string namespaceTab;
    private string tab;

    private readonly ModelFileFactoryOptions options;

    public ModelFileFactory(ModelFileFactoryOptions options)
    {
        this.options = options;

        namespaceTab = options.UseFileScopedNamespaces ? "" : options.Tab;
        tab = options.Tab;
    }

    public IEnumerable<(string path, string contents)> CreateModelFiles(DatabaseDefinition database)
    {
        //var dbCsTypeName = database.TableModels.Any(x => x.Model.CsTypeName == database.CsTypeName)
        //    ? $"I{database.CsTypeName}Db"
        //    : $"I{database.CsTypeName}";

        yield return ($"{database.CsType.Name}.cs",
                FileHeader(options.NamespaceName ?? database.CsType.Namespace, options.UseFileScopedNamespaces, options.Usings)
                .Concat(DatabaseFileContents(database, database.CsType.Name, options))
                .Concat(FileFooter(options.UseFileScopedNamespaces))
                .ToJoinedString("\n"));

        foreach (var table in database.TableModels.Where(x => !x.IsStub))
        {
            var namespaceName = options.NamespaceName ?? table.Model.CsType.Namespace;
            if (namespaceName == null)
                throw new Exception($"Namespace is null for '{table.Model.CsType.Name}'");

            var usings = options.Usings
                .Concat(table.Model.Usings?.Select(x => x.FullNamespaceName) ?? new List<string>())
                .Concat(table.Model.RelationProperties.Values
                    .Where(x => x.RelationPart.Type == RelationPartType.CandidateKey)
                    .Select(x => "System.Collections.Generic"))
                .Distinct()
                .Where(x => x != null)
                .Where(name => name != namespaceName)
                .Select(name => (name.StartsWith("System"), name))
                .OrderByDescending(x => x.Item1)
                .ThenBy(x => x.name)
                .Select(x => x.name);

            var file =
                FileHeader(namespaceName, options.UseFileScopedNamespaces, usings)
                .Concat(ModelFileContents(table.Model, options))
                .Concat(FileFooter(options.UseFileScopedNamespaces))
                .ToJoinedString("\n");

            var path = GetFilePath(table);

            yield return (path, file);
        }
    }

    private string GetFilePath(TableModel table)
    {
        var path = $"{table.Model.CsType.Name}.cs";

        if (options.SeparateTablesAndViews)
            return table.Table.Type == TableType.Table
                ? $"Tables{Path.DirectorySeparatorChar}{path}"
                : $"Views{Path.DirectorySeparatorChar}{path}";

        return path;
    }

    private IEnumerable<string> DatabaseFileContents(DatabaseDefinition database, string dbName, ModelFileFactoryOptions settings)
    {
        var namespaceTab = options.UseFileScopedNamespaces ? "" : options.Tab;
        var tab = settings.Tab;

        if (database.UseCache)
            yield return $"{namespaceTab}[UseCache]";

        foreach (var limit in database.CacheLimits)
            yield return $"{namespaceTab}[CacheLimit(CacheLimitType.{limit.limitType}, {limit.amount})]";

        foreach (var cleanup in database.CacheCleanup)
            yield return $"{namespaceTab}[CacheCleanup(CacheCleanupType.{cleanup.cleanupType}, {cleanup.amount})]";

        yield return $"{namespaceTab}[Database(\"{database.Name}\")]";
        yield return $"{namespaceTab}public partial class {dbName}(DataSourceAccess dataSource) : IDatabaseModel";
        //yield return $"{namespaceTab}public interface {dbName} : IDatabaseModel";
        yield return namespaceTab + "{";

        foreach (var t in database.TableModels.OrderBy(x => x.Table.DbName))
        {
            yield return $"{namespaceTab}{tab}public DbRead<{t.Model.CsType.Name}> {t.CsPropertyName} {{ get; }} = new DbRead<{t.Model.CsType.Name}>(dataSource);";
            //yield return $"{namespaceTab}{tab}DbRead<I{t.Model.CsTypeName}> {t.CsPropertyName} {{ get; }}";
        }

        yield return namespaceTab + "}";
    }

    private IEnumerable<string> ModelFileContents(ModelDefinition model, ModelFileFactoryOptions options)
    {
        var valueProps = model.ValueProperties.Values
            .OrderBy(x => x.Type)
            .ThenByDescending(x => x.Attributes.Any(x => x is PrimaryKeyAttribute))
            .ThenByDescending(x => x.Attributes.Any(x => x is ForeignKeyAttribute))
            .ThenBy(x => x.PropertyName)
            .ToList();

        var relationProps = model.RelationProperties.Values
            .OrderBy(x => x.Type)
            .ThenByDescending(x => x.Attributes.Any(x => x is PrimaryKeyAttribute))
            .ThenByDescending(x => x.Attributes.Any(x => x is ForeignKeyAttribute))
            .ThenBy(x => x.PropertyName)
            .ToList();

        foreach (var row in valueProps.Where(x => x.EnumProperty != null && !x.EnumProperty.Value.DeclaredInClass).SelectMany(x => WriteEnum(options, x)))
            yield return row;

        if (model.ModelInstanceInterface != null)
            foreach (var row in WriteInterface(model.ModelInstanceInterface.Value))
                yield return row;

        foreach (var row in WriteClass(model, options, valueProps, relationProps))
            yield return row;
    }

    private IEnumerable<string> WriteInterface(CsTypeDeclaration modelInterface)
    {
        yield return $"{namespaceTab}public partial interface {modelInterface.Name}";
        yield return namespaceTab + "{";
        yield return namespaceTab + "}";
        yield return "";
    }

    private IEnumerable<string> WriteClass(ModelDefinition model, ModelFileFactoryOptions options, List<ValueProperty> valueProps, List<RelationProperty> relationProps)
    {
        var table = model.Table;

        if (table is ViewDefinition view)
        {
            yield return $"{namespaceTab}[Definition(\"{view.Definition}\")]";
            yield return $"{namespaceTab}[View(\"{table.DbName}\")]";
        }
        else
        {
            yield return $"{namespaceTab}[Table(\"{table.DbName}\")]";
        }

        if (model.ModelInstanceInterface != null)
            yield return $"{namespaceTab}[Interface<{model.ModelInstanceInterface.Value.Name}>]";

        var interfaces = table.Type == TableType.Table ? "ITableModel" : "IViewModel";

        interfaces += $"<{model.Database.CsType.Name}>";
        //interfaces += $", I{table.Model.CsType.Name}";
        //if (model.Interfaces?.Length > 0)
        //    interfaces += ", " + model.Interfaces.Select(x => x.Name).ToJoinedString(", ");

        yield return $"{namespaceTab}public abstract partial class {table.Model.CsType.Name}(RowData rowData, DataSourceAccess dataSource) : Immutable<{table.Model.CsType.Name}, {model.Database.CsType.Name}>(rowData, dataSource), {interfaces}";
        //yield return $"{namespaceTab}public partial {(options.UseRecords ? "record" : "class")} {table.Model.CsTypeName} : {interfaces}";

        yield return namespaceTab + "{";

        foreach (var row in valueProps.Where(x => x.EnumProperty != null && x.EnumProperty.Value.DeclaredInClass).SelectMany(x => WriteEnum(options, x)))
            yield return tab + row;

        foreach (var valueProperty in valueProps)
        {
            var c = valueProperty.Column;

            if (c.PrimaryKey)
                yield return $"{namespaceTab}{tab}[PrimaryKey]";

            foreach (var index in c.ColumnIndices.Where(x => x.Characteristic != IndexCharacteristic.PrimaryKey && x.Characteristic != IndexCharacteristic.ForeignKey && x.Characteristic != IndexCharacteristic.VirtualDataLinq))
            {
                var columns = index.Columns.Count() > 1
                    ? "," + index.Columns.Select(x => $"\"{x.DbName}\"").ToJoinedString(", ")
                    : string.Empty;

                yield return $"{namespaceTab}{tab}[Index(\"{index.Name}\", IndexCharacteristic.{index.Characteristic}, IndexType.{index.Type}{columns})]";
            }

            foreach (var index in c.ColumnIndices)
            {
                foreach (var relationPart in index.RelationParts.Where(x => x.Type == RelationPartType.ForeignKey))
                {
                    yield return $"{namespaceTab}{tab}[ForeignKey(\"{relationPart.Relation.CandidateKey.ColumnIndex.Table.DbName}\", \"{relationPart.Relation.CandidateKey.ColumnIndex.Columns[0].DbName}\", \"{relationPart.Relation.ConstraintName}\")]";
                }
            }

            if (c.AutoIncrement)
                yield return $"{namespaceTab}{tab}[AutoIncrement]";

            if (c.Nullable)
                yield return $"{namespaceTab}{tab}[Nullable]";

            foreach (var dbType in c.DbTypes.OrderBy(x => x.DatabaseType))
            {
                if (dbType.Signed.HasValue && dbType.Decimals.HasValue && dbType.Length.HasValue)
                    yield return $"{namespaceTab}{tab}[Type(DatabaseType.{dbType.DatabaseType}, \"{dbType.Name}\", {dbType.Length}, {dbType.Decimals}, {(dbType.Signed.Value ? "true" : "false")})]";
                else if (dbType.Signed.HasValue && dbType.Length.HasValue)
                    yield return $"{namespaceTab}{tab}[Type(DatabaseType.{dbType.DatabaseType}, \"{dbType.Name}\", {dbType.Length}, {(dbType.Signed.Value ? "true" : "false")})]";
                else if (dbType.Signed.HasValue && !dbType.Length.HasValue)
                    yield return $"{namespaceTab}{tab}[Type(DatabaseType.{dbType.DatabaseType}, \"{dbType.Name}\", {(dbType.Signed.Value ? "true" : "false")})]";
                else if (dbType.Length.HasValue && dbType.Decimals.HasValue)
                    yield return $"{namespaceTab}{tab}[Type(DatabaseType.{dbType.DatabaseType}, \"{dbType.Name}\", {dbType.Length}, {dbType.Decimals})]";
                else if (dbType.Length.HasValue)
                    yield return $"{namespaceTab}{tab}[Type(DatabaseType.{dbType.DatabaseType}, \"{dbType.Name}\", {dbType.Length})]";
                else
                    yield return $"{namespaceTab}{tab}[Type(DatabaseType.{dbType.DatabaseType}, \"{dbType.Name}\")]";
            }

            if (valueProperty.HasDefaultValue())
            {
                var defaultAttr = valueProperty.GetDefaultAttribute();
                if (defaultAttr is DefaultCurrentTimestampAttribute)
                {
                    yield return $"{namespaceTab}{tab}[DefaultCurrentTimestamp]";
                }
                else if (defaultAttr != null)
                    yield return $"{namespaceTab}{tab}[Default({FormatDefaultValue(defaultAttr.Value)})]";
            }

            if (valueProperty.EnumProperty != null)
                yield return $"{namespaceTab}{tab}[Enum({string.Join(", ", valueProperty.EnumProperty.Value.EnumValues.Select(x => $"\"{x.name}\""))})]";

            yield return $"{namespaceTab}{tab}[Column(\"{c.DbName}\")]";
            yield return $"{namespaceTab}{tab}public abstract {c.ValueProperty.CsType.Name}{GetPropertyNullable(c)} {c.ValueProperty.PropertyName} {{ get; }}";
            yield return $"";
        }

        foreach (var relationProperty in relationProps)
        {
            var otherPart = relationProperty.RelationPart.GetOtherSide();

            if (otherPart.ColumnIndex.Columns.Count == 1)
                yield return $"{namespaceTab}{tab}[Relation(\"{otherPart.ColumnIndex.Table.DbName}\", \"{otherPart.ColumnIndex.Columns[0].DbName}\", \"{relationProperty.RelationName}\")]";
            else
                yield return $"{namespaceTab}{tab}[Relation(\"{otherPart.ColumnIndex.Table.DbName}\", [{otherPart.ColumnIndex.Columns.Select(x => $"\"{x.DbName}\"").ToJoinedString(", ")}], \"{relationProperty.RelationName}\")]";

            if (relationProperty.RelationPart.Type == RelationPartType.ForeignKey)
                yield return $"{namespaceTab}{tab}public abstract {otherPart.ColumnIndex.Table.Model.CsType.Name}{(options.UseNullableReferenceTypes ? "?" : "")} {relationProperty.PropertyName} {{ get; }}";
            else
                yield return $"{namespaceTab}{tab}public abstract IImmutableRelation<{otherPart.ColumnIndex.Table.Model.CsType.Name}> {relationProperty.PropertyName} {{ get; }}";

            yield return $"";
        }

        yield return namespaceTab + "}";
    }

    private string FormatDefaultValue(object value)
    {
        if (value is string str)
            return $"\"{str}\"";

        if (value is bool b)
            return b ? "true" : "false";

        if (value is DateTime dt)
            return $"DateTime.Parse(\"{dt:yyyy-MM-dd HH:mm:ss}\")";

        if (value is DateTimeOffset dto)
            return $"DateTimeOffset.Parse(\"{dto:yyyy-MM-dd HH:mm:ss}\")";

        if (value is TimeSpan ts)
            return $"TimeSpan.Parse(\"{ts:hh\\:mm\\:ss}\")";

        return value.ToString();
    }

    private string GetPropertyNullable(ColumnDefinition column)
    {
        return (options.UseNullableReferenceTypes || column.ValueProperty.CsNullable) && (column.Nullable || column.AutoIncrement || column.ValueProperty.HasDefaultValue()) ? "?" : "";
    }

    private IEnumerable<string> WriteEnum(ModelFileFactoryOptions options, ValueProperty property)
    {
        yield return $"{namespaceTab}public enum {property.CsType.Name}";
        yield return namespaceTab + "{";
        //yield return $"{tab}{tab}Empty,";

        foreach (var val in property.EnumProperty!.Value.EnumValues)
            yield return $"{namespaceTab}{tab}{val.name} = {val.value},";

        yield return namespaceTab + "}";
        yield return "";
    }

    private IEnumerable<string> FileHeader(string namespaceName, bool useFileScopedNamespaces, IEnumerable<string> usings)
    {
        foreach (var row in usings)
            yield return $"using {row};";

        yield return "";
        yield return $"namespace {namespaceName}{(useFileScopedNamespaces ? ";" : "")}";


        if (useFileScopedNamespaces)
            yield return "";
        else
            yield return "{";
    }

    private IEnumerable<string> FileFooter(bool useFileScopedNamespaces)
    {
        if (!useFileScopedNamespaces)
            yield return "}";
    }
}

================
File: src/DataLinq.Core/Factories/SyntaxParser.cs
================
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using DataLinq.Attributes;
using DataLinq.ErrorHandling;
using DataLinq.Extensions.Helpers;
using DataLinq.Metadata;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ThrowAway;
using ThrowAway.Extensions;

namespace DataLinq.Core.Factories;

public class SyntaxParser
{
    private static readonly string[] modelInterfaceNames = ["IDatabaseModel", "ITableModel", "IViewModel", "IModelInstance"];
    private static readonly string[] customModelInterfaceName = ["ICustomDatabaseModel", "ICustomTableModel", "ICustomViewModel"];
    private readonly ImmutableArray<TypeDeclarationSyntax> modelSyntaxes;

    public static bool IsModelInterface(string interfaceName) =>
        modelInterfaceNames.Any(interfaceName.StartsWith);

    public static bool IsCustomModelInterface(string interfaceName) =>
        customModelInterfaceName.Any(interfaceName.StartsWith);

    public SyntaxParser(ImmutableArray<TypeDeclarationSyntax> modelSyntaxes)
    {
        this.modelSyntaxes = modelSyntaxes;
    }

    public Option<TableModel, IDLOptionFailure> ParseTableModel(DatabaseDefinition database, TypeDeclarationSyntax typeSyntax, string csPropertyName)
    {
        ModelDefinition model;
        if (typeSyntax == null)
        {
            model = new ModelDefinition(new CsTypeDeclaration(csPropertyName, database.CsType.Namespace, ModelCsType.Interface));
        }
        else
        {
            if (!ParseModel(typeSyntax).TryUnwrap(out model, out var failure))
                return failure;
        }

        return new TableModel(csPropertyName, database, model, typeSyntax == null);
    }

    private Option<ModelDefinition, IDLOptionFailure> ParseModel(TypeDeclarationSyntax typeSyntax)
    {
        var model = new ModelDefinition(new CsTypeDeclaration(typeSyntax));

        if (!string.IsNullOrEmpty(typeSyntax.SyntaxTree.FilePath))
            model.SetCsFile(new CsFileDeclaration(typeSyntax.SyntaxTree.FilePath));

        if (!typeSyntax.AttributeLists.SelectMany(attrList => attrList.Attributes).Select(ParseAttribute).Transpose().TryUnwrap(out var attributes, out var failures))
            return DLOptionFailure.Fail($"Parsing attributes", model, failures);

        model.SetAttributes(attributes);

        var modelInstanceInterfaces = model.Attributes
            .Where(x => x is InterfaceAttribute interfaceAttribute && interfaceAttribute.GenerateInterface)
            .Select(x => x as InterfaceAttribute)
            .Select(x => new CsTypeDeclaration(x?.Name ?? $"I{model.CsType.Name}", model.CsType.Namespace, ModelCsType.Interface))
            .ToList();

        if (modelInstanceInterfaces.Count > 1)
            return DLOptionFailure.Fail(DLFailureType.InvalidArgument,
                $"Multiple model instance interfaces ({modelInstanceInterfaces.Select(x => x.Name).ToJoinedString(", ")}) found in model", model);

        //if (modelInstanceInterfaces.GroupBy(x => x.Name).Any(x => x.Count() > 1))
        //    return DLOptionFailure.Fail(DLFailureType.InvalidArgument,
        //        $"Duplicate interface names {modelInstanceInterfaces.GroupBy(x => x.Name).Where(x => x.Count() > 1).ToJoinedString()} in model '{model.CsType.Name}'");

        if (modelInstanceInterfaces.Any())
            model.SetModelInstanceInterface(modelInstanceInterfaces.First());

        if (typeSyntax.BaseList != null)
        {
            // Build all interfaces from the BaseList.
            var interfaces = typeSyntax.BaseList.Types
                .Select(baseType => new CsTypeDeclaration(baseType))
                .Where(x => !x.Name.StartsWith("Immutable<"))
                .ToList();

            model.SetInterfaces(interfaces);
        }

        if (model.CsType.ModelCsType == ModelCsType.Interface)
            model.SetCsType(model.CsType.MutateName(MetadataTypeConverter.RemoveInterfacePrefix(model.CsType.Name)));

        if (!typeSyntax.Members.OfType<PropertyDeclarationSyntax>()
            .Where(prop => prop.AttributeLists.SelectMany(attrList => attrList.Attributes)
                .Any(attr => attr.Name.ToString() == "Column" || attr.Name.ToString() == "Relation"))
            .Select(prop => ParseProperty(prop, model))
            .Transpose()
            .TryUnwrap(out var properties, out var propFailures))
            return DLOptionFailure.Fail($"Parsing properties", model, propFailures);

        model.AddProperties(properties);

        model.SetUsings(typeSyntax.SyntaxTree.GetRoot()
            .DescendantNodes()
            .OfType<UsingDirectiveSyntax>()
            .Select(uds => uds?.Name?.ToString())
            .Where(x => !string.IsNullOrEmpty(x))
            .Distinct()
            .OrderBy(ns => ns!.StartsWith("System"))
            .ThenBy(ns => ns)
            .Select(ns => new ModelUsing(ns!)));

        return model;
    }

    public Option<Attribute, IDLOptionFailure> ParseAttribute(AttributeSyntax attributeSyntax)
    {
        var name = attributeSyntax.Name.ToString();
        var generictype = attributeSyntax.Name as GenericNameSyntax;
        var arguments = attributeSyntax.ArgumentList?.Arguments
            .Select(x => x.Expression.ToString().Trim('"'))
            .ToList() ?? [];

        if (name == "Database")
        {
            if (arguments.Count != 1)
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' doesn't have any arguments");

            return new DatabaseAttribute(arguments[0]);
        }

        if (name == "Table")
        {
            if (arguments.Count != 1)
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' doesn't have any arguments");

            return new TableAttribute(arguments[0]);
        }

        if (name == "View")
        {
            if (arguments.Count != 1)
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' doesn't have any arguments");

            return new ViewAttribute(arguments[0]);
        }

        if (name == "Column")
        {
            if (arguments.Count != 1)
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' doesn't have any arguments");

            return new ColumnAttribute(arguments[0]);
        }

        if (name == "Definition")
        {
            if (arguments.Count != 1)
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' doesn't have any arguments");

            return new DefinitionAttribute(arguments[0]);
        }

        if (name == "UseCache")
        {
            if (arguments.Count == 1)
                return new UseCacheAttribute(bool.Parse(arguments[0]));
            else
                return new UseCacheAttribute();
        }

        if (name == "CacheLimit")
        {
            if (arguments.Count != 2)
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' doesn't have 2 arguments");

            if (!Enum.TryParse(arguments[0].Split('.').Last(), out CacheLimitType limitType))
                return DLOptionFailure.Fail(DLFailureType.InvalidType, $"Invalid CacheLimitType value '{arguments[0]}'");

            return new CacheLimitAttribute(limitType, long.Parse(arguments[1]));
        }

        if (name == "CacheCleanup")
        {
            if (arguments.Count != 2)
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' doesn't have 2 arguments");

            if (!Enum.TryParse(arguments[0].Split('.').Last(), out CacheCleanupType cleanupType))
                return DLOptionFailure.Fail(DLFailureType.InvalidType, $"Invalid CacheCleanupType value '{arguments[0]}'");

            return new CacheCleanupAttribute(cleanupType, long.Parse(arguments[1]));
        }

        if (name == "IndexCache")
        {
            if (arguments.Count < 1 || arguments.Count > 2)
            {
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' doesn't have 1 or 2 arguments");
            }

            if (!Enum.TryParse(arguments[0].Split('.').Last(), out IndexCacheType indexCacheType))
            {
                return DLOptionFailure.Fail(DLFailureType.InvalidType, $"Invalid IndexCacheType value '{arguments[0]}'");
            }

            return arguments.Count == 1
                ? new IndexCacheAttribute(indexCacheType)
                : new IndexCacheAttribute(indexCacheType, int.Parse(arguments[1]));
        }

        if (name == "AutoIncrement")
        {
            if (arguments.Any())
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' have too many arguments");

            return new AutoIncrementAttribute();
        }

        if (name == "Relation")
        {
            if (arguments.Count == 2)
                return new RelationAttribute(arguments[0], arguments[1]);
            else if (arguments.Count == 3)
                return new RelationAttribute(arguments[0], arguments[1], arguments[2]);
            else
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' doesn't have 2 or 3 arguments");
        }

        if (name == "PrimaryKey")
        {
            if (arguments.Any())
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' have too many arguments");

            return new PrimaryKeyAttribute();
        }

        if (name == "ForeignKey")
        {
            if (arguments.Count != 3)
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' must have 3 arguments");

            return new ForeignKeyAttribute(arguments[0], arguments[1], arguments[2]);
        }

        if (name == "Enum")
        {
            return new EnumAttribute([.. arguments]);
        }

        if (name == "Nullable")
        {
            if (arguments.Any())
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' have too many arguments");

            return new NullableAttribute();
        }

        if (name == "Default")
        {
            if (arguments.Count != 1)
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' have too few arguments");

            return new DefaultAttribute(arguments[0]);
        }

        if (name == "DefaultCurrentTimestamp")
        {
            if (arguments.Count != 0)
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' have too many arguments");

            return new DefaultCurrentTimestampAttribute();
        }

        if (name == "Index")
        {
            if (arguments.Count < 2)
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' have too few arguments");

            string indexName = arguments[0];
            if (!Enum.TryParse(arguments[1].Split('.').Last(), out IndexCharacteristic characteristic))
                return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Invalid IndexCharacteristic value '{arguments[1]}'");

            if (arguments.Count == 2)
                return new IndexAttribute(arguments[0], characteristic);

            if (Enum.TryParse(arguments[2].Split('.').Last(), out IndexType type))
                return new IndexAttribute(indexName, characteristic, type, arguments.Skip(3).ToArray());
            else
                return new IndexAttribute(indexName, characteristic, arguments.Skip(2).ToArray());
        }


        if (name == "Type")
        {
            string enumValue = arguments[0].Split('.').Last();
            if (Enum.TryParse(enumValue, out DatabaseType dbType))
            {
                switch (arguments.Count)
                {
                    case 1: return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' have too few arguments");
                    case 2: return new TypeAttribute(dbType, arguments[1]);
                    case 3:
                        if (long.TryParse(arguments[2], out long length))
                            return new TypeAttribute(dbType, arguments[1], length);
                        else
                            return new TypeAttribute(dbType, arguments[1], bool.Parse(arguments[2]));
                    case 4:
                        if (int.TryParse(arguments[3], out int decimals))
                            return new TypeAttribute(dbType, arguments[1], long.Parse(arguments[2]), decimals);
                        else
                            return new TypeAttribute(dbType, arguments[1], long.Parse(arguments[2]), bool.Parse(arguments[3]));
                    case 5:
                        return new TypeAttribute(dbType, arguments[1], long.Parse(arguments[2]), int.Parse(arguments[3]), bool.Parse(arguments[4]));
                }
            }
            else
            {
                switch (arguments.Count)
                {
                    case 1: return new TypeAttribute(arguments[0]);
                    case 2:
                        if (long.TryParse(arguments[1], out long length))
                            return new TypeAttribute(arguments[0], length);
                        else
                            return new TypeAttribute(arguments[0], bool.Parse(arguments[1]));
                    case 3:
                        return new TypeAttribute(arguments[0], long.Parse(arguments[1]), bool.Parse(arguments[2]));
                    case 4:
                        return new TypeAttribute(arguments[0], long.Parse(arguments[1]), int.Parse(arguments[2]), bool.Parse(arguments[3]));
                }
            }

            return DLOptionFailure.Fail(DLFailureType.NotImplemented, $"Attribute 'TypeAttribute' with {arguments.Count} arguments not implemented");
        }

        if (name.StartsWith("Interface"))
        {
            // Handle generic InterfaceAttribute<T>
            if (generictype != null)
            {
                if (arguments.Count > 1)
                    return DLOptionFailure.Fail(DLFailureType.InvalidArgument, $"Attribute '{name}' have too many arguments");

                // Extract the type argument from the generic type
                var typeArgument = generictype.TypeArgumentList.Arguments[0].ToString();
                return new InterfaceAttribute(typeArgument, arguments.Count == 0 || bool.Parse(arguments[0]));
            }

            if (arguments.Count == 1)
                return new InterfaceAttribute(arguments[0]);
            else if (arguments.Count == 2)
                return new InterfaceAttribute(arguments[0], bool.Parse(arguments[1]));
            else
                return new InterfaceAttribute();
        }

        return DLOptionFailure.Fail(DLFailureType.NotImplemented, $"Attribute '{name}' not implemented");
    }

    public Option<PropertyDefinition, IDLOptionFailure> ParseProperty(PropertyDeclarationSyntax propSyntax, ModelDefinition model)
    {
        if (!propSyntax.AttributeLists
            .SelectMany(attrList => attrList.Attributes)
            .Select(ParseAttribute)
            .Transpose()
            .TryUnwrap(out var attributes, out var failures))
            return DLOptionFailure.Fail($"Parsing attributes for {propSyntax.Identifier.Text}", model, failures);

        PropertyDefinition property = attributes.Any(attribute => attribute is RelationAttribute)
            ? new RelationProperty(propSyntax.Identifier.Text, new CsTypeDeclaration(propSyntax), model, attributes)
            : new ValueProperty(propSyntax.Identifier.Text, new CsTypeDeclaration(propSyntax), model, attributes);

        if (property is ValueProperty valueProp)
        {
            valueProp.SetCsNullable(propSyntax.Type is NullableTypeSyntax);

            if (attributes.Any(attribute => attribute is EnumAttribute))
            {
                valueProp.SetCsSize(MetadataTypeConverter.CsTypeSize("enum"));

                var enumValueList = attributes.OfType<EnumAttribute>().Single().Values.Select((x, i) => (x, i + 1)).ToList();
                valueProp.SetEnumProperty(new EnumProperty(enumValueList, null, true));
            }
            else
            {
                valueProp.SetCsSize(MetadataTypeConverter.CsTypeSize(property.CsType.Name));
            }
        }

        return property;
    }

    public Option<(string csPropertyName, TypeDeclarationSyntax classSyntax), IDLOptionFailure> GetTableType(PropertyDeclarationSyntax property, List<TypeDeclarationSyntax> modelTypeSyntaxes)
    {
        var propType = property.Type;

        if (propType is GenericNameSyntax genericType && genericType.Identifier.Text == "DbRead")
        {
            var typeArgument = genericType.TypeArgumentList.Arguments[0] as IdentifierNameSyntax;
            if (typeArgument != null)
            {
                var modelClass = modelTypeSyntaxes.FirstOrDefault(cls => cls.Identifier.Text == typeArgument.Identifier.Text);
                return (property.Identifier.Text, modelClass);
            }
        }

        return DLOptionFailure.Fail(DLFailureType.NotImplemented, $"Table type {propType} is not implemented.");
    }

    private bool InheritsFrom(CsTypeDeclaration decl, string typeName)
    {
        var matchingSyntax = modelSyntaxes.FirstOrDefault(ts => ts.Identifier.Text == decl.Name);
        if (matchingSyntax == null)
            return false;

        // If the matching syntax has a BaseList, check each base type.
        if (matchingSyntax.BaseList != null)
        {
            foreach (var baseTypeSyntax in matchingSyntax.BaseList.Types)
            {
                // Create a CsTypeDeclaration for the base type.
                var baseDecl = new CsTypeDeclaration(baseTypeSyntax);

                // Direct match: if the baseDecl's name is the type of interest.
                if (baseDecl.Name == typeName || baseDecl.Name.StartsWith(typeName + "<"))
                    return true;

                // Recursively check if the base type inherits from the type.
                if (InheritsFrom(baseDecl, typeName))
                    return true;
            }
        }
        return false;
    }
}

================
File: src/DataLinq.Core/Interfaces/IDataSourceAccess.cs
================
namespace DataLinq.Interfaces;

public interface IDataSourceAccess
{
}

================
File: src/DataLinq.Core/Interfaces/IDefinition.cs
================
using DataLinq.Metadata;

namespace DataLinq.Interfaces;

public interface IDefinition
{
    CsFileDeclaration? CsFile { get; }
}

================
File: src/DataLinq.Core/Interfaces/IModel.cs
================
namespace DataLinq.Interfaces;

public interface IModel
{

}

public interface IModel<T> : IModel
    where T : IDatabaseModel
{

}

public interface IDatabaseModel
{

}

//public interface ICustomDatabaseModel : IDatabaseModel
//{

//}

public interface ITableModel : IModel
{

}

public interface ITableModel<T> : IModel<T>
    where T : IDatabaseModel
{

}

//public interface ICustomTableModel : ITableModel
//{

//}

//public interface ICustomTableModel<T> : ITableModel<T>
//    where T : IDatabaseModel
//{

//}

public interface IViewModel : IModel
{

}

public interface IViewModel<T> : IModel<T>
    where T : IDatabaseModel
{

}

//public interface ICustomViewModel : IViewModel
//{

//}

//public interface ICustomViewModel<T> : IViewModel<T>
//    where T : IDatabaseModel
//{

//}

================
File: src/DataLinq.Core/Interfaces/IView.cs
================
namespace DataLinq.Interfaces;

public interface IView
{

}

public interface IWritableView : IView
{

}

public interface IReadableView : IView
{

}

================
File: src/DataLinq.Core/Metadata/ColumnDefinition.cs
================
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Extensions.Helpers;
using DataLinq.Interfaces;

namespace DataLinq.Metadata;

public class DatabaseColumnType(DatabaseType databaseType, string name, long? length = null, int? decimals = null, bool? signed = null)
{
    public DatabaseType DatabaseType { get; } = databaseType;
    public string Name { get; private set; } = name;
    public void SetName(string name) => Name = name;
    public long? Length { get; private set; } = length;
    public void SetLength(long? length) => Length = length == 0 ? null : length;
    public int? Decimals { get; private set; } = decimals;
    public void SetDecimals(int? decimals) => Decimals = decimals;
    public void SetDecimals(long? decimals) => Decimals = (int?)decimals;
    public bool? Signed { get; private set; } = signed;
    public void SetSigned(bool signed) => Signed = signed;

    public override string ToString() => $"{Name} ({Length}) [{DatabaseType}]";

    public DatabaseColumnType Clone() => new(DatabaseType, Name, Length, Decimals, Signed);
}

public class ColumnDefinition(string dbName, TableDefinition table) : IDefinition
{
    public TableDefinition Table { get; } = table;
    public string DbName { get; private set; } = dbName;
    public void SetDbName(string value) => DbName = value;
    public DatabaseColumnType[] DbTypes { get; private set; } = [];
    public int Index { get; private set; }
    public bool ForeignKey { get; private set; }
    public void SetForeignKey(bool value = true) => ForeignKey = value;
    public bool PrimaryKey { get; private set; }
    public bool Unique => ColumnIndices.Any(x => x.Characteristic == Attributes.IndexCharacteristic.Unique);
    public bool AutoIncrement { get; private set; }
    public void SetAutoIncrement(bool value = true) => AutoIncrement = value;
    public bool Nullable { get; private set; }
    public void SetNullable(bool value = true) => Nullable = value;
    
    public IEnumerable<ColumnIndex> ColumnIndices => Table.ColumnIndices.Where(x => x.Columns.Contains(this));
    public ValueProperty ValueProperty { get; private set; }

    public CsFileDeclaration? CsFile => Table?.Model?.CsFile;

    public void SetValueProperty(ValueProperty value)
    {
        ValueProperty = value;
        value.SetColumn(this);
    }

    public void SetPrimaryKey(bool value = true)
    {
        PrimaryKey = value;

        if (value)
            Table.AddPrimaryKeyColumn(this);
        else
            Table.RemovePrimaryKeyColumn(this);
    }

    public void AddDbType(DatabaseColumnType columnType)
    {
        DbTypes = DbTypes.AsEnumerable().Append(columnType).ToArray();
    }

    private readonly ConcurrentDictionary<DatabaseType, DatabaseColumnType?> cachedDbTypes = new();
    public DatabaseColumnType? GetDbTypeFor(DatabaseType databaseType)
    {
        if (cachedDbTypes.TryGetValue(databaseType, out DatabaseColumnType? result))
            return result;
        else
            return cachedDbTypes.GetOrAdd(databaseType, type => DbTypes.FirstOrDefault(x => x.DatabaseType == type) ?? DbTypes.FirstOrDefault());
    }

    public override string ToString() => $"{Table.DbName}.{DbName} ({DbTypes.ToJoinedString(", ")})";
}

================
File: src/DataLinq.Core/Metadata/ColumnIndex.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Attributes;

namespace DataLinq.Metadata;

/// <summary>
/// Represents an index associated with one or more columns in a database table.
/// </summary>
public class ColumnIndex
{
    /// <summary>
    /// Table that the index belongs to.
    /// </summary>
    public TableDefinition Table { get; set; }

    /// <summary>
    /// Gets or sets the list of columns associated with the index. 
    /// Each entry includes the column in the order of the index.
    /// </summary>
    public List<ColumnDefinition> Columns { get; }

    public List<RelationPart> RelationParts { get; set; } = new List<RelationPart>();

    /// <summary>
    /// Gets or sets the characteristic of the index, such as whether it's a primary key or unique.
    /// </summary>
    public IndexCharacteristic Characteristic { get; }

    /// <summary>
    /// Gets or sets the type of the index, indicating the underlying data structure or algorithm used.
    /// </summary>
    public IndexType Type { get; }

    /// <summary>
    /// Gets or sets the name of the index.
    /// </summary>
    public string Name { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="ColumnIndex"/> class.
    /// </summary>
    /// <param name="name">The name of the index.</param>
    /// <param name="characteristic">The characteristic of the index.</param>
    /// <param name="type">The type of the index.</param>
    /// <param name="columns">The columns associated with the index.</param>
    public ColumnIndex(string name, IndexCharacteristic characteristic, IndexType type, List<ColumnDefinition> columns)
    {
        Name = name;
        Characteristic = characteristic;
        Type = type;
        this.Columns = columns ?? [];
        this.Table = this.Columns.First().Table;
        Validate();
    }

    public void AddColumn(ColumnDefinition column)
    {
        if (Columns.Contains(column))
            throw new ArgumentException($"Columns already contains column '{column}'");
        
        Columns.Add(column);
    }

    /// <summary>
    /// Provides a string representation of the <see cref="ColumnIndex"/> object.
    /// </summary>
    /// <returns>A string representation of the index.</returns>
    public override string ToString()
    {
        return $"{Name} ({Type}, {Characteristic}) on columns: {string.Join(", ", Columns.Select(c => c.DbName))}";
    }

    /// <summary>
    /// Validates the index's type and characteristic.
    /// </summary>
    private void Validate()
    {
        // Index name should not be empty.
        if (string.IsNullOrWhiteSpace(Name))
        {
            throw new InvalidOperationException("Index name cannot be empty.");
        }

        // An index should have at least one column.
        if (!Columns.Any())
        {
            throw new InvalidOperationException("An index should have at least one column.");
        }

        if (Columns.Any(c => c.Table != Table))
        {
            throw new InvalidOperationException("All columns in an index must belong to the same table.");
        }

        // A FULLTEXT index should not be a primary key or unique.
        if (Type == IndexType.FULLTEXT && (Characteristic == IndexCharacteristic.PrimaryKey || Characteristic == IndexCharacteristic.Unique))
        {
            throw new InvalidOperationException("A FULLTEXT index cannot be a primary key or unique.");
        }

        // A primary key index should not be of type FULLTEXT or HASH.
        if (Characteristic == IndexCharacteristic.PrimaryKey && (Type == IndexType.FULLTEXT || Type == IndexType.HASH))
        {
            throw new InvalidOperationException("A primary key index cannot be of type FULLTEXT or HASH.");
        }

        // A unique index should not be of type FULLTEXT.
        if (Characteristic == IndexCharacteristic.Unique && Type == IndexType.FULLTEXT)
        {
            throw new InvalidOperationException("A unique index cannot be of type FULLTEXT.");
        }

        // A FULLTEXT index should have Simple as its characteristic.
        if (Type == IndexType.FULLTEXT && Characteristic != IndexCharacteristic.Simple)
        {
            throw new InvalidOperationException("A FULLTEXT index should have Simple as its characteristic.");
        }

        // Additional validations can be added here as needed.
    }
}

================
File: src/DataLinq.Core/Metadata/CsFileDeclaration.cs
================
using System;
using System.IO;

namespace DataLinq.Metadata;

public readonly record struct CsFileDeclaration
{
    public string Name { get; }
    public string FullPath { get; }
    public CsFileDeclaration(string fullPath)
    {
        if (string.IsNullOrEmpty(fullPath))
            throw new ArgumentException($"Argument '{nameof(fullPath)}' is null or empty");

        FullPath = fullPath;
        Name = Path.GetFileName(fullPath);
    }

    public override string ToString() => FullPath;
}

================
File: src/DataLinq.Core/Metadata/CsTypeDeclaration.cs
================
using System;
using System.Reflection;
using DataLinq.Core.Factories;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DataLinq.Metadata;

public enum ModelCsType
{
    Class,
    Record,
    Interface,
    Struct,
    Primitive,
    Enum,
    Tuple,
    Pointer
}

public class ModelUsing(string fullNamespaceName)
{
    public string FullNamespaceName { get; } = fullNamespaceName;

    public override string ToString() => FullNamespaceName;
}

public readonly record struct CsTypeDeclaration
{
    public readonly Type? Type { get; }
    public readonly string Name { get; }
    public readonly string Namespace { get; }
    public readonly ModelCsType ModelCsType { get; }

    public CsTypeDeclaration(Type type)
    {
        if (type == null)
            throw new ArgumentNullException(nameof(type));

        Type = type;
        Name = MetadataTypeConverter.GetKeywordName(type);
        Namespace = type.Namespace;
        ModelCsType = ParseModelCsType(type);
    }

    public CsTypeDeclaration(TypeDeclarationSyntax typeSyntax)
    {
        string genericPart = typeSyntax.TypeParameterList != null
            ? typeSyntax.TypeParameterList.ToString()
            : string.Empty;

        Name = MetadataTypeConverter.GetKeywordName(typeSyntax.Identifier.Text + genericPart);
        Namespace = GetNamespace(typeSyntax);
        ModelCsType = ParseModelCsType(typeSyntax);
    }

    public CsTypeDeclaration(PropertyDeclarationSyntax propertyDeclarationSyntax)
    {
        Name = MetadataTypeConverter.GetKeywordName(ParseTypeName(propertyDeclarationSyntax.Type) ?? string.Empty);

        //var typeSyntax = propertyDeclarationSyntax.Type;
        //Name = MetadataTypeConverter.GetKeywordName(typeSyntax.ToString().Trim('?', '"', '\"'));
        Namespace = GetNamespace(propertyDeclarationSyntax);
        ModelCsType = ParseModelCsType(propertyDeclarationSyntax.Type);
    }

    public CsTypeDeclaration(BaseTypeSyntax baseTypeSyntax)
    {

        Name = MetadataTypeConverter.GetKeywordName(ParseTypeName(baseTypeSyntax.Type) ?? string.Empty);
        Namespace = GetNamespace(baseTypeSyntax);
        ModelCsType = ParseModelCsType(baseTypeSyntax.Type);
    }


    public CsTypeDeclaration(string name, string @namespace, ModelCsType modelCsType)
    {
        Name = name;
        Namespace = @namespace;
        ModelCsType = modelCsType;
    }

    public CsTypeDeclaration MutateName(string name) => new(name, Namespace, ModelCsType);

    //public CsTypeDeclaration Clone() => new(Name, Namespace, ModelCsType);

    private static string ParseTypeName(TypeSyntax baseTypeSyntax)
    {
        return baseTypeSyntax switch
        {
            GenericNameSyntax genericName => genericName.ToString(),
            SimpleNameSyntax simpleName => simpleName.Identifier.Text,
            _ => baseTypeSyntax.ToString().Trim('?', '"', '\"')
        };
    }

    public static ModelCsType ParseModelCsType(Type type)
    {
        if (type.IsClass)
        {
            if (type.GetProperty("EqualityContract", BindingFlags.NonPublic | BindingFlags.Instance) != null)
                return ModelCsType.Record;

            return ModelCsType.Class;
        }

        if (type.IsInterface)
            return ModelCsType.Interface;

        if (type.IsValueType)
        {
            if (type.IsPrimitive)
            {
                // Handle primitive types (e.g., int, bool, char)
                return ModelCsType.Primitive;
            }
            else
            {
                // Handle other value types (e.g., structs, enums)
                return ModelCsType.Struct;
            }
        }

        throw new NotImplementedException($"Unknown type '{type}'");
    }

    public static string GetNamespace(SyntaxNode typeSyntax)
    {
        // Traverse up the syntax tree to find the containing namespace
        SyntaxNode? potentialNamespaceParent = typeSyntax.Parent;

        while (potentialNamespaceParent != null && !(potentialNamespaceParent is NamespaceDeclarationSyntax || potentialNamespaceParent is FileScopedNamespaceDeclarationSyntax))
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        // If we found a NamespaceDeclarationSyntax, return its name
        if (potentialNamespaceParent is NamespaceDeclarationSyntax namespaceDeclaration)
        {
            return namespaceDeclaration.Name.ToString();
        }
        else if (potentialNamespaceParent is FileScopedNamespaceDeclarationSyntax fileScopedNamespaceDeclaration)
        {
            return fileScopedNamespaceDeclaration.Name.ToString();
        }

        // If no namespace was found, return an empty string or some default value
        return string.Empty;
    }

    public static ModelCsType ParseModelCsType(SyntaxNode syntaxNode)
    {
        if (syntaxNode is TypeDeclarationSyntax typeDeclarationSyntax)
        {
            return typeDeclarationSyntax switch
            {
                ClassDeclarationSyntax => ModelCsType.Class,
                RecordDeclarationSyntax => ModelCsType.Record,
                InterfaceDeclarationSyntax => ModelCsType.Interface,
                StructDeclarationSyntax => ModelCsType.Struct,
                _ => throw new NotImplementedException($"Unknown type of TypeDeclarationSyntax '{typeDeclarationSyntax}'"),
            };
        }
        else if (syntaxNode is EnumDeclarationSyntax)
        {
            // Handle enum types
            return ModelCsType.Struct; // Assuming enums are treated as structs
        }
        else
        {
            throw new NotImplementedException($"Unknown type of SyntaxNode '{syntaxNode}'");
        }
    }

    public static ModelCsType ParseModelCsType(TypeSyntax typeSyntax)
    {
        if (typeSyntax is NullableTypeSyntax nullableTypeSyntax)
        {
            // Handle nullable types
            return ParseModelCsType(nullableTypeSyntax.ElementType);
        }
        else if (typeSyntax is ArrayTypeSyntax arrayTypeSyntax)
        {
            // Handle array types
            return ParseModelCsType(arrayTypeSyntax.ElementType);
        }
        else if (typeSyntax is QualifiedNameSyntax qualifiedNameSyntax)
        {
            // Handle qualified names (e.g., System.String)
            return ParseModelCsType(qualifiedNameSyntax.Right);
        }
        else if (typeSyntax is AliasQualifiedNameSyntax aliasQualifiedNameSyntax)
        {
            // Handle alias qualified names (e.g., global::System.String)
            return ParseModelCsType(aliasQualifiedNameSyntax.Name);
        }
        else if (typeSyntax is TupleTypeSyntax)
        {
            // Handle tuple types
            return ModelCsType.Struct; // Assuming tuples are treated as structs
        }
        else if (typeSyntax is PointerTypeSyntax)
        {
            // Handle pointer types
            return ModelCsType.Struct; // Assuming pointers are treated as structs
        }
        else if (typeSyntax is PredefinedTypeSyntax predefinedTypeSyntax)
        {
            // Handle predefined types (built-in types)
            var typeName = predefinedTypeSyntax.Keyword.Text;
            if (MetadataTypeConverter.IsKnownCsType(typeName))
            {
                if (MetadataTypeConverter.IsPrimitiveType(typeName))
                    return ModelCsType.Primitive;
                else
                    return ModelCsType.Struct;
            }
            else
                throw new NotImplementedException($"Unknown predefined type '{typeName}'");
        }
        else if (typeSyntax is SimpleNameSyntax simpleNameSyntax)
        {
            // Check if the type name ends with "Class", "Record", or "Interface"
            var typeName = simpleNameSyntax.Identifier.Text;
            if (typeName.EndsWith("Class"))
                return ModelCsType.Class;
            if (typeName.EndsWith("Record"))
                return ModelCsType.Record;
            if (typeName.EndsWith("Interface"))
                return ModelCsType.Interface;

            // Default to class if no specific suffix is found
            return ModelCsType.Class;
        }
        else if (typeSyntax is GenericNameSyntax genericNameSyntax)
        {
            // Handle generic types
            var typeName = genericNameSyntax.Identifier.Text;
            if (typeName.EndsWith("Class"))
                return ModelCsType.Class;
            if (typeName.EndsWith("Record"))
                return ModelCsType.Record;
            if (typeName.EndsWith("Interface"))
                return ModelCsType.Interface;

            // Default to class if no specific suffix is found
            return ModelCsType.Class;
        }
        else
        {
            throw new NotImplementedException($"Unknown type of TypeSyntax '{typeSyntax}'");
        }
    }
}

================
File: src/DataLinq.Core/Metadata/DatabaseDefinition.cs
================
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Attributes;
using DataLinq.Interfaces;

namespace DataLinq.Metadata;

public class DatabaseDefinition : IDefinition
{
    public static ConcurrentDictionary<Type, DatabaseDefinition> LoadedDatabases { get; } = new();

    public DatabaseDefinition(string name, CsTypeDeclaration csType, string? dbName = null)
    {
        Name = name;
        DbName = dbName ?? Name;
        CsType = csType;
    }

    public string Name { get; private set; }
    public void SetName(string name) => Name = name;
    public string DbName { get; private set; }
    public void SetDbName(string dbName) => DbName = dbName;
    public CsTypeDeclaration CsType { get; private set; }
    public void SetCsType(CsTypeDeclaration csType) => CsType = csType;
    public CsFileDeclaration? CsFile { get; private set; }
    public void SetCsFile(CsFileDeclaration csFile) => CsFile = csFile;
    public bool UseCache { get; private set; }
    public void SetCache(bool useCache) => UseCache = useCache;
    public Attribute[] Attributes { get; private set; } = [];
    public void SetAttributes(IEnumerable<Attribute> attributes) => Attributes = attributes.ToArray();
    public TableModel[] TableModels { get; private set; } = [];
    public void SetTableModels(IEnumerable<TableModel> tableModels) => TableModels = tableModels.ToArray();
    public List<(CacheLimitType limitType, long amount)> CacheLimits { get; private set; } = [];
    public List<(IndexCacheType indexCacheType, int? amount)> IndexCache { get; private set; } = [];
    public List<(CacheCleanupType cleanupType, long amount)> CacheCleanup { get; private set; } = [];
}

================
File: src/DataLinq.Core/Metadata/ModelDefinition.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Interfaces;

namespace DataLinq.Metadata;

public class ModelDefinition(CsTypeDeclaration csType) : IDefinition
{
    public CsTypeDeclaration CsType { get; private set; } = csType;
    public void SetCsType(CsTypeDeclaration csType) => CsType = csType;
    public CsFileDeclaration? CsFile { get; private set; }
    public void SetCsFile(CsFileDeclaration csFile) => CsFile = csFile;
    public TableModel TableModel { get; private set; }
    internal void SetTableModel(TableModel tableModel) => TableModel = tableModel;
    public DatabaseDefinition Database => TableModel.Database;
    public TableDefinition Table => TableModel.Table;
    public CsTypeDeclaration? ImmutableType { get; private set; }
    public void SetImmutableType(CsTypeDeclaration immutableType) => ImmutableType = immutableType;
    public CsTypeDeclaration? MutableType { get; private set; }
    public void SetMutableType(CsTypeDeclaration mutableType) => MutableType = mutableType;
    public CsTypeDeclaration? ModelInstanceInterface { get; private set; }
    public void SetModelInstanceInterface(CsTypeDeclaration? interfaceType) => ModelInstanceInterface = interfaceType;
    public CsTypeDeclaration[] OriginalInterfaces { get; private set; } = [];
    public void SetInterfaces(IEnumerable<CsTypeDeclaration> interfaces) => OriginalInterfaces = interfaces.ToArray();
    public ModelUsing[] Usings { get; private set; } = [];
    public void SetUsings(IEnumerable<ModelUsing> usings) => Usings = usings.ToArray();
    public Dictionary<string, RelationProperty> RelationProperties { get; } = new();
    public Dictionary<string, ValueProperty> ValueProperties { get; } = new();
    public Attribute[] Attributes { get; private set; } = [];
    public void SetAttributes(IEnumerable<Attribute> attributes) => Attributes = attributes.ToArray();

    public void AddProperties(IEnumerable<PropertyDefinition> properties)
    {
        foreach (var property in properties)
            AddProperty(property);
    }

    public void AddProperty(PropertyDefinition property)
    {
        if (property is RelationProperty relationProperty)
            RelationProperties.Add(relationProperty.PropertyName, relationProperty);
        else if (property is ValueProperty valueProperty)
            ValueProperties.Add(valueProperty.PropertyName, valueProperty);
        else
            throw new NotImplementedException();
    }

    protected bool IsOfType(Type modelType) =>
           modelType == CsType.Type || modelType.BaseType == CsType.Type;

    public static ModelDefinition? Find(IModel model) =>
        DatabaseDefinition
        .LoadedDatabases
        .Values
        .Select(x => Array.Find(x.TableModels, y => y.Model.IsOfType(model.GetType())))
        .FirstOrDefault(x => x != null)
        ?.Model;

    public static ModelDefinition? Find<T>() where T : IModel =>
        DatabaseDefinition
        .LoadedDatabases
        .Values
        .Select(x => Array.Find(x.TableModels, y => y.Model.IsOfType(typeof(T))))
        .FirstOrDefault(x => x != null)
        ?.Model;

    public CsTypeDeclaration CsTypeOrInterface => ModelInstanceInterface ?? CsType;

    public override string ToString()
    {
        if (TableModel == null)
            return $"{CsType.Name}";
        else
            return $"{CsType.Name} ({Database?.DbName}.{Table?.DbName})";
    }
}

================
File: src/DataLinq.Core/Metadata/PropertyDefinition.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Attributes;
using DataLinq.Interfaces;

namespace DataLinq.Metadata;

public enum PropertyType
{
    Value,
    Relation
}

public abstract class PropertyDefinition(string propertyName, CsTypeDeclaration csType, ModelDefinition model, IEnumerable<Attribute> attributes) : IDefinition
{
    public Attribute[] Attributes { get; private set; } = attributes.ToArray();
    public void SetAttributes(IEnumerable<Attribute> attributes) => Attributes = attributes.ToArray();
    public void AddAttribute(Attribute attribute) => Attributes = [.. Attributes, attribute];
    public string PropertyName { get; private set; } = propertyName;
    public void SetPropertyName(string propertyName) => PropertyName = propertyName;
    public CsTypeDeclaration CsType { get; private set; } = csType;
    public void SetCsType(CsTypeDeclaration csType) => CsType = csType;
    public ModelDefinition Model { get; private set; } = model;
    public PropertyType Type { get; protected private set; }

    public CsFileDeclaration? CsFile => Model?.CsFile;

    public override string ToString() => $"Property: {CsType.Name} {PropertyName}";
}

public class ValueProperty : PropertyDefinition
{
    public ColumnDefinition Column { get; private set; }
    public void SetColumn(ColumnDefinition column) => Column = column;
    public bool CsNullable { get; private set; }
    public void SetCsNullable(bool csNullable = true) => CsNullable = csNullable;
    public int? CsSize { get; private set; }
    public void SetCsSize(int? csSize) => CsSize = csSize;
    public EnumProperty? EnumProperty { get; private set; }
    public void SetEnumProperty(EnumProperty enumProperty) => EnumProperty = enumProperty;

    public ValueProperty(string propertyName, CsTypeDeclaration csType, ModelDefinition model, IEnumerable<Attribute> attributes) : base(propertyName, csType, model, attributes)
    {
        Type = PropertyType.Value;
    }

    public bool HasDefaultValue() => Attributes.Any(x => x is DefaultAttribute);

    public DefaultAttribute? GetDefaultAttribute() => Attributes
            .Where(x => x is DefaultAttribute)
            .Select(x => x as DefaultAttribute)
            .FirstOrDefault();

    public string? GetDefaultValue()
    {
        var defaultAttr = GetDefaultAttribute();

        if (defaultAttr is DefaultCurrentTimestampAttribute)
        {
            return CsType.Name switch
            {
                "DateOnly" => "DateOnly.FromDateTime(DateTime.Now)",
                "TimeOnly" => "TimeOnly.FromDateTime(DateTime.Now)",
                "DateTime" => "DateTime.Now",
                _ => "DateTime.Now"
            };
        }

        return defaultAttr?.Value.ToString();
    }
}

public record struct EnumProperty
{
    public EnumProperty(List<(string name, int value)>? enumValues = null, List<(string name, int value)>? csEnumValues = null, bool declaredInClass = true)
    {
        DbEnumValues = enumValues ?? new();
        CsEnumValues = csEnumValues ?? new();
        DeclaredInClass = declaredInClass;
    }

    public List<(string name, int value)> DbEnumValues { get; }
    public List<(string name, int value)> CsEnumValues { get; }
    public List<(string name, int value)> EnumValues => CsEnumValues.Count != 0 ? CsEnumValues : DbEnumValues;
    public bool DeclaredInClass { get; }
}

public class RelationProperty : PropertyDefinition
{
    public RelationPart RelationPart { get; set; }
    public string RelationName { get; set; }

    public RelationProperty(string propertyName, CsTypeDeclaration csType, ModelDefinition model, IEnumerable<Attribute> attributes) : base(propertyName, csType, model, attributes)
    {
        Type = PropertyType.Relation;
    }
}

================
File: src/DataLinq.Core/Metadata/RelationDefinition.cs
================
namespace DataLinq.Metadata;

public enum RelationType
{
    OneToMany
}

public class RelationDefinition
{
    public RelationPart ForeignKey { get; set; }
    public RelationPart CandidateKey { get; set; }
    public RelationType Type { get; set; }
    public string ConstraintName { get; set; }

    public override string ToString()
    {
        return $"{ConstraintName}: {ForeignKey} -> {CandidateKey}";
    }
}

================
File: src/DataLinq.Core/Metadata/RelationPart.cs
================
namespace DataLinq.Metadata;

public enum RelationPartType
{
    ForeignKey,
    CandidateKey
}

public class RelationPart
{
    public ColumnIndex ColumnIndex { get; set; }
    public RelationDefinition Relation { get; set; }
    public RelationPartType Type { get; set; }
    public string CsName { get; set; }

    public RelationPart GetOtherSide() => Type == RelationPartType.CandidateKey
        ? Relation.ForeignKey
        : Relation.CandidateKey;

    public override string ToString()
    {
        return $"{Type}: {ColumnIndex}";
    }
}

================
File: src/DataLinq.Core/Metadata/TableDefinition.cs
================
using System.Collections.Generic;
using System.Linq;
using DataLinq.Attributes;
using DataLinq.Interfaces;

namespace DataLinq.Metadata;

public enum TableType
{
    Table,
    View
}

public class TableDefinition(string dbName) : IDefinition
{
    public string DbName { get; private set; } = dbName;
    public void SetDbName(string dbName) => DbName = dbName;
    public TableModel TableModel { get; private set; }
    internal void SetTableModel(TableModel tableModel) => TableModel = tableModel;
    public DatabaseDefinition Database => TableModel.Database;
    public ModelDefinition Model => TableModel.Model;
    public ColumnDefinition[] Columns { get; private set; } = [];
    public void SetColumns(IEnumerable<ColumnDefinition> columns) => Columns = columns.ToArray();

    public ColumnDefinition[] PrimaryKeyColumns { get; private set; } = [];
    public List<ColumnIndex> ColumnIndices { get; private set; } = [];

    public TableType Type { get; protected set; } = TableType.Table;
    public List<(CacheLimitType limitType, long amount)> CacheLimits { get; } = [];
    public List<(IndexCacheType indexCacheType, int? amount)> IndexCache { get; } = [];
    public CsFileDeclaration? CsFile => Model?.CsFile;

    internal bool? explicitUseCache;
    public bool UseCache
    {
        get => explicitUseCache ?? Database.UseCache;
        set => explicitUseCache = value;
    }


    public void AddPrimaryKeyColumn(ColumnDefinition column)
    {
        if (PrimaryKeyColumns == null)
            PrimaryKeyColumns = [column];
        else
            PrimaryKeyColumns = PrimaryKeyColumns.Concat(new[] { column }).ToArray();
    }

    public void RemovePrimaryKeyColumn(ColumnDefinition column)
    {
        if (PrimaryKeyColumns == null)
            return;

        PrimaryKeyColumns = PrimaryKeyColumns.Where(x => x != column).ToArray();
    }


    public override string ToString()
    {
        var desc = $"Table: {DbName}";

        if (Model?.CsType.Name != DbName)
            desc += $" ({Model?.CsType.Name})";

        return desc;
    }
}

public class ViewDefinition : TableDefinition
{
    public string? Definition { get; private set; }
    public void SetDefinition(string definition) => Definition = definition;

    public ViewDefinition(string dbName) : base(dbName)
    {
        Type = TableType.View;
    }
}

================
File: src/DataLinq.Core/Metadata/TableModel.cs
================
using DataLinq.Core.Factories;

namespace DataLinq.Metadata;

public class TableModel
{
    public string CsPropertyName { get; private set; }
    public DatabaseDefinition Database { get; }
    public TableDefinition Table { get; }
    public ModelDefinition Model { get; }
    public bool IsStub { get; }

    public TableModel(string csPropertyName, DatabaseDefinition database, TableDefinition table, string csName)
    {
        CsPropertyName = csPropertyName;
        Database = database;
        Table = table;
        Model = new ModelDefinition(new CsTypeDeclaration(csName, database.CsType.Namespace, ModelCsType.Class));
        IsStub = false;

        Table.SetTableModel(this);
        Model.SetTableModel(this);
    }

    public TableModel(string csPropertyName, DatabaseDefinition database, ModelDefinition model, bool isStub = false)
    {
        CsPropertyName = csPropertyName;
        Database = database;
        Model = model;
        Table = MetadataFactory.ParseTable(model);
        IsStub = isStub;

        Table.SetTableModel(this);
        Model.SetTableModel(this);
    }

    public void SetCsPropertyName(string csPropertyName) => CsPropertyName = csPropertyName;

    public override string ToString()
    {
        return $"{Table}, {Model}";
    }
}

================
File: src/DataLinq.Core/Types/DatabaseType.cs
================
namespace DataLinq;

/// <summary>
/// Enumeration of database types.
/// </summary>
public enum DatabaseType
{
    /// <summary>
    /// Default database type.
    /// </summary>
    Default,
    /// <summary>
    /// MySQL database type.
    /// </summary>
    MySQL,
    /// <summary>
    /// SQLite database type.
    /// </summary>
    SQLite
}

================
File: src/DataLinq.Generators.Tests/Extensions/Helpers/LinqExtensions.cs
================
using System;
using System.Collections.Generic;

namespace DataLinq.Extensions.Helpers;

internal static class LinqExtensions
{
    internal static string ToJoinedString<T>(this IEnumerable<T> source, string separator = "\n") =>
        string.Join(separator, source);

    //https://stackoverflow.com/a/11463800
    internal static IEnumerable<List<T>> SplitList<T>(this List<T> locations, int nSize = 30)
    {
        for (int i = 0; i < locations.Count; i += nSize)
        {
            yield return locations.GetRange(i, Math.Min(nSize, locations.Count - i));
        }
    }

    internal static IEnumerable<T> Yield<T>(this T item)
    {
#pragma warning disable RCS1165 // Unconstrained type parameter checked for null.
        if (item != null)
#pragma warning restore RCS1165 // Unconstrained type parameter checked for null.
            yield return item;
    }
}

================
File: src/DataLinq.Generators.Tests/Extensions/Helpers/QueryExtensions.cs
================
using DataLinq.Query;

namespace DataLinq.Extensions.Helpers;

internal static class QueryExtensions
{
    internal static string ToSql(this Relation relation)
    {
        switch (relation)
        {
            case Relation.Equal:
                return "=";

            case Relation.EqualNull:
                return "IS";

            case Relation.NotEqual:
                return "<>";

            case Relation.NotEqualNull:
                return "IS NOT";

            case Relation.Like:
                return "LIKE";

            case Relation.GreaterThan:
                return ">";

            case Relation.GreaterThanOrEqual:
                return ">=";

            case Relation.LessThan:
                return "<";

            case Relation.LessThanOrEqual:
                return "<=";

            case Relation.In:
                return "IN";

            case Relation.NotIn:
                return "NOT IN";
        }

        return null;
    }
}

================
File: src/DataLinq.Generators.Tests/Extensions/Helpers/StringExtensions.cs
================
using System;

namespace DataLinq.Extensions.Helpers;

internal static class StringExtensions
{
    //https://stackoverflow.com/a/4405876
    internal static string FirstCharToUpper(this string input) =>
        input switch
        {
            null => throw new ArgumentNullException(nameof(input)),
            "" => throw new ArgumentException($"{nameof(input)} cannot be empty", nameof(input)),
            _ => string.Concat(input[0].ToString().ToUpper(), input.Substring(1))
        };
}

================
File: src/DataLinq.Generators.Tests/SourceGeneratorTests.cs
================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using DataLinq.Extensions.Helpers;
using DataLinq.SourceGenerators;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using Xunit;

namespace DataLinq.Tests;

public class SourceGeneratorTests
{
    private string SyntaxTreesToString(IEnumerable<SyntaxTree> syntaxTrees)
    {
        return syntaxTrees.Select(x => x.ToString()).ToJoinedString();
    }

    private IEnumerable<SyntaxTree> GenerateCodeFromFolder(string[] dirs, bool includeSubfolders)
    {
        var projectRoot = Directory.GetParent(Environment.CurrentDirectory).Parent.Parent.Parent;

        var sources = dirs
            .SelectMany(x => Directory.EnumerateFiles(Path.Combine(projectRoot.FullName, x), "*.cs", enumerationOptions: new EnumerationOptions() { RecurseSubdirectories = includeSubfolders }))
            .Select(x => File.ReadAllText(x));

        return GenerateCode(sources);
    }

    private IEnumerable<SyntaxTree> GenerateCode(params string[] sources)
    {
        return GenerateCode(sources.Select(x => CSharpSyntaxTree.ParseText(SourceText.From(x))));
    }

    private IEnumerable<SyntaxTree> GenerateCode(IEnumerable<string> sources)
    {
        return GenerateCode(sources.Select(x => CSharpSyntaxTree.ParseText(SourceText.From(x))));
    }

    private IEnumerable<SyntaxTree> GenerateCode(IEnumerable<SyntaxTree> syntaxTrees)
    {
        // Set up compilation
        var compilation = CSharpCompilation.Create("TestAssembly",
            syntaxTrees,
            new[]
            {
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(Enumerable).Assembly.Location),
            },
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        // Create the generator driver
        var generator = new ModelGenerator();
        ModelGeneratorHoist host = new(generator);

        var driver = CSharpGeneratorDriver.Create(host);

        // Run the generator
        driver.RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out var diagnostics);

        if (diagnostics.Where(x => x.Severity == DiagnosticSeverity.Error).Any())
        {
            Assert.Fail(string.Join('\n', diagnostics.Select(d => d.ToString())));
        }

        return outputCompilation.SyntaxTrees;
    }

    //[Fact]
    //public void TestBasics()
    //{
    //    // The source code to be used as input for the generator
    //    var inputCode = @"
    //    namespace TestNamespace;

    //    public abstract partial class TestModel(RowData rowData, DataSourceAccess dataSource) : Immutable<TestModel>(rowData, dataSource), ITableModel<TestDb>
    //    {
    //        [PrimaryKey]
    //        [Column(""Name"")]
    //        public string Name { get; set; }
    //    }";

    //    var inputDbCode = @"
    //    using System;
    //    using DataLinq;
    //    using DataLinq.Interfaces;
    //    using DataLinq.Attributes;

    //    namespace DataLinq.Tests.Models;


    //    [Database(""testdb"")]
    //    public partial class TestDb(DataSourceAccess dataSource) : IDatabaseModel
    //    {
    //        DbRead<ITestModel> TestModels { get; }
    //    }";

    //    // Create the syntax tree from the source code
    //    //var syntaxTree = CSharpSyntaxTree.ParseText(SourceText.From(inputCode));


    //    var generatedCode = SyntaxTreesToString(GenerateCode(inputDbCode, inputCode));

    //    //var generatedCode = generatedTree.ToString();

    //    // Check that the generated code contains the expected proxy class
    //    Assert.Contains("public partial class ImmutableTestModel", generatedCode);
    //    Assert.Contains("public partial class TestDb", generatedCode);
    //}


    [Fact]
    public void TestEmployees()
    {
        var syntax = GenerateCodeFromFolder(["DataLinq.Tests.Models\\employees\\gen"], true);
        var code = SyntaxTreesToString(syntax);

        Assert.Contains("public partial class ImmutableEmployee", code);
    }

    [Fact]
    public void TestEmployeesOnlyDb()
    {
        var syntax = GenerateCodeFromFolder(["DataLinq.Tests.Models\\employees\\gen"], false);
        var code = SyntaxTreesToString(syntax);

        Assert.Contains("public partial class EmployeesDb", code);
    }

    [Fact]
    public void TestAllround()
    {
        var syntax = GenerateCodeFromFolder(["DataLinq.Tests.Models\\Allround"], true);
        var code = SyntaxTreesToString(syntax);

        Assert.Contains("public partial class AllroundBenchmark", code);
        Assert.Contains("public partial class MutablePayment", code);
    }

    [Fact]
    public void TestAllroundOnlyDb()
    {
        var syntax = GenerateCodeFromFolder(["DataLinq.Tests.Models\\Allround"], false);
        var code = SyntaxTreesToString(syntax);

        Assert.Contains("public partial class AllroundBenchmark", code);
    }

    [Fact]
    public void TestAllModels()
    {
        var syntax = GenerateCodeFromFolder(["DataLinq.Tests.Models\\employees\\gen", "DataLinq.Tests.Models\\Allround"], true);
        var code = SyntaxTreesToString(syntax);

        Assert.Contains("public partial class AllroundBenchmark", code);
        Assert.Contains("public partial class EmployeesDb", code);
        Assert.Contains("public partial class ImmutablePayment", code);
        Assert.Contains("public partial class MutableEmployee", code);
    }
}

================
File: src/DataLinq.Generators/ModelGenerator.cs
================
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Runtime.CompilerServices;
using DataLinq.Core.Factories;
using DataLinq.Core.Factories.Models;
using DataLinq.ErrorHandling;
using DataLinq.Metadata;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SGF;
using ThrowAway;

[assembly: InternalsVisibleTo("DataLinq.Generators.Tests")]

namespace DataLinq.SourceGenerators;

[IncrementalGenerator]
public class ModelGenerator() : IncrementalGenerator("DataLinqSourceGenerator")
{
    private readonly MetadataFromModelsFactory metadataFactory = new(new MetadataFromInterfacesFactoryOptions());
    private readonly GeneratorFileFactory fileFactory = new(new GeneratorFileFactoryOptions());

    public override void OnInitialize(SgfInitializationContext context)
    {
        // Create a provider for model declarations
        IncrementalValuesProvider<TypeDeclarationSyntax> modelDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsModelDeclaration(s),
                transform: static (ctx, _) => GetModelDeclaration(ctx))
            .Where(static m => m is not null)!;

        // Combine the compilation and model declarations
        IncrementalValueProvider<(Compilation, ImmutableArray<TypeDeclarationSyntax>)> compilationAndClasses = context.CompilationProvider
            .Combine(modelDeclarations.Collect());

        // Cache the metadata
        //IncrementalValuesProvider<DatabaseDefinition> cachedMetadata = compilationAndClasses.SelectMany((source, _) =>
        //    metadataFactory.ReadSyntaxTrees(source.Item2));

        IncrementalValuesProvider<Option<DatabaseDefinition, IDLOptionFailure>> cachedMetadata = compilationAndClasses.SelectMany((source, _) =>
        {
            try
            {
                return metadataFactory.ReadSyntaxTrees(source.Item2);

                //if (Option.CatchAll<List<Option<DatabaseDefinition, IDataLinqOptionFailure>>>(() => metadataFactory.ReadSyntaxTrees(source.Item2))
                //    .TryUnwrap(out var value, out var failure))
                //    return value;
                //else
                //    return [failure];
            }
            catch (Exception e)
            {
                return [DLOptionFailure.Fail(e)];
            }
        });


        // Check if nullable reference types are enabled and set the option
        context.RegisterSourceOutput(context.CompilationProvider, (spc, compilation) =>
        {
            fileFactory.Options.UseNullableReferenceTypes = IsNullableEnabled(compilation);
        });

        // Generate source files based on the cached metadata
        context.RegisterSourceOutput(cachedMetadata, (spc, metadata) =>
        {
            if (spc.CancellationToken.IsCancellationRequested)
                return;

            ExecuteForDatabase(metadata, spc);
        });
    }

    private static bool IsModelDeclaration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration &&
               classDeclaration.BaseList?.Types.Any(t => SyntaxParser.IsModelInterface(t.ToString())) == true;
    }


    private static TypeDeclarationSyntax GetModelDeclaration(GeneratorSyntaxContext context) =>
        (TypeDeclarationSyntax)context.Node;

    private void ExecuteForDatabase(Option<DatabaseDefinition, IDLOptionFailure> db, SgfSourceProductionContext context)
    {
        if (db.HasFailed)
        {
            // Create more detailed diagnostics with error location if available
            var failure = db.Failure;
            var location = Location.None;
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "DLG001",
                    "Database Metadata Generation Failed",
                    $"{failure.Value}",
                    "DataLinq.Generators",
                    DiagnosticSeverity.Error,
                    true),
                location));
            return;
        }

        try
        {
            foreach (var (path, contents) in fileFactory.CreateModelFiles(db.Value))
            {
                context.AddSource($"{db.Value.Name}/{path}", contents);
            }
        }
        catch (Exception e)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "DLG002",
                    "Model File Generation Failed",
                    $"{e.Message}\n{e.StackTrace}",
                    "DataLinq.Generators",
                    DiagnosticSeverity.Error,
                    true),
                Location.None));
        }
    }

    private static bool IsNullableEnabled(Compilation compilation)
    {
        return compilation.Options.NullableContextOptions switch
        {
            NullableContextOptions.Enable => true,
            NullableContextOptions.Warnings => true,
            NullableContextOptions.Annotations => true,
            _ => false,
        };
    }

    private void LogInfo(SgfSourceProductionContext context, string message)
    {
#if DEBUG
        context.ReportDiagnostic(Diagnostic.Create(
            new DiagnosticDescriptor(
                "DLG999",
                "Info",
                message,
                "DataLinq.Generators",
                DiagnosticSeverity.Info,
                true),
            Location.None));
#endif
    }

}

================
File: src/DataLinq.MySql/Extensions/Helpers/LinqExtensions.cs
================
using System;
using System.Collections.Generic;

namespace DataLinq.Extensions.Helpers;

internal static class LinqExtensions
{
    internal static string ToJoinedString<T>(this IEnumerable<T> source, string separator = "\n") =>
        string.Join(separator, source);

    //https://stackoverflow.com/a/11463800
    internal static IEnumerable<List<T>> SplitList<T>(this List<T> locations, int nSize = 30)
    {
        for (int i = 0; i < locations.Count; i += nSize)
        {
            yield return locations.GetRange(i, Math.Min(nSize, locations.Count - i));
        }
    }

    internal static IEnumerable<T> Yield<T>(this T item)
    {
#pragma warning disable RCS1165 // Unconstrained type parameter checked for null.
        if (item != null)
#pragma warning restore RCS1165 // Unconstrained type parameter checked for null.
            yield return item;
    }
}

================
File: src/DataLinq.MySql/Extensions/Helpers/QueryExtensions.cs
================
using System;
using DataLinq.Query;

namespace DataLinq.Extensions.Helpers;

internal static class QueryExtensions
{
    internal static string ToSql(this Relation relation) => relation switch
    {
        Relation.Equal => "=",
        Relation.EqualNull => "IS",
        Relation.NotEqual => "<>",
        Relation.NotEqualNull => "IS NOT",
        Relation.Like => "LIKE",
        Relation.GreaterThan => ">",
        Relation.GreaterThanOrEqual => ">=",
        Relation.LessThan => "<",
        Relation.LessThanOrEqual => "<=",
        Relation.In => "IN",
        Relation.NotIn => "NOT IN",
        _ => throw new NotImplementedException($"Relation {relation} is not supported"),
    };
}

================
File: src/DataLinq.MySql/Extensions/Helpers/StringExtensions.cs
================
using System;

namespace DataLinq.Extensions.Helpers;

internal static class StringExtensions
{
    //https://stackoverflow.com/a/4405876
    internal static string FirstCharToUpper(this string input) =>
        input switch
        {
            null => throw new ArgumentNullException(nameof(input)),
            "" => throw new ArgumentException($"{nameof(input)} cannot be empty", nameof(input)),
            _ => string.Concat(input[0].ToString().ToUpper(), input.Substring(1))
        };
}

================
File: src/DataLinq.MySql/MetadataFromMySqlFactory.cs
================
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Data.Common;
using System.Globalization;
using System.Linq;
using DataLinq.Attributes;
using DataLinq.Core.Factories;
using DataLinq.Extensions.Helpers;
using DataLinq.Metadata;
using DataLinq.MySql.Models;
using ThrowAway;

namespace DataLinq.MySql;

public class MetadataFromMySqlFactoryCreator : IMetadataFromDatabaseFactoryCreator
{
    public IMetadataFromSqlFactory GetMetadataFromSqlFactory(MetadataFromDatabaseFactoryOptions options)
    {
        return new MetadataFromMySqlFactory(options);
    }
}

public class MetadataFromMySqlFactory : IMetadataFromSqlFactory
{
    private readonly MetadataFromDatabaseFactoryOptions options;

    public MetadataFromMySqlFactory(MetadataFromDatabaseFactoryOptions options)
    {
        this.options = options;
    }

    public Option<DatabaseDefinition> ParseDatabase(string name, string csTypeName, string csNamespace, string dbName, string connectionString)
    {
        var information_Schema = new MySqlDatabase<information_schema>(connectionString, "information_schema").Query();
        var database = new DatabaseDefinition(name, new CsTypeDeclaration(csTypeName, csNamespace, ModelCsType.Class), dbName);

        database.SetTableModels(information_Schema
            .TABLES.Where(x => x.TABLE_SCHEMA == dbName)
            .AsEnumerable()
            .Select(x => ParseTable(database, information_Schema, x))
            .Where(IsTableOrViewInOptionsList));

        var missingTables = FindMissingTablesOrViewInOptionsList(database.TableModels).ToList();
        if (missingTables.Any())
            return $"Could not find the specified tables or views: {missingTables.ToJoinedString(", ")}";

        ParseIndices(database, information_Schema);
        ParseRelations(database, information_Schema);
        MetadataFactory.ParseIndices(database);
        MetadataFactory.ParseRelations(database);
        MetadataFactory.ParseInterfaces(database);

        return database;
    }

    private IEnumerable<string> FindMissingTablesOrViewInOptionsList(TableModel[] tableModels)
    {
        foreach (var tableName in options.Tables.Concat(options.Views))
        {
            if (!tableModels.Any(x => tableName.Equals(x.Table.DbName, StringComparison.OrdinalIgnoreCase)))
                yield return tableName;
        }
    }

    private bool IsTableOrViewInOptionsList(TableModel tableModel)
    {
        if (tableModel.Table.Type == TableType.View && options.Views.Any() && !options.Views.Any(x => x.Equals(tableModel.Table.DbName, StringComparison.OrdinalIgnoreCase)))
            return false;

        if (tableModel.Table.Type == TableType.Table && options.Tables.Any() && !options.Tables.Any(x => x.Equals(tableModel.Table.DbName, StringComparison.OrdinalIgnoreCase)))
            return false;

        return true;
    }

    private void ParseIndices(DatabaseDefinition database, information_schema information_Schema)
    {
        // Fetch table-column pairs that are part of a foreign key relationship
        var foreignKeyColumns = information_Schema.KEY_COLUMN_USAGE
            .Where(x => x.TABLE_SCHEMA == database.DbName && x.REFERENCED_TABLE_NAME != null)
            .Select(x => new { x.TABLE_NAME, x.COLUMN_NAME })
            .ToList();

        var indexGroups = information_Schema
            .STATISTICS.Where(x => x.TABLE_SCHEMA == database.DbName && x.INDEX_NAME != "PRIMARY")
            .ToList()
            .Where(x => !foreignKeyColumns.Any(fk => fk.TABLE_NAME == x.TABLE_NAME && fk.COLUMN_NAME == x.COLUMN_NAME))
            .GroupBy(x => x.INDEX_NAME);

        foreach (var dbIndexGroup in indexGroups)
        {
            var indexedColumns = dbIndexGroup.OrderBy(x => x.SEQ_IN_INDEX).ToList();
            var columnNames = indexedColumns.Select(x => x.COLUMN_NAME).ToArray();

            // Determine the type and characteristic of the index.
            var indexType = dbIndexGroup.First().INDEX_TYPE.ToUpper() switch
            {
                "BTREE" => IndexType.BTREE,
                "FULLTEXT" => IndexType.FULLTEXT,
                "HASH" => IndexType.HASH,
                "RTREE" => IndexType.RTREE,
                _ => throw new NotImplementedException($"Unknown index type '{dbIndexGroup.First().INDEX_TYPE.ToUpper()}'"),
            };

            var indexCharacteristic = dbIndexGroup.First().NON_UNIQUE == 0
                ? IndexCharacteristic.Unique
                : IndexCharacteristic.Simple;

            foreach (var indexColumn in indexedColumns)
            {
                var column = database
                    .TableModels.SingleOrDefault(x => x.Table.DbName == indexColumn.TABLE_NAME)?
                    .Table.Columns.SingleOrDefault(x => x.DbName == indexColumn.COLUMN_NAME);

                column?.ValueProperty.AddAttribute(new IndexAttribute(dbIndexGroup.First().INDEX_NAME, indexCharacteristic, indexType, columnNames));
            }
        }
    }

    private void ParseRelations(DatabaseDefinition database, information_schema information_Schema)
    {
        foreach (var key in information_Schema
            .KEY_COLUMN_USAGE.Where(x => x.TABLE_SCHEMA == database.DbName && x.REFERENCED_COLUMN_NAME != null))
        {
            var foreignKeyColumn = database
                .TableModels.SingleOrDefault(x => x.Table.DbName == key.TABLE_NAME)?
                .Table.Columns.SingleOrDefault(x => x.DbName == key.COLUMN_NAME);

            if (foreignKeyColumn == null || key.REFERENCED_TABLE_NAME == null || key.REFERENCED_COLUMN_NAME == null)
                continue;

            foreignKeyColumn.SetForeignKey();
            foreignKeyColumn.ValueProperty.AddAttribute(new ForeignKeyAttribute(key.REFERENCED_TABLE_NAME, key.REFERENCED_COLUMN_NAME, key.CONSTRAINT_NAME));

            var referencedColumn = database
                .TableModels.SingleOrDefault(x => x.Table.DbName == key.REFERENCED_TABLE_NAME)?
                .Table.Columns.SingleOrDefault(x => x.DbName == key.REFERENCED_COLUMN_NAME);

            if (referencedColumn != null)
            {
                MetadataFactory.AddRelationProperty(referencedColumn, foreignKeyColumn, key.CONSTRAINT_NAME);
                MetadataFactory.AddRelationProperty(foreignKeyColumn, referencedColumn, key.CONSTRAINT_NAME);
            }
        }
    }

    

    private TableModel ParseTable(DatabaseDefinition database, information_schema information_Schema, TABLES dbTables)
    {
        var type = dbTables.TABLE_TYPE == "BASE TABLE" ? TableType.Table : TableType.View;

        if (dbTables.TABLE_NAME == null)
            throw new Exception("Table name is null");

        var table = type == TableType.Table
            ? new TableDefinition(dbTables.TABLE_NAME)
            : new ViewDefinition(dbTables.TABLE_NAME);

        var csName = options.CapitaliseNames
            ? table.DbName.FirstCharToUpper()
            : table.DbName;

        var tableModel = new TableModel(csName, database, table, csName);

        if (table is ViewDefinition view)
        {
            view.SetDefinition(information_Schema
                .VIEWS.Where(x => x.TABLE_SCHEMA == database.DbName && x.TABLE_NAME == view.DbName)
                .AsEnumerable()
                .Select(x => x.VIEW_DEFINITION)
                .FirstOrDefault()?
                .Replace($"`{database.DbName}`.", "") ?? "");
        }

        table.SetColumns(information_Schema
            .COLUMNS.Where(x => x.TABLE_SCHEMA == database.DbName && x.TABLE_NAME == table.DbName)
            .AsEnumerable()
            .Select(x => ParseColumn(table, x)));

        return tableModel;
    }

    private ColumnDefinition ParseColumn(TableDefinition table, COLUMNS dbColumns)
    {
        var dbType = new DatabaseColumnType(DatabaseType.MySQL, dbColumns.DATA_TYPE);

        if (dbColumns.COLUMN_TYPE.Contains("unsigned"))
            dbType.SetSigned(false);
       
        if (dbType.Name == "decimal" || dbType.Name == "bit")
        {
            dbType.SetLength(dbColumns.NUMERIC_PRECISION);
            dbType.SetDecimals(dbColumns.NUMERIC_SCALE);
        }
        else if (dbType.Name == "int" || dbType.Name == "tinyint" || dbType.Name == "smallint" || dbType.Name == "mediumint" || dbType.Name == "bigint")
        {
            // Parse length from COLUMN_TYPE string
            var length = ParseLengthFromColumnType(dbColumns.COLUMN_TYPE);
            dbType.SetLength(length);
        }
        else if (dbType.Name != "enum")
        {
            dbType.SetLength(dbColumns.CHARACTER_MAXIMUM_LENGTH);
        }

        var column = new ColumnDefinition(dbColumns.COLUMN_NAME, table);
        

        column.SetNullable(dbColumns.IS_NULLABLE == "YES");
        column.SetPrimaryKey(dbColumns.COLUMN_KEY == "PRI");
        column.SetAutoIncrement(dbColumns.EXTRA.Contains("auto_increment"));
        column.AddDbType(dbType);

        var csType = ParseCsType(dbType.Name);
        var valueProp = MetadataFactory.AttachValueProperty(column, csType, options.CapitaliseNames);

        if (csType == "enum")
        {
            MetadataFactory.AttachEnumProperty(valueProp, new List<(string name, int value)>(), ParseEnumType(dbColumns.COLUMN_TYPE), true);
            if (valueProp.CsType.Name == "enum")
                valueProp.SetCsType(valueProp.CsType.MutateName(valueProp.PropertyName + "Value"));
            //valueProp.CsTypeName = valueProp.CsTypeName == "enum" ? valueProp.PropertyName + "Value" : valueProp.CsTypeName;
        }

        var defaultAttr = ParseDefaultValue(dbColumns, valueProp);
        if (defaultAttr != null)
            valueProp.AddAttribute(defaultAttr);

        return column;
    }

    private static DefaultAttribute? ParseDefaultValue(COLUMNS dbColumns, ValueProperty property)
    {
        if (dbColumns.COLUMN_DEFAULT != null && !string.Equals(dbColumns.COLUMN_DEFAULT, "NULL", StringComparison.CurrentCultureIgnoreCase))
        {
            if (dbColumns.COLUMN_DEFAULT.StartsWith("CURRENT_TIMESTAMP", StringComparison.CurrentCultureIgnoreCase))
                return new DefaultCurrentTimestampAttribute();

            if (property.CsType.Type == typeof(bool) && dbColumns.COLUMN_DEFAULT.StartsWith("b'"))
                return new DefaultAttribute(dbColumns.COLUMN_DEFAULT == "b'1'");

            var value = property.CsType.Type != null ?
                    Convert.ChangeType(dbColumns.COLUMN_DEFAULT, property.CsType.Type, CultureInfo.InvariantCulture)
                    : dbColumns.COLUMN_DEFAULT;

            return new DefaultAttribute(value);
        }

        return null;
    }

    private int? ParseLengthFromColumnType(string columnType)
    {
        var startIndex = columnType.IndexOf('(') + 1;
        var endIndex = columnType.IndexOf(')');
        if (startIndex > 0 && endIndex > startIndex)
        {
            var lengthStr = columnType.Substring(startIndex, endIndex - startIndex);
            if (int.TryParse(lengthStr, out var length))
            {
                return length;
            }
        }

        return null; // Default length if parsing fails
    }

    private IEnumerable<(string name, int value)> ParseEnumType(string COLUMN_TYPE) =>
        COLUMN_TYPE[5..^1]
        .Trim('\'')
        .Split("','")
        .Select((x, i) => (x, i + 1));

    private string ParseCsType(string dbType)
    {
        return dbType.ToLower() switch
        {
            "int" => "int",
            "tinyint" => "int",
            "mediumint" => "int",
            "varchar" => "string",
            "text" => "string",
            "mediumtext" => "string",
            "bit" => "bool",
            "double" => "double",
            "datetime" => "DateTime",
            "timestamp" => "DateTime",
            "year" => "int",
            "date" => "DateOnly",
            "time" => "TimeOnly",
            "float" => "float",
            "bigint" => "long",
            "char" => "string",
            "binary" => "Guid",
            "enum" => "enum",
            "longtext" => "string",
            "decimal" => "decimal",
            "blob" => "byte[]",
            "tinyblob" => "byte[]",
            "mediumblob" => "byte[]",
            "longblob" => "byte[]",
            "smallint" => "int",
            _ => throw new NotImplementedException($"Unknown type '{dbType}'"),
        };
    }
}

================
File: src/DataLinq.MySql/Models/information_schema/information_schema.cs
================
using System;
using DataLinq;
using DataLinq.Interfaces;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Mutation;

namespace DataLinq.MySql.Models;

[Database("information_schema")]
public partial class information_schema(DataSourceAccess dataSource) : IDatabaseModel
{
    public DbRead<COLUMNS> COLUMNS { get; } = new DbRead<COLUMNS>(dataSource);
    public DbRead<KEY_COLUMN_USAGE> KEY_COLUMN_USAGE { get; } = new DbRead<KEY_COLUMN_USAGE>(dataSource);
    public DbRead<STATISTICS> STATISTICS { get; } = new DbRead<STATISTICS>(dataSource);
    public DbRead<TABLES> TABLES { get; } = new DbRead<TABLES>(dataSource);
    public DbRead<VIEWS> VIEWS { get; } = new DbRead<VIEWS>(dataSource);
}

================
File: src/DataLinq.MySql/Models/information_schema/Views/COLUMNS.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.MySql.Models;

[Definition("")]
[View("COLUMNS")]
public abstract partial class COLUMNS(RowData rowData, DataSourceAccess dataSource) : Immutable<COLUMNS, information_schema>(rowData, dataSource), IViewModel<information_schema>
{
    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 21, false)]
    [Column("CHARACTER_MAXIMUM_LENGTH")]
    public abstract long? CHARACTER_MAXIMUM_LENGTH { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 21, false)]
    [Column("CHARACTER_OCTET_LENGTH")]
    public abstract long? CHARACTER_OCTET_LENGTH { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 32)]
    [Column("CHARACTER_SET_NAME")]
    public abstract string? CHARACTER_SET_NAME { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 32)]
    [Column("COLLATION_NAME")]
    public abstract string? COLLATION_NAME { get; }

    [Type(DatabaseType.MySQL, "varchar", 1024)]
    [Column("COLUMN_COMMENT")]
    public abstract string COLUMN_COMMENT { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "longtext", 4294967295)]
    [Column("COLUMN_DEFAULT")]
    public abstract string? COLUMN_DEFAULT { get; }

    [Type(DatabaseType.MySQL, "varchar", 3)]
    [Column("COLUMN_KEY")]
    public abstract string COLUMN_KEY { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("COLUMN_NAME")]
    public abstract string COLUMN_NAME { get; }

    [Type(DatabaseType.MySQL, "longtext", 4294967295)]
    [Column("COLUMN_TYPE")]
    public abstract string COLUMN_TYPE { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("DATA_TYPE")]
    public abstract string DATA_TYPE { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 21, false)]
    [Column("DATETIME_PRECISION")]
    public abstract long? DATETIME_PRECISION { get; }

    [Type(DatabaseType.MySQL, "varchar", 80)]
    [Column("EXTRA")]
    public abstract string EXTRA { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "longtext", 4294967295)]
    [Column("GENERATION_EXPRESSION")]
    public abstract string? GENERATION_EXPRESSION { get; }

    [Type(DatabaseType.MySQL, "varchar", 6)]
    [Column("IS_GENERATED")]
    public abstract string IS_GENERATED { get; }

    [Type(DatabaseType.MySQL, "varchar", 3)]
    [Column("IS_NULLABLE")]
    public abstract string IS_NULLABLE { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 21, false)]
    [Column("NUMERIC_PRECISION")]
    public abstract long? NUMERIC_PRECISION { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 21, false)]
    [Column("NUMERIC_SCALE")]
    public abstract long? NUMERIC_SCALE { get; }

    [Type(DatabaseType.MySQL, "bigint", 21, false)]
    [Column("ORDINAL_POSITION")]
    public abstract long ORDINAL_POSITION { get; }

    [Type(DatabaseType.MySQL, "varchar", 80)]
    [Column("PRIVILEGES")]
    public abstract string PRIVILEGES { get; }

    [Type(DatabaseType.MySQL, "varchar", 512)]
    [Column("TABLE_CATALOG")]
    public abstract string TABLE_CATALOG { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("TABLE_NAME")]
    public abstract string TABLE_NAME { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("TABLE_SCHEMA")]
    public abstract string TABLE_SCHEMA { get; }

}

================
File: src/DataLinq.MySql/Models/information_schema/Views/KEY_COLUMN_USAGE.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.MySql.Models;

[Definition("")]
[View("KEY_COLUMN_USAGE")]
public abstract partial class KEY_COLUMN_USAGE(RowData rowData, DataSourceAccess dataSource) : Immutable<KEY_COLUMN_USAGE, information_schema>(rowData, dataSource), IViewModel<information_schema>
{
    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("COLUMN_NAME")]
    public abstract string COLUMN_NAME { get; }

    [Type(DatabaseType.MySQL, "varchar", 512)]
    [Column("CONSTRAINT_CATALOG")]
    public abstract string CONSTRAINT_CATALOG { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("CONSTRAINT_NAME")]
    public abstract string CONSTRAINT_NAME { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("CONSTRAINT_SCHEMA")]
    public abstract string CONSTRAINT_SCHEMA { get; }

    [Type(DatabaseType.MySQL, "bigint", 10)]
    [Column("ORDINAL_POSITION")]
    public abstract long ORDINAL_POSITION { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 10)]
    [Column("POSITION_IN_UNIQUE_CONSTRAINT")]
    public abstract long? POSITION_IN_UNIQUE_CONSTRAINT { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("REFERENCED_COLUMN_NAME")]
    public abstract string? REFERENCED_COLUMN_NAME { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("REFERENCED_TABLE_NAME")]
    public abstract string? REFERENCED_TABLE_NAME { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("REFERENCED_TABLE_SCHEMA")]
    public abstract string? REFERENCED_TABLE_SCHEMA { get; }

    [Type(DatabaseType.MySQL, "varchar", 512)]
    [Column("TABLE_CATALOG")]
    public abstract string TABLE_CATALOG { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("TABLE_NAME")]
    public abstract string TABLE_NAME { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("TABLE_SCHEMA")]
    public abstract string TABLE_SCHEMA { get; }

}

================
File: src/DataLinq.MySql/Models/information_schema/Views/STATISTICS.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.MySql.Models;

[Definition("")]
[View("STATISTICS")]
public abstract partial class STATISTICS(RowData rowData, DataSourceAccess dataSource) : Immutable<STATISTICS, information_schema>(rowData, dataSource), IViewModel<information_schema>
{
    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 21)]
    [Column("CARDINALITY")]
    public abstract long? CARDINALITY { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 1)]
    [Column("COLLATION")]
    public abstract string? COLLATION { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("COLUMN_NAME")]
    public abstract string COLUMN_NAME { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 16)]
    [Column("COMMENT")]
    public abstract string? COMMENT { get; }

    [Type(DatabaseType.MySQL, "varchar", 1024)]
    [Column("INDEX_COMMENT")]
    public abstract string INDEX_COMMENT { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("INDEX_NAME")]
    public abstract string INDEX_NAME { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("INDEX_SCHEMA")]
    public abstract string INDEX_SCHEMA { get; }

    [Type(DatabaseType.MySQL, "varchar", 16)]
    [Column("INDEX_TYPE")]
    public abstract string INDEX_TYPE { get; }

    [Type(DatabaseType.MySQL, "bigint", 1)]
    [Column("NON_UNIQUE")]
    public abstract long NON_UNIQUE { get; }

    [Type(DatabaseType.MySQL, "varchar", 3)]
    [Column("NULLABLE")]
    public abstract string NULLABLE { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 10)]
    [Column("PACKED")]
    public abstract string? PACKED { get; }

    [Type(DatabaseType.MySQL, "bigint", 2)]
    [Column("SEQ_IN_INDEX")]
    public abstract long SEQ_IN_INDEX { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 3)]
    [Column("SUB_PART")]
    public abstract long? SUB_PART { get; }

    [Type(DatabaseType.MySQL, "varchar", 512)]
    [Column("TABLE_CATALOG")]
    public abstract string TABLE_CATALOG { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("TABLE_NAME")]
    public abstract string TABLE_NAME { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("TABLE_SCHEMA")]
    public abstract string TABLE_SCHEMA { get; }

}

================
File: src/DataLinq.MySql/Models/information_schema/Views/TABLES.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.MySql.Models;

[Definition("")]
[View("TABLES")]
public abstract partial class TABLES(RowData rowData, DataSourceAccess dataSource) : Immutable<TABLES, information_schema>(rowData, dataSource), IViewModel<information_schema>
{
    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 21, false)]
    [Column("AUTO_INCREMENT")]
    public abstract long? AUTO_INCREMENT { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 21, false)]
    [Column("AVG_ROW_LENGTH")]
    public abstract long? AVG_ROW_LENGTH { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "datetime")]
    [Column("CHECK_TIME")]
    public abstract DateTime? CHECK_TIME { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 21, false)]
    [Column("CHECKSUM")]
    public abstract long? CHECKSUM { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 2048)]
    [Column("CREATE_OPTIONS")]
    public abstract string? CREATE_OPTIONS { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "datetime")]
    [Column("CREATE_TIME")]
    public abstract DateTime? CREATE_TIME { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 21, false)]
    [Column("DATA_FREE")]
    public abstract long? DATA_FREE { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 21, false)]
    [Column("DATA_LENGTH")]
    public abstract long? DATA_LENGTH { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("ENGINE")]
    public abstract string? ENGINE { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 21, false)]
    [Column("INDEX_LENGTH")]
    public abstract long? INDEX_LENGTH { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 21, false)]
    [Column("MAX_DATA_LENGTH")]
    public abstract long? MAX_DATA_LENGTH { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 21, false)]
    [Column("MAX_INDEX_LENGTH")]
    public abstract long? MAX_INDEX_LENGTH { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 10)]
    [Column("ROW_FORMAT")]
    public abstract string? ROW_FORMAT { get; }

    [Type(DatabaseType.MySQL, "varchar", 512)]
    [Column("TABLE_CATALOG")]
    public abstract string TABLE_CATALOG { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 32)]
    [Column("TABLE_COLLATION")]
    public abstract string? TABLE_COLLATION { get; }

    [Type(DatabaseType.MySQL, "varchar", 2048)]
    [Column("TABLE_COMMENT")]
    public abstract string TABLE_COMMENT { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("TABLE_NAME")]
    public abstract string TABLE_NAME { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 21, false)]
    [Column("TABLE_ROWS")]
    public abstract long? TABLE_ROWS { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("TABLE_SCHEMA")]
    public abstract string TABLE_SCHEMA { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("TABLE_TYPE")]
    public abstract string TABLE_TYPE { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 1)]
    [Column("TEMPORARY")]
    public abstract string? TEMPORARY { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "datetime")]
    [Column("UPDATE_TIME")]
    public abstract DateTime? UPDATE_TIME { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "bigint", 21, false)]
    [Column("VERSION")]
    public abstract long? VERSION { get; }

}

================
File: src/DataLinq.MySql/Models/information_schema/Views/VIEWS.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.MySql.Models;

[Definition("")]
[View("VIEWS")]
public abstract partial class VIEWS(RowData rowData, DataSourceAccess dataSource) : Immutable<VIEWS, information_schema>(rowData, dataSource), IViewModel<information_schema>
{
    [Type(DatabaseType.MySQL, "varchar", 10)]
    [Column("ALGORITHM")]
    public abstract string ALGORITHM { get; }

    [Type(DatabaseType.MySQL, "varchar", 32)]
    [Column("CHARACTER_SET_CLIENT")]
    public abstract string CHARACTER_SET_CLIENT { get; }

    [Type(DatabaseType.MySQL, "varchar", 8)]
    [Column("CHECK_OPTION")]
    public abstract string CHECK_OPTION { get; }

    [Type(DatabaseType.MySQL, "varchar", 32)]
    [Column("COLLATION_CONNECTION")]
    public abstract string COLLATION_CONNECTION { get; }

    [Type(DatabaseType.MySQL, "varchar", 189)]
    [Column("DEFINER")]
    public abstract string DEFINER { get; }

    [Type(DatabaseType.MySQL, "varchar", 3)]
    [Column("IS_UPDATABLE")]
    public abstract string IS_UPDATABLE { get; }

    [Type(DatabaseType.MySQL, "varchar", 7)]
    [Column("SECURITY_TYPE")]
    public abstract string SECURITY_TYPE { get; }

    [Type(DatabaseType.MySQL, "varchar", 512)]
    [Column("TABLE_CATALOG")]
    public abstract string TABLE_CATALOG { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("TABLE_NAME")]
    public abstract string TABLE_NAME { get; }

    [Type(DatabaseType.MySQL, "varchar", 64)]
    [Column("TABLE_SCHEMA")]
    public abstract string TABLE_SCHEMA { get; }

    [Type(DatabaseType.MySQL, "longtext", 4294967295)]
    [Column("VIEW_DEFINITION")]
    public abstract string VIEW_DEFINITION { get; }

}

================
File: src/DataLinq.MySql/MySqlDatabase.cs
================
using DataLinq.Interfaces;
using DataLinq.Logging;
using DataLinq.Metadata;
using Microsoft.Extensions.Logging;

namespace DataLinq.MySql;

/// <summary>
/// Factory for creating instances of MySQL database providers.
/// </summary>
public class MySqlDatabaseCreator : IDatabaseProviderCreator
{
    private ILoggerFactory? loggerFactory;

    /// <summary>
    /// Determines if the provided type name corresponds to a MySQL or MariaDB database type.
    /// </summary>
    /// <param name="typeName">The name of the database type to check.</param>
    /// <returns>true if typeName is either 'mysql' or 'mariadb'; otherwise, false.</returns>
    public bool IsDatabaseType(string typeName)
    {
        return typeName.Equals("mysql", System.StringComparison.OrdinalIgnoreCase)
            || typeName.Equals("mariadb", System.StringComparison.OrdinalIgnoreCase);
    }

    /// <summary>
    /// Creates a new MySqlDatabase provider for the specified type of database model.
    /// </summary>
    /// <typeparam name="T">The type of the database model.</typeparam>
    /// <param name="connectionString">The connection string for the database.</param>
    /// <param name="databaseName">The name of the database.</param>
    /// <returns>An instance of MySqlDatabase for the specified model type.</returns>
    Database<T> IDatabaseProviderCreator.GetDatabaseProvider<T>(string connectionString, string databaseName)
    {
        return new MySqlDatabase<T>(connectionString, databaseName, loggerFactory);
    }

    public MySqlDatabaseCreator UseLoggerFactory(ILoggerFactory? loggerFactory)
    {
        this.loggerFactory = loggerFactory;
        return this;
    }

    IDatabaseProviderCreator IDatabaseProviderCreator.UseLoggerFactory(ILoggerFactory? loggerFactory) =>
        UseLoggerFactory(loggerFactory);
}

/// <summary>
/// Represents a MySQL database provider specific to a given database model type.
/// </summary>
/// <typeparam name="T">The type of the database model.</typeparam>
public class MySqlDatabase<T> : Database<T>
     where T : class, IDatabaseModel
{
    /// <summary>
    /// Initializes a new instance of the MySqlDatabase with the specified connection string.
    /// </summary>
    /// <param name="connectionString">The connection string for the MySQL database.</param>
    public MySqlDatabase(string connectionString) : base(new MySQLProvider<T>(connectionString))
    {
    }

    /// <summary>
    /// Initializes a new instance of the MySqlDatabase with the specified connection string and logger factory.
    /// </summary>
    /// <param name="connectionString">The connection string for the MySQL database.</param>
    /// <param name="loggerFactory">The logger factory to use for logging.</param>
    public MySqlDatabase(string connectionString, ILoggerFactory? loggerFactory) : base(new MySQLProvider<T>(connectionString, loggerFactory == null ? DataLinqLoggingConfiguration.NullConfiguration : new DataLinqLoggingConfiguration(loggerFactory)))
    {
    }

    /// <summary>
    /// Initializes a new instance of the MySqlDatabase with the specified connection string and database name.
    /// </summary>
    /// <param name="connectionString">The connection string for the MySQL database.</param>
    /// <param name="databaseName">The name of the database.</param>
    public MySqlDatabase(string connectionString, string databaseName) : base(new MySQLProvider<T>(connectionString, databaseName))
    {
    }

    /// <summary>
    /// Initializes a new instance of the MySqlDatabase with the specified connection string, database name and logger factory.
    /// </summary>
    /// <param name="connectionString">The connection string for the MySQL database.</param>
    /// <param name="databaseName">The name of the database.</param>
    /// /// <param name="loggerFactory">The logger factory to use for logging.</param>
    public MySqlDatabase(string connectionString, string databaseName, ILoggerFactory? loggerFactory) : base(new MySQLProvider<T>(connectionString, databaseName, loggerFactory == null ? DataLinqLoggingConfiguration.NullConfiguration : new DataLinqLoggingConfiguration(loggerFactory)))
    {
    }
}

================
File: src/DataLinq.MySql/MySqlDatabaseTransaction.cs
================
using System;
using System.Data;
using DataLinq.Logging;
using DataLinq.Mutation;
using MySqlConnector;

namespace DataLinq.MySql;

/// <summary>
/// Represents a transaction for a MySQL database, encapsulating the logic to execute commands with transactional support.
/// </summary>
public class MySqlDatabaseTransaction : DatabaseTransaction
{
    private IDbConnection? dbConnection;
    private readonly string databaseName;
    private readonly MySqlDataSource? dataSource;
    private readonly DataLinqLoggingConfiguration loggingConfiguration;

    /// <summary>
    /// Initializes a new instance of the MySqlDatabaseTransaction class with the specified connection string and transaction type.
    /// </summary>
    /// <param name="connectionString">The connection string to the MySQL database.</param>
    /// <param name="type">The type of transaction to be performed.</param>
    public MySqlDatabaseTransaction(MySqlDataSource dataSource, TransactionType type, string databaseName, DataLinqLoggingConfiguration loggingConfiguration) : base(type)
    {
        this.dataSource = dataSource;
        this.databaseName = databaseName;
        this.loggingConfiguration = loggingConfiguration;
    }

    /// <summary>
    /// Initializes a new instance of the MySqlDatabaseTransaction class with the specified database transaction and transaction type.
    /// Ensures that the provided transaction is valid and the connection is open.
    /// </summary>
    /// <param name="dbTransaction">The existing database transaction.</param>
    /// <param name="type">The type of transaction to be performed.</param>
    public MySqlDatabaseTransaction(IDbTransaction dbTransaction, TransactionType type, string databaseName, DataLinqLoggingConfiguration loggingConfiguration) : base(dbTransaction, type)
    {
        if (dbTransaction.Connection == null) throw new ArgumentNullException("dbTransaction.Connection", "The transaction connection is null");
        if (dbTransaction.Connection is not MySqlConnection) throw new ArgumentException("The transaction connection must be an MySqlConnection", "dbTransaction.Connection");
        if (dbTransaction.Connection.State != ConnectionState.Open) throw new Exception("The transaction connection is not open");

        SetStatus(DatabaseTransactionStatus.Open);
        dbConnection = dbTransaction.Connection;
        this.databaseName = databaseName;
        this.loggingConfiguration = loggingConfiguration;
    }

    /// <summary>
    /// Gets the underlying database connection for the transaction, ensuring it is open and valid.
    /// </summary>
    private IDbConnection DbConnection
    {
        get
        {
            if (Status == DatabaseTransactionStatus.Committed || Status == DatabaseTransactionStatus.RolledBack)
                throw new Exception("Cannot open a new connection on a committed or rolled back transaction.");

            if (Status == DatabaseTransactionStatus.Closed)
            {
                if (dataSource == null)
                    throw new Exception("The data source is null");

                SetStatus(DatabaseTransactionStatus.Open);
                dbConnection = dataSource.OpenConnection();
                DbTransaction = dbConnection.BeginTransaction(IsolationLevel.ReadCommitted);

                if (databaseName != null)
                    ExecuteNonQuery($"USE `{databaseName}`;");
            }

            if (dbConnection == null)
                throw new Exception("The database connection is null");

            return dbConnection;
        }
    }

    /// <summary>
    /// Executes a non-query SQL command within the context of the transaction.
    /// </summary>
    /// <param name="command">The command to execute.</param>
    /// <returns>The number of rows affected.</returns>
    public override int ExecuteNonQuery(IDbCommand command)
    {
        command.Connection = DbConnection;
        command.Transaction = DbTransaction;
        Log.SqlCommand(loggingConfiguration.SqlCommandLogger, command);
        return command.ExecuteNonQuery();
    }

    /// <summary>
    /// Executes a SQL command with a non-query statement such as INSERT, UPDATE, or DELETE.
    /// </summary>
    /// <param name="query">The SQL query string to execute.</param>
    /// <returns>The number of rows affected by the command.</returns>
    public override int ExecuteNonQuery(string query) =>
        ExecuteNonQuery(new MySqlCommand(query));

    /// <summary>
    /// Executes a SQL command that returns a single value, such as a COUNT or MAX.
    /// </summary>
    /// <param name="query">The SQL query string to execute.</param>
    /// <returns>The first column of the first row in the result set returned by the query.</returns>
    public override object? ExecuteScalar(string query) =>
        ExecuteScalar(new MySqlCommand(query));

    /// <summary>
    /// Executes a SQL command that returns a single value of type T.
    /// </summary>
    /// <typeparam name="T">The expected return type of the scalar result.</typeparam>
    /// <param name="query">The SQL query string to execute.</param>
    /// <returns>The result cast to the type T, or default(T) if the result is DBNull or null.</returns>
    public override T ExecuteScalar<T>(string query) =>
        ExecuteScalar<T>(new MySqlCommand(query));

    /// <summary>
    /// Executes a SQL command that returns a single value of type T, using the provided IDbCommand.
    /// </summary>
    /// <typeparam name="T">The expected return type of the scalar result.</typeparam>
    /// <param name="command">The IDbCommand to execute.</param>
    /// <returns>The result cast to the type T, or default(T) if the result is DBNull or null.</returns>
    public override T ExecuteScalar<T>(IDbCommand command) =>
        (T)(ExecuteScalar(command) ?? default(T)!);

    /// <summary>
    /// Executes a SQL command that returns a single value, using the provided IDbCommand.
    /// </summary>
    /// <param name="command">The IDbCommand to execute.</param>
    /// <returns>The first column of the first row in the result set returned by the command, or null if the result is DBNull.</returns>
    public override object? ExecuteScalar(IDbCommand command)
    {
        command.Connection = DbConnection;
        command.Transaction = DbTransaction;
        Log.SqlCommand(loggingConfiguration.SqlCommandLogger, command);
        var result = command.ExecuteScalar();
        return result == DBNull.Value ? null : result;
    }


    /// <summary>
    /// Executes a SQL command that returns a result set, such as a SELECT query.
    /// </summary>
    /// <param name="query">The SQL query string to execute.</param>
    /// <returns>An IDataLinqDataReader that can be used to read the returned data.</returns>
    public override IDataLinqDataReader ExecuteReader(string query)
    {
        return ExecuteReader(new MySqlCommand(query));
    }


    /// <summary>
    /// Close this reader when done! (or use a using-statement)
    /// </summary>
    /// <param name="command"></param>
    /// <returns></returns>
    public override IDataLinqDataReader ExecuteReader(IDbCommand command)
    {
        command.Connection = DbConnection;
        command.Transaction = DbTransaction;
        Log.SqlCommand(loggingConfiguration.SqlCommandLogger, command);

        return new MySqlDataLinqDataReader((command.ExecuteReader() as MySqlDataReader)!);
    }

    /// <summary>
    /// Commits the transaction, ensuring it is open before attempting to commit.
    /// </summary>
    public override void Commit()
    {
        if (Status == DatabaseTransactionStatus.Open)
        {
            if (DbTransaction?.Connection?.State == ConnectionState.Open)
                DbTransaction.Commit();
        }

        SetStatus(DatabaseTransactionStatus.Committed);
        Dispose();
    }

    /// <summary>
    /// Rolls back the transaction, ensuring it is open before attempting to roll back.
    /// </summary>
    public override void Rollback()
    {
        if (Status == DatabaseTransactionStatus.Open)
        {
            if (DbTransaction?.Connection?.State == ConnectionState.Open)
                DbTransaction.Rollback();
        }

        SetStatus(DatabaseTransactionStatus.RolledBack);
        Dispose();
    }

    /// <summary>
    /// Closes the transaction and the underlying connection if open.
    /// </summary>
    private void Close()
    {
        if (Status == DatabaseTransactionStatus.Open)
        {
            if (DbTransaction?.Connection?.State == ConnectionState.Open)
                DbTransaction.Rollback();

            SetStatus(DatabaseTransactionStatus.RolledBack);
        }

        dbConnection?.Close();
    }

    #region IDisposable Members

    /// <summary>
    /// Releases all resources used by the MySqlDatabaseTransaction, rolling back the transaction if it is still open.
    /// </summary>
    public override void Dispose()
    {
        Close();
        dbConnection?.Dispose();
        DbTransaction?.Dispose();
    }

    #endregion IDisposable Members
}

================
File: src/DataLinq.MySql/MySqlDataLinqDataReader.cs
================
using System;
using System.Buffers;
using System.Linq;
using DataLinq.Metadata;
using DataLinq.Utils;
using MySqlConnector;

namespace DataLinq.MySql;

public struct MySqlDataLinqDataReader : IDataLinqDataReader, IDisposable
{
    public MySqlDataLinqDataReader(MySqlDataReader dataReader)
    {
        this.dataReader = dataReader;
    }

    private readonly MySqlDataReader dataReader;

    public void Dispose()
    {
        dataReader.Dispose();
    }

    public bool IsDbNull(int ordinal)
    {
        return dataReader.IsDBNull(ordinal);
    }

    public string GetString(int ordinal)
    {
        return dataReader.GetString(ordinal);
    }

    public bool GetBoolean(int ordinal)
    {
        return dataReader.GetBoolean(ordinal);
    }

    public int GetInt32(int ordinal)
    {
        return dataReader.GetInt32(ordinal);
    }

    public DateOnly GetDateOnly(int ordinal)
    {
        return dataReader.GetDateOnly(ordinal);
    }

    public Guid GetGuid(int ordinal)
    {
        return dataReader.GetGuid(ordinal);
    }

    public int GetOrdinal(string name)
    {
        return dataReader.GetOrdinal(name);
    }

    public object GetValue(int ordinal)
    {
        return dataReader.GetValue(ordinal);
    }

    public long GetByteLength(int ordinal)
    {
        return dataReader.GetBytes(ordinal, 0, null, 0, 0);
    }

    public byte[]? GetBytes(int ordinal)
    {
        if (GetByteLength(ordinal) == 0)
            return null;

        var buffer = new byte[GetByteLength(ordinal)];
        if (GetBytes(ordinal, buffer) == 0)
            throw new Exception($"Unexpectedly read 0 bytes from column ordinal {ordinal}");

        return buffer;
    }

    public long GetBytes(int ordinal, Span<byte> buffer)
    {
        byte[] tempBuffer = ArrayPool<byte>.Shared.Rent(buffer.Length);

        try
        {
            long bytesRead = dataReader.GetBytes(ordinal, 0, tempBuffer, 0, buffer.Length);
            new ReadOnlySpan<byte>(tempBuffer, 0, (int)bytesRead).CopyTo(buffer);
            return bytesRead;
        }
        finally
        {
            ArrayPool<byte>.Shared.Return(tempBuffer);
        }
    }

    public bool ReadNextRow()
    {
        return dataReader.Read();
    }

    //public bool CanReadBytes(Type type)
    //{
    //    return type == typeof(byte[]) || type == typeof(byte?[]) ||
    //            type == typeof(Guid) || type == typeof(Guid?);
    //}

    //public void ReadPrimaryKeys(ReadOnlySpan<Column> primaryKeyColumns, Span<byte> buffer, Span<int> lengths)
    //{
    //    int bufferOffset = 0;

    //    for (int i = 0; i < primaryKeyColumns.Length; i++)
    //    {
    //        int bytesRead;
    //        if (CanReadBytes(primaryKeyColumns[i].ValueProperty.CsType))
    //        {
    //            bytesRead = (int)GetBytes(i, buffer.Slice(bufferOffset));
    //        }
    //        else
    //        {
    //            var span = DataReader.ConvertTypeToBytes(ReadColumn(primaryKeyColumns[i], i), primaryKeyColumns[i].ValueProperty);
    //            if (bufferOffset + span.Length > buffer.Length)
    //            {
    //                throw new ArgumentException("Buffer is too small to hold all the data.");
    //            }
    //            span.CopyTo(buffer.Slice(bufferOffset));
    //            bytesRead = span.Length;
    //        }

    //        lengths[i] = bufferOffset + bytesRead;
    //        bufferOffset += bytesRead;
    //    }
    //}

    public T? GetValue<T>(ColumnDefinition column)
    {
        return GetValue<T>(column, GetOrdinal(column.DbName));
    }

    public T? GetValue<T>(ColumnDefinition column, int ordinal)
    {
        if (IsDbNull(ordinal))
            return default;

        else if (column.ValueProperty.CsType.Type == typeof(Guid) || column.ValueProperty.CsType.Type == typeof(Guid?))
        {
            //var dbType = column.GetDbTypeFor(DatabaseType.MySQL); // column.DbTypes.FirstOrDefault(x => x.DatabaseType == DatabaseType.MySQL) ?? column.DbTypes.FirstOrDefault(); //SqlFromMetadataFactory.GetDbType(column);
            //if (value is byte[] bytes && column.GetDbTypeFor(DatabaseType.MySQL)?.Length == 16 && column.GetDbTypeFor(DatabaseType.MySQL)?.Name == "binary")
            //    return new Guid(bytes);

            return (T?)(object)GetGuid(ordinal);
        }
        else if (column.ValueProperty.CsType.Type == typeof(string))
            return (T?)(object)GetString(ordinal);
        else if (column.ValueProperty.CsType.Type == typeof(int) || column.ValueProperty.CsType.Type == typeof(int?))
            return (T?)(object)GetInt32(ordinal);
        else if (column.ValueProperty.CsType.Type == typeof(DateOnly) || column.ValueProperty.CsType.Type == typeof(DateOnly?))
            return (T?)(object)GetDateOnly(ordinal);
        else if (column.ValueProperty.CsType.Type?.IsEnum == true)
        {
            var enumValue = GetValue(ordinal);
            if (enumValue is string stringValue)
                return (T?)Enum.ToObject(column.ValueProperty.CsType.Type, column.ValueProperty.EnumProperty.Value.EnumValues.Single(x => x.name.Equals(stringValue, StringComparison.OrdinalIgnoreCase)).value);
            else
                return (T?)Enum.ToObject(column.ValueProperty.CsType.Type, enumValue);
        }

        var value = GetValue(ordinal);
        if (column.ValueProperty.CsNullable)
            return (T?)Convert.ChangeType(value, TypeUtils.GetNullableConversionType(column.ValueProperty.CsType.Type));
        else if (value.GetType() != column.ValueProperty.CsType.Type)
            return (T?)Convert.ChangeType(value, column.ValueProperty.CsType.Type);

        return (T?)value;
    }

    //public object? ReadColumn(Column column, int ordinal)
    //{
    //    //var ordinal = GetOrdinal(column.DbName);
    //    var value = GetValue(ordinal);

    //    if (value is DBNull)
    //        return null;
    //    else if (column.ValueProperty.CsType == typeof(Guid) || column.ValueProperty.CsType == typeof(Guid?))
    //    {
    //        //var dbType = column.GetDbTypeFor(DatabaseType.MySQL); // column.DbTypes.FirstOrDefault(x => x.DatabaseType == DatabaseType.MySQL) ?? column.DbTypes.FirstOrDefault(); //SqlFromMetadataFactory.GetDbType(column);
    //        if (value is byte[] bytes && column.GetDbTypeFor(DatabaseType.MySQL)?.Length == 16 && column.GetDbTypeFor(DatabaseType.MySQL)?.Name == "binary")
    //            return new Guid(bytes);
    //    }
    //    else if (column.ValueProperty.CsType == typeof(DateOnly))
    //        return GetDateOnly(GetOrdinal(column.DbName));
    //    else if (column.ValueProperty.CsType.IsEnum && value is string stringValue)
    //        return Enum.ToObject(column.ValueProperty.CsType, column.ValueProperty.EnumProperty.Value.EnumValues.Single(x => x.name.Equals(stringValue, StringComparison.OrdinalIgnoreCase)).value);
    //    else if (column.ValueProperty.CsType.IsEnum)
    //        return Enum.ToObject(column.ValueProperty.CsType, value);
    //    else if (column.ValueProperty.CsNullable)
    //        return Convert.ChangeType(value, TypeUtils.GetNullableConversionType(column.ValueProperty.CsType));
    //    else if (value.GetType() != column.ValueProperty.CsType)
    //        return Convert.ChangeType(value, column.ValueProperty.CsType);

    //    return value;
    //}
}

================
File: src/DataLinq.MySql/MySqlDataLinqDataWriter.cs
================
using System;
using DataLinq.Metadata;

namespace DataLinq.MySql;

/// <summary>
/// Represents a data writer for MySql database.
/// </summary>
public class MySqlDataLinqDataWriter : IDataLinqDataWriter
{
    /// <summary>
    /// Initializes a new instance of the <see cref="MySqlDataLinqDataWriter"/> class.
    /// </summary>
    public MySqlDataLinqDataWriter()
    {
    }

    /// <summary>
    /// Converts the specified value to the appropriate type for the specified column.
    /// </summary>
    /// <param name="column">The column metadata.</param>
    /// <param name="value">The value to convert.</param>
    /// <returns>The converted value.</returns>
    public object? ConvertValue(ColumnDefinition column, object? value)
    {
        if (value == null)
            return null;

        if (value is Guid guid)
        {
            var dbType = SqlFromMetadataFactory.GetDbType(column);

            if (dbType.Name == "binary" && dbType.Length == 16)
                return guid.ToByteArray();
        }

        return value;
    }
}

================
File: src/DataLinq.MySql/MySqlDbAccess.cs
================
using System.Data;
using DataLinq.Logging;
using MySqlConnector;

namespace DataLinq.MySql;

public class MySqlDbAccess : DatabaseAccess
{
    private readonly MySqlDataSource dataSource;
    private readonly DataLinqLoggingConfiguration loggingConfiguration;

    public MySqlDbAccess(MySqlDataSource dataSource, DataLinqLoggingConfiguration loggingConfiguration) : base()
    {
        this.dataSource = dataSource;
        this.loggingConfiguration = loggingConfiguration;
    }

    public override int ExecuteNonQuery(IDbCommand command)
    {
        using var connection = dataSource.OpenConnection();
        command.Connection = connection;

        Log.SqlCommand(loggingConfiguration.SqlCommandLogger, command);

        return command.ExecuteNonQuery();
    }

    public override int ExecuteNonQuery(string query) =>
        ExecuteNonQuery(new MySqlCommand(query));

    public override object? ExecuteScalar(string query) =>
        ExecuteScalar(new MySqlCommand(query));

    public override T ExecuteScalar<T>(string query) =>
        ExecuteScalar<T>(new MySqlCommand(query));

    public override T ExecuteScalar<T>(IDbCommand command) =>
        (T)(ExecuteScalar(command) ?? default(T)!);

    public override object? ExecuteScalar(IDbCommand command)
    {
        using var connection = dataSource.OpenConnection();
        command.Connection = connection;

        Log.SqlCommand(loggingConfiguration.SqlCommandLogger, command);

        return command.ExecuteScalar();
    }

    public override IDataLinqDataReader ExecuteReader(IDbCommand command)
    {
        var connection = dataSource.OpenConnection();
        command.Connection = connection;

        Log.SqlCommand(loggingConfiguration.SqlCommandLogger, command);

        return new MySqlDataLinqDataReader((command.ExecuteReader(CommandBehavior.CloseConnection) as MySqlDataReader)!);
    }

    public override IDataLinqDataReader ExecuteReader(string query) =>
        ExecuteReader(new MySqlCommand(query));
}

================
File: src/DataLinq.MySql/MySQLProvider.cs
================
using System;
using System.Data;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using DataLinq.Extensions.Helpers;
using DataLinq.Interfaces;
using DataLinq.Logging;
using DataLinq.Metadata;
using DataLinq.Mutation;
using DataLinq.Query;
using MySqlConnector;

namespace DataLinq.MySql;

public class MySQLProvider : IDatabaseProviderRegister
{
    public static bool HasBeenRegistered { get; private set; }

    //[ModuleInitializer]
    public static void RegisterProvider()
    {
        if (HasBeenRegistered)
            return;

        PluginHook.DatabaseProviders[DatabaseType.MySQL] = new MySqlDatabaseCreator();
        PluginHook.SqlFromMetadataFactories[DatabaseType.MySQL] = new SqlFromMetadataFactory();
        PluginHook.MetadataFromSqlFactories[DatabaseType.MySQL] = new MetadataFromMySqlFactoryCreator();

        HasBeenRegistered = true;
    }
}

public class MySQLProviderConstants : IDatabaseProviderConstants
{
    public string ParameterSign { get; } = "?";
    public string LastInsertCommand { get; } = "last_insert_id()";
    public string EscapeCharacter { get; } = "`";
    public bool SupportsMultipleDatabases { get; } = true;
}

public class MySQLProvider<T> : DatabaseProvider<T>, IDisposable
    where T : class, IDatabaseModel
{
    private MySqlDataLinqDataWriter dataWriter = new MySqlDataLinqDataWriter();
    private MySqlDataSource dataSource;
    private MySqlDbAccess dbAccess;

    public override IDatabaseProviderConstants Constants { get; } = new MySQLProviderConstants();
    public override DatabaseAccess DatabaseAccess => dbAccess;

    static MySQLProvider()
    {
        MySQLProvider.RegisterProvider();
    }

    public MySQLProvider(string connectionString) : this(connectionString, null, DataLinqLoggingConfiguration.NullConfiguration)
    {
    }

    public MySQLProvider(string connectionString, DataLinqLoggingConfiguration loggingConfiguration) : base(connectionString, DatabaseType.MySQL, loggingConfiguration)
    {
        var connectionStringBuilder = new MySqlConnectionStringBuilder(connectionString);

        if (!string.IsNullOrWhiteSpace(connectionStringBuilder.Database))
            DatabaseName = connectionStringBuilder.Database;

        Setup();
    }

    public MySQLProvider(string connectionString, string? databaseName) : this(connectionString, databaseName, DataLinqLoggingConfiguration.NullConfiguration)
    {
    }

    public MySQLProvider(string connectionString, string? databaseName, DataLinqLoggingConfiguration loggingConfiguration) : base(connectionString, DatabaseType.MySQL, loggingConfiguration, databaseName)
    {
        Setup();
    }

    private void Setup()
    {
        dataSource = new MySqlDataSourceBuilder(ConnectionString)
            .UseLoggerFactory(LoggingConfiguration.LoggerFactory)
            .Build();

        dbAccess = new MySqlDbAccess(dataSource, LoggingConfiguration);
    }

    //public override void CreateDatabase(string? databaseName = null)
    //{
    //    if (databaseName == null && DatabaseName == null)
    //        throw new ArgumentNullException("DatabaseName not defined");

    //    using var transaction = GetNewDatabaseTransaction(TransactionType.ReadAndWrite);

    //    var query = $"CREATE DATABASE IF NOT EXISTS {databaseName ?? DatabaseName};\n" +
    //        $"USE `{databaseName ?? DatabaseName}`;\n" +
    //        GetCreateSql();

    //    transaction.ExecuteNonQuery(query);
    //}


    public override DatabaseTransaction GetNewDatabaseTransaction(TransactionType type)
    {

        return new MySqlDatabaseTransaction(dataSource, type, DatabaseName, LoggingConfiguration);
    }

    public override DatabaseTransaction AttachDatabaseTransaction(IDbTransaction dbTransaction, TransactionType type)
    {
        return new MySqlDatabaseTransaction(dbTransaction, type, DatabaseName, LoggingConfiguration);
    }

    public override bool DatabaseExists(string? databaseName = null)
    {
        if (databaseName == null && DatabaseName == null)
            throw new ArgumentNullException("DatabaseName not defined");

        return DatabaseAccess
            .ReadReader($"SHOW DATABASES LIKE '{databaseName ?? DatabaseName}'")
            .Any();
    }

    public override bool FileOrServerExists()
    {
        try
        {
            return DatabaseAccess.ExecuteScalar<int>("SELECT 1") == 1;
        }
        catch (Exception)
        {
            return false;
        }
    }

    public override string GetLastIdQuery()
    {
        return "SELECT last_insert_id()";
    }

    public override Sql GetParameterValue(Sql sql, string key)
    {
        return sql.AddFormat("?{0}", key);
    }

    public override Sql GetParameterComparison(Sql sql, string field, Query.Relation relation, string[] key)
    {
        return sql.AddFormat("{0} {1} {2}",
            field,
            relation.ToSql(),
            GetParameterName(relation, key));
    }

    private string GetParameterName(Query.Relation relation, string[] key)
    {
        var builder = new StringBuilder();
        if (key.Length > 1 || relation == Query.Relation.In || relation == Query.Relation.NotIn)
        {
            builder.Append('(');
        }

        for (int i = 0; i < key.Length; i++)
        {
            if (i > 0)
            {
                builder.Append(", ");
            }
            builder.Append('?');
            builder.Append(key[i]);
        }

        if (key.Length > 1 || relation == Query.Relation.In || relation == Query.Relation.NotIn)
        {
            builder.Append(')');
        }

        return builder.ToString();
    }

    public override Sql GetParameter(Sql sql, string key, object? value)
    {
        return sql.AddParameters(new MySqlParameter("?" + key, value ?? DBNull.Value));
    }

    public override Sql GetLimitOffset(Sql sql, int? limit, int? offset)
    {
        if (!limit.HasValue && !offset.HasValue)
            return sql;

        if (limit.HasValue && !offset.HasValue)
            sql.AddText($"\nLIMIT {limit}");
        else if (!limit.HasValue && offset.HasValue)
            sql.AddText($"\nLIMIT 18446744073709551615 OFFSET {offset}");
        else
            sql.AddText($"\nLIMIT {limit} OFFSET {offset}");

        return sql;
    }

    public override Sql GetTableName(Sql sql, string tableName, string? alias = null)
    {
        sql.AddText($"{Constants.EscapeCharacter}{DatabaseName}{Constants.EscapeCharacter}.");

        sql.AddText(string.IsNullOrEmpty(alias)
            ? $"{Constants.EscapeCharacter}{tableName}{Constants.EscapeCharacter}"
            : $"{Constants.EscapeCharacter}{tableName}{Constants.EscapeCharacter} {alias}");

        return sql;
    }

    public override IDbCommand ToDbCommand(IQuery query)
    {
        var sql = query.ToSql();

        var command = new MySqlCommand(sql.Text);
        command.Parameters.AddRange(sql.Parameters.ToArray());

        return command;
    }

    public override Sql GetCreateSql() => new SqlFromMetadataFactory().GetCreateTables(Metadata, true);

    public override IDataLinqDataWriter GetWriter()
    {
        return dataWriter;
    }
}

================
File: src/DataLinq.MySql/SqlFromMetadataFactory.cs
================
using System;
using System.Linq;
using DataLinq.Attributes;
using DataLinq.ErrorHandling;
using DataLinq.Extensions.Helpers;
using DataLinq.Metadata;
using DataLinq.Query;
using MySqlConnector;
using ThrowAway;

namespace DataLinq.MySql;

public class SqlFromMetadataFactory : ISqlFromMetadataFactory
{
    private static readonly string[] NoLengthTypes = new string[] { "text", "tinytext", "mediumtext", "longtext", "enum", "float", "double", "blob", "tinyblob", "mediumblob", "longblob" };

    public Option<int, IDLOptionFailure> CreateDatabase(Sql sql, string databaseName, string connectionString, bool foreignKeyRestrict)
    {
        using var connection = new MySqlConnection(connectionString);
        connection.Open();
        var command = connection.CreateCommand();

        command.CommandText = $"CREATE DATABASE IF NOT EXISTS `{databaseName}`;\n" +
            $"USE `{databaseName}`;\n" +
            sql.Text;

        return command.ExecuteNonQuery();
    }

    public Option<Sql, IDLOptionFailure> GetCreateTables(DatabaseDefinition metadata, bool foreignKeyRestrict)
    {
        var sql = new SqlGeneration(2, '`', "/* Generated %datetime% by DataLinq */\n\n");
        //sql.CreateDatabase(metadata.DbName);

        foreach (var table in sql.SortTablesByForeignKeys(metadata.TableModels.Where(x => x.Table.Type == TableType.Table).Select(x => x.Table).ToList()))
        {
            sql.CreateTable(table.DbName, x =>
            {
                CreateColumns(foreignKeyRestrict, x, table);
            });
        }

        foreach (var view in sql.SortViewsByForeignKeys(metadata.TableModels.Where(x => x.Table.Type == TableType.View).Select(x => x.Table).Cast<ViewDefinition>().ToList()))
        {
            sql.CreateView(view.DbName, view.Definition);
        }

        return sql.sql;
    }

    private static void CreateColumns(bool foreignKeyRestrict, SqlGeneration sql, TableDefinition table)
    {
        var longestName = table.Columns.Max(x => x.DbName.Length) + 1;
        foreach (var column in table.Columns.OrderBy(x => x.Index))
        {
            var dbType = GetDbType(column);
            //var dbType = column.DbTypes.Single(x => x.DatabaseType == DatabaseType.MySQL);

            var row = sql.NewRow().Indent()
                .ColumnName(column.DbName)
                .Type(dbType.Name.ToUpper(), column.DbName, longestName);

            if (dbType.Name == "enum" && column.ValueProperty.EnumProperty.HasValue)
                sql.EnumValues(column.ValueProperty.EnumProperty.Value.EnumValues.Select(x => x.name));

            if (!NoLengthTypes.Contains(dbType.Name.ToLower()) && dbType.Length.HasValue && dbType.Length != 0)
                sql.TypeLength(dbType.Length, dbType.Decimals);

            var defaultValue = GetDefaultValue(column);
            if (defaultValue != null)
                row.DefaultValue(defaultValue);

            sql.Unsigned(dbType.Signed);
            sql.Nullable(column.Nullable)
                .Autoincrement(column.AutoIncrement);

        }

        sql.PrimaryKey(table.PrimaryKeyColumns.Select(x => x.DbName).ToArray());

        //foreach (var uniqueIndex in table.ColumnIndices.Where(x => x.Characteristic == IndexCharacteristic.Unique))
        //    sql.UniqueKey(uniqueIndex.Name, uniqueIndex.Columns.Select(x => x.DbName).ToArray());

        foreach (var foreignKey in table.Columns.Where(x => x.ForeignKey))
            foreach (var index in foreignKey.ColumnIndices)
                foreach (var relation in index.RelationParts)
                    sql.ForeignKey(relation, foreignKeyRestrict);

        foreach (var index in table.ColumnIndices.Where(x => x.Characteristic != IndexCharacteristic.PrimaryKey && x.Characteristic != IndexCharacteristic.ForeignKey && x.Characteristic != IndexCharacteristic.VirtualDataLinq))
            sql.Index(index.Name, index.Characteristic != IndexCharacteristic.Simple ? index.Characteristic.ToString().ToUpper() : null, index.Type.ToString().ToUpper(), index.Columns.Select(x => x.DbName).ToArray());
    }

    public static DatabaseColumnType GetDbType(ColumnDefinition column)
    {
        if (column.DbTypes.Any(x => x.DatabaseType == DatabaseType.MySQL))
            return column.DbTypes.First(x => x.DatabaseType == DatabaseType.MySQL);

        var type = column.DbTypes
            .Select(x => TryGetColumnType(x))
            .Concat(GetDbTypeFromCsType(column.ValueProperty).Yield())
            .Where(x => x != null)
            .FirstOrDefault();

        if (type == null)
            throw new Exception($"Could not find a MySQL database type for '{column.Table.Model.CsType.Name}.{column.ValueProperty.PropertyName}'");

        return type;
    }

    public static string? GetDefaultValue(ColumnDefinition column)
    {
        var defaultAttr = column.ValueProperty.Attributes
            .Where(x => x is DefaultAttribute)
            .Select(x => x as DefaultAttribute)
            .FirstOrDefault();

        if (defaultAttr is DefaultCurrentTimestampAttribute)
            return "CURRENT_TIMESTAMP";

        return defaultAttr?.Value.ToString();
    }

    private static DatabaseColumnType? TryGetColumnType(DatabaseColumnType dbType)
    {
        string? type = null;

        if (dbType.DatabaseType == DatabaseType.Default)
            type = ParseDefaultType(dbType.Name);
        else if (dbType.DatabaseType == DatabaseType.SQLite)
            type = ParseSQLiteType(dbType.Name);

        return type == null
            ? null
            : new DatabaseColumnType(DatabaseType.MySQL, type, dbType.Length, dbType.Decimals, dbType.Signed);
    }

    private static DatabaseColumnType? GetDbTypeFromCsType(ValueProperty property)
    {
        var type = ParseCsType(property.CsType.Name);

        return type == null
            ? null
            : new DatabaseColumnType(DatabaseType.MySQL, type);
    }

    private static string? ParseDefaultType(string defaultType)
    {
        return defaultType.ToLower() switch
        {
            "integer" => "integer",
            "int" => "integer",
            "tinyint" => "integer",
            "mediumint" => "integer",
            "bit" => "integer",
            "bigint" => "integer",
            "smallint" => "integer",
            "enum" => "integer",
            "real" => "real",
            "double" => "real",
            "float" => "real",
            "decimal" => "real",
            "varchar" => "text",
            "text" => "text",
            "mediumtext" => "text",
            "datetime" => "text",
            "timestamp" => "text",
            "date" => "text",
            "char" => "text",
            "longtext" => "text",
            "binary" => "blob",
            "blob" => "blob",
            _ => null
            //_ => throw new NotImplementedException($"Unknown type '{mysqlType}'"),
        };
    }

    private static string? ParseSQLiteType(string sqliteType)
    {
        return sqliteType.ToLower() switch
        {
            "integer" => "int",
            "text" => "varchar",
            "real" => "double",
            "blob" => "binary",
            _ => null
        };
    }

    private static string? ParseCsType(string csType)
    {
        return csType.ToLower() switch
        {
            "int" => "int",
            "string" => "varchar",
            "bool" => "bit",
            "double" => "double",
            "DateTime" => "datetime",
            "DateOnly" => "date",
            "float" => "float",
            "long" => "bigint",
            "Guid" => "binary",
            "enum" => "enum",
            "decimal" => "decimal",
            "byte[]" => "blob",
            _ => null
        };
    }
}

================
File: src/DataLinq.SQLite/Extensions/Helpers/LinqExtensions.cs
================
using System;
using System.Collections.Generic;

namespace DataLinq.Extensions.Helpers;

internal static class LinqExtensions
{
    internal static string ToJoinedString<T>(this IEnumerable<T> source, string separator = "\n") =>
        string.Join(separator, source);

    //https://stackoverflow.com/a/11463800
    internal static IEnumerable<List<T>> SplitList<T>(this List<T> locations, int nSize = 30)
    {
        for (int i = 0; i < locations.Count; i += nSize)
        {
            yield return locations.GetRange(i, Math.Min(nSize, locations.Count - i));
        }
    }

    internal static IEnumerable<T> Yield<T>(this T item)
    {
#pragma warning disable RCS1165 // Unconstrained type parameter checked for null.
        if (item != null)
#pragma warning restore RCS1165 // Unconstrained type parameter checked for null.
            yield return item;
    }
}

================
File: src/DataLinq.SQLite/Extensions/Helpers/QueryExtensions.cs
================
using DataLinq.Query;

namespace DataLinq.Extensions.Helpers;

internal static class QueryExtensions
{
    internal static string ToSql(this Relation relation)
    {
        switch (relation)
        {
            case Relation.Equal:
                return "=";

            case Relation.EqualNull:
                return "IS";

            case Relation.NotEqual:
                return "<>";

            case Relation.NotEqualNull:
                return "IS NOT";

            case Relation.Like:
                return "LIKE";

            case Relation.GreaterThan:
                return ">";

            case Relation.GreaterThanOrEqual:
                return ">=";

            case Relation.LessThan:
                return "<";

            case Relation.LessThanOrEqual:
                return "<=";

            case Relation.In:
                return "IN";

            case Relation.NotIn:
                return "NOT IN";
        }

        return null;
    }
}

================
File: src/DataLinq.SQLite/Extensions/Helpers/StringExtensions.cs
================
using System;

namespace DataLinq.Extensions.Helpers;

internal static class StringExtensions
{
    //https://stackoverflow.com/a/4405876
    internal static string FirstCharToUpper(this string input) =>
        input switch
        {
            null => throw new ArgumentNullException(nameof(input)),
            "" => throw new ArgumentException($"{nameof(input)} cannot be empty", nameof(input)),
            _ => string.Concat(input[0].ToString().ToUpper(), input.Substring(1))
        };
}

================
File: src/DataLinq.SQLite/MetadataFromSQLiteFactory.cs
================
using System;
using System.Data;
using System.Linq;
using System.Text.RegularExpressions;
using DataLinq.Attributes;
using DataLinq.Core.Factories;
using DataLinq.Extensions.Helpers;
using DataLinq.Metadata;
using ThrowAway;

namespace DataLinq.SQLite;

public class MetadataFromSQLiteFactoryCreator : IMetadataFromDatabaseFactoryCreator
{
    public IMetadataFromSqlFactory GetMetadataFromSqlFactory(MetadataFromDatabaseFactoryOptions options)
    {
        return new MetadataFromSQLiteFactory(options);
    }
}

public class MetadataFromSQLiteFactory : IMetadataFromSqlFactory
{
    private readonly MetadataFromDatabaseFactoryOptions options;

    public MetadataFromSQLiteFactory(MetadataFromDatabaseFactoryOptions options)
    {
        this.options = options;
    }

    public Option<DatabaseDefinition> ParseDatabase(string name, string csTypeName, string csNamespace, string dbName, string connectionString)
    {
        var dbAccess = new SQLiteDatabaseTransaction(connectionString, Mutation.TransactionType.ReadOnly);

        var database = new DatabaseDefinition(name, new CsTypeDeclaration(csTypeName, csNamespace, ModelCsType.Class), dbName);
        database.SetTableModels(dbAccess
            .ReadReader("SELECT *\r\nFROM sqlite_master m\r\nWHERE\r\nm.type <> 'index' AND\r\nm.tbl_name <> 'sqlite_sequence'")
            .Select(x => ParseTable(database, x, dbAccess)));

        ParseIndices(database, dbAccess);
        ParseRelations(database, dbAccess);
        MetadataFactory.ParseIndices(database);
        MetadataFactory.ParseRelations(database);
        MetadataFactory.ParseInterfaces(database);

        return database;
    }

    private void ParseIndices(DatabaseDefinition database, SQLiteDatabaseTransaction dbAccess)
    {
        foreach (var tableModel in database.TableModels.Where(x => x.Table.Type == TableType.Table))
        {
            foreach (var reader in dbAccess.ReadReader($"SELECT l.`name`, l.`origin`, l.`unique`, i.`seqno`, i.`name` FROM pragma_index_list('{tableModel.Table.DbName}') l JOIN pragma_index_info(l.`name`) i"))
            {
                var column = tableModel
                    .Table.Columns.Single(x => x.DbName == reader.GetString(4));

                var name = reader.GetString(0);
                if (name.StartsWith("sqlite_autoindex"))
                    name = column.DbName;

                // Determine the type and characteristic of the index.
                var indexType = IndexType.BTREE;  // SQLite predominantly uses B-tree
                var indexCharacteristic = reader.GetInt32(2) == 1
                    ? IndexCharacteristic.Unique
                    : IndexCharacteristic.Simple;

                column.ValueProperty.AddAttribute(new IndexAttribute(name, indexCharacteristic, indexType));
            }
        }
    }

    private void ParseRelations(DatabaseDefinition database, SQLiteDatabaseTransaction dbAccess)
    {
        foreach (var tableModel in database.TableModels.Where(x => x.Table.Type == TableType.Table))
        {
            foreach (var reader in dbAccess.ReadReader($"SELECT `id`, `table`, `from`, `to` FROM pragma_foreign_key_list('{tableModel.Table.DbName}')"))
            {
                var keyName = reader.GetString(0);
                var tableName = reader.GetString(1);
                var fromColumn = reader.GetString(2);
                var toColumn = reader.GetString(3);

                var foreignKeyColumn = tableModel
                    .Table.Columns.Single(x => x.DbName == fromColumn);

                foreignKeyColumn.SetForeignKey();
                foreignKeyColumn.ValueProperty.AddAttribute(new ForeignKeyAttribute(tableName, toColumn, keyName));

                var referencedColumn = database
                   .TableModels.SingleOrDefault(x => x.Table.DbName == tableName)?
                   .Table.Columns.SingleOrDefault(x => x.DbName == toColumn);

                if (referencedColumn != null)
                {
                    MetadataFactory.AddRelationProperty(referencedColumn, foreignKeyColumn, keyName);
                    MetadataFactory.AddRelationProperty(foreignKeyColumn, referencedColumn, keyName);
                }
            }
        }
    }

    private TableModel ParseTable(DatabaseDefinition database, IDataLinqDataReader reader, SQLiteDatabaseTransaction dbAccess)
    {
        var type = reader.GetString(0) == "table" ? TableType.Table : TableType.View; //sqlite_master.type
        var table = type == TableType.Table
             ? new TableDefinition(reader.GetString(2))
             : new ViewDefinition(reader.GetString(2));

        var csName = options.CapitaliseNames
            ? table.DbName.FirstCharToUpper()
            : table.DbName;

        var tableModel = new TableModel(csName, database, table, csName);

        if (table is ViewDefinition view)
            view.SetDefinition(ParseViewDefinition(reader.GetString(4))); //sqlite_master.sql

        table.SetColumns(dbAccess
            .ReadReader($"SELECT * FROM pragma_table_info(\"{table.DbName}\")")
            .Select(x => ParseColumn(table, x, dbAccess)));

        return tableModel;
    }

    private static string ParseViewDefinition(string definition)
    {
        definition = definition
            .ReplaceLineEndings(" ")
            .Replace("\"", @"\""");

        var selectIndex = definition.IndexOf("SELECT ", StringComparison.OrdinalIgnoreCase);

        if (selectIndex != -1)
            definition = definition.Substring(selectIndex);

        return definition;
    }

    private ColumnDefinition ParseColumn(TableDefinition table, IDataLinqDataReader reader, SQLiteDatabaseTransaction dbAccess)
    {
        var dbType = new DatabaseColumnType(DatabaseType.SQLite, reader.GetString(2).ToLower());

        // For whatever reason, sometimes the data type for columns in views return ""
        if (string.IsNullOrEmpty(dbType.Name))
            dbType.SetName("text");

        var dbName = reader.GetString(1);

        var createStatement = dbAccess.ExecuteScalar<string>($"SELECT sql FROM sqlite_master WHERE type='table' AND name='{table.DbName}'");
        var hasAutoIncrement = false;

        if (createStatement != null)
        {
            // Check if the specified column is defined as AUTOINCREMENT
            var pattern = $@"\""({dbName})\""\s+INTEGER\s+PRIMARY\s+KEY\s+AUTOINCREMENT\b";
            var regex = new Regex(pattern, RegexOptions.IgnoreCase | RegexOptions.Singleline);

            hasAutoIncrement = regex.IsMatch(createStatement);
        }

        var column = new ColumnDefinition(dbName, table);
        column.SetNullable(reader.GetBoolean(3) == false); // For views, this seems to indicate all columns as Nullable
        column.SetAutoIncrement(hasAutoIncrement);
        column.SetPrimaryKey(reader.GetBoolean(5));
        column.AddDbType(dbType);

        var csType = ParseCsType(dbType.Name);

        MetadataFactory.AttachValueProperty(column, csType, options.CapitaliseNames);

        return column;
    }

    // https://www.sqlite.org/datatype3.html
    private string ParseCsType(string dbType)
    {
        return dbType.ToLower() switch
        {
            "integer" => "int",
            "real" => "double",
            "text" => "string",
            "blob" => "byte[]",
            _ => throw new NotImplementedException($"Unknown type '{dbType}'"),
        };
    }
}

================
File: src/DataLinq.SQLite/SqlFromMetadataFactory.cs
================
using System;
using System.Data;
using System.IO;
using System.Linq;
using DataLinq.Attributes;
using DataLinq.ErrorHandling;
using DataLinq.Extensions.Helpers;
using DataLinq.Metadata;
using DataLinq.Query;
using Microsoft.Data.Sqlite;
using ThrowAway;

namespace DataLinq.SQLite;

public class SqlFromMetadataFactory : ISqlFromMetadataFactory
{
    public Option<Sql, IDLOptionFailure> GetCreateTables(DatabaseDefinition metadata, bool foreignKeyRestrict)
    {
        var sql = new SQLiteGeneration(2, '"', "/* Generated %datetime% by DataLinq */\n\n");
        foreach (var table in sql.SortTablesByForeignKeys(metadata.TableModels.Select(x => x.Table).Where(x => x.Type == TableType.Table).ToList()))
        {
            sql.CreateTable(table.DbName, x =>
            {
                var longestName = table.Columns.Max(x => x.DbName.Length) + 1;
                foreach (var column in table.Columns.OrderBy(x => x.Index))
                {
                    var dbType = GetDbType(column);

                    sql.NewRow().Indent()
                        .ColumnName(column.DbName)
                        .Type(dbType.Name.ToUpper(), column.DbName, longestName)
                        .Add(column.PrimaryKey && table.PrimaryKeyColumns.Length == 1 ? " PRIMARY KEY" : "")
                        .Add(column.AutoIncrement ? " AUTOINCREMENT" : "");

                    sql.Nullable(column.PrimaryKey ? false : column.Nullable);
                }

                if (table.PrimaryKeyColumns.Length > 1)
                    sql.PrimaryKey(table.PrimaryKeyColumns.Select(x => x.DbName).ToArray());

                //{
                //    sql.NewRow().Indent()
                //        .Add($"PRIMARY KEY ({table.PrimaryKeyColumns.Select(x => x.DbName).ToJoinedString(", ")})");
                //}

                foreach (var uniqueIndex in table.ColumnIndices.Where(x => x.Characteristic == IndexCharacteristic.Unique))
                    sql.UniqueKey(uniqueIndex.Name, uniqueIndex.Columns.Select(x => x.DbName).ToArray());

                foreach (var foreignKey in table.Columns.Where(x => x.ForeignKey))
                    foreach (var index in foreignKey.ColumnIndices)
                        foreach (var relation in index.RelationParts)
                            sql.ForeignKey(relation, foreignKeyRestrict);
            });
        }

        foreach (var view in sql.SortViewsByForeignKeys(metadata.TableModels.Select(x => x.Table).Where(x => x.Type == TableType.View).Cast<ViewDefinition>().ToList()))
        {
            if (string.IsNullOrWhiteSpace(view.Definition))
                return DLOptionFailure.Fail($"View '{view.DbName}' does not have a Definition, can't create view. Add the 'DefinitionAttribute' to the view.");

            sql.CreateView(view.DbName, view.Definition);
        }

        return sql.sql;
    }

    public Option<int, IDLOptionFailure> CreateDatabase(Sql sql, string databaseName, string connectionString, bool foreignKeyRestrict)
    {
        var builder = new SqliteConnectionStringBuilder(connectionString);
        var file = builder.DataSource;

        if (file != "memory")
        {
            if (File.Exists(file))
                return DLOptionFailure.Fail($"Failed to create new SQLite database file '{file}', it already exists.");

            File.WriteAllBytes(file, []);
        }

        using var connection = new SqliteConnection(connectionString);
        connection.Open();
        var command = connection.CreateCommand();
        command.CommandText = sql.Text;

        return command.ExecuteNonQuery();
    }

    public static DatabaseColumnType GetDbType(ColumnDefinition column)
    {
        if (column.DbTypes.Any(x => x.DatabaseType == DatabaseType.SQLite))
            return column.DbTypes.First(x => x.DatabaseType == DatabaseType.SQLite);

        var type = column.DbTypes
            .Select(x => TryGetColumnType(x))
            .Concat(GetDbTypeFromCsType(column.ValueProperty).Yield())
            .Where(x => x != null)
            .FirstOrDefault();

        if (type == null)
            throw new Exception($"Could not find a SQLite database type for '{column.Table.Model.CsType.Name}.{column.ValueProperty.PropertyName}'");

        return type;
    }

    private static DatabaseColumnType? TryGetColumnType(DatabaseColumnType dbType)
    {
        string? type = null;

        if (dbType.DatabaseType == DatabaseType.Default)
            type = ParseDefaultType(dbType.Name);
        else if (dbType.DatabaseType == DatabaseType.MySQL)
            type = ParseMySqlType(dbType.Name);

        return type == null
            ? null
            : new DatabaseColumnType(DatabaseType.SQLite, type, dbType.Length, dbType.Decimals, dbType.Signed);
    }

    private static DatabaseColumnType? GetDbTypeFromCsType(ValueProperty property)
    {
        var type = ParseCsType(property.CsType.Name);

        return type == null
            ? null 
            : new DatabaseColumnType(DatabaseType.SQLite, type);
    }

    private static string? ParseDefaultType(string defaultType)
    {
        return defaultType.ToLower() switch
        {
            "integer" => "integer",
            "int" => "integer",
            "tinyint" => "integer",
            "mediumint" => "integer",
            "bit" => "integer",
            "bigint" => "integer",
            "smallint" => "integer",
            "enum" => "integer",
            "real" => "real",
            "double" => "real",
            "float" => "real",
            "decimal" => "real",
            "varchar" => "text",
            "text" => "text",
            "mediumtext" => "text",
            "datetime" => "text",
            "timestamp" => "text",
            "date" => "text",
            "char" => "text",
            "longtext" => "text",
            "binary" => "blob",
            "blob" => "blob",
            _ => null
            //_ => throw new NotImplementedException($"Unknown type '{mysqlType}'"),
        };
    }

    private static string? ParseMySqlType(string mysqlType)
    {
        return mysqlType.ToLower() switch
        {
            "int" => "integer",
            "tinyint" => "integer",
            "mediumint" => "integer",
            "varchar" => "text",
            "text" => "text",
            "mediumtext" => "text",
            "bit" => "integer",
            "double" => "real",
            "datetime" => "text",
            "timestamp" => "text",
            "date" => "text",
            "float" => "real",
            "bigint" => "integer",
            "char" => "text",
            "binary" => "blob",
            "enum" => "integer",
            "longtext" => "text",
            "decimal" => "real",
            "blob" => "blob",
            "smallint" => "integer",
            _ => null
            //_ => throw new NotImplementedException($"Unknown type '{mysqlType}'"),
        };
    }

    private static string? ParseCsType(string csType)
    {
        return csType.ToLower() switch
        {
            "int" => "integer",
            "double" => "real",
            "string" => "text",
            "byte[]" => "blob",
            _ => null
            //_ => throw new NotImplementedException($"Unknown type '{csType}'"),
        };
    }
}

public class SQLiteGeneration : SqlGeneration
{
    public SQLiteGeneration(int indentationSpaces = 4, char quoteChar = '`', string generatedText = "") : base(indentationSpaces, quoteChar, generatedText)
    {
    }

    public override SqlGeneration UniqueKey(string name, params string[] columns)
        => NewRow().Indent().Add($"CONSTRAINT {QuotedString(name)} UNIQUE {ParenthesisList(columns)}");
}

================
File: src/DataLinq.SQLite/SQLiteDatabase.cs
================
using DataLinq.Interfaces;
using DataLinq.Metadata;
using Microsoft.Extensions.Logging;

namespace DataLinq.SQLite;

public class SQLiteDatabaseCreator : IDatabaseProviderCreator
{
    private ILoggerFactory? loggerFactory;

    public bool IsDatabaseType(string typeName)
    {
        return typeName.Equals("sqlite", System.StringComparison.OrdinalIgnoreCase);
    }

    Database<T> IDatabaseProviderCreator.GetDatabaseProvider<T>(string connectionString, string databaseName) //Ignore databaseName for SQLite, use filename instead since SQlite only supports one database per file.
    {
        return new SQLiteDatabase<T>(connectionString);
    }

    public SQLiteDatabaseCreator UseLoggerFactory(ILoggerFactory? loggerFactory)
    {
        this.loggerFactory = loggerFactory;
        return this;
    }

    IDatabaseProviderCreator IDatabaseProviderCreator.UseLoggerFactory(ILoggerFactory? loggerFactory) =>
        UseLoggerFactory(loggerFactory);
}

public class SQLiteDatabase<T> : Database<T>
     where T : class, IDatabaseModel
{
    public SQLiteDatabase(string connectionString) : base(new SQLiteProvider<T>(connectionString))
    {
    }

    //public SQLiteDatabase(string connectionString, string databaseName) : base(new SQLiteProvider<T>(connectionString, databaseName))
    //{
    //}
}

================
File: src/DataLinq.SQLite/SQLiteDatabaseTransaction.cs
================
using System;
using System.Data;
using DataLinq.Mutation;
using Microsoft.Data.Sqlite;

namespace DataLinq.SQLite;

public class SQLiteDatabaseTransaction : DatabaseTransaction
{
    private IDbConnection dbConnection;
    private readonly string connectionString;

    //private SqliteTransaction dbTransaction;

    public SQLiteDatabaseTransaction(string connectionString, TransactionType type) : base(type)
    {
        this.connectionString = connectionString;
    }

    public SQLiteDatabaseTransaction(IDbTransaction dbTransaction, TransactionType type) : base(dbTransaction, type)
    {
        if (dbTransaction.Connection == null) throw new ArgumentNullException("dbTransaction.Connection", "The transaction connection is null");
        if (dbTransaction.Connection is not SqliteConnection) throw new ArgumentException("The transaction connection must be an SqliteConnection", "dbTransaction.Connection");
        if (dbTransaction.Connection.State != ConnectionState.Open) throw new Exception("The transaction connection is not open");

        SetStatus(DatabaseTransactionStatus.Open);
        dbConnection = dbTransaction.Connection;
    }

    private IDbConnection DbConnection
    {
        get
        {
            if (Status == DatabaseTransactionStatus.Committed || Status == DatabaseTransactionStatus.RolledBack)
                throw new Exception("Can't open a new connection on a committed or rolled back transaction");

            if (Status == DatabaseTransactionStatus.Closed)
            {
                SetStatus(DatabaseTransactionStatus.Open);
                dbConnection = new SqliteConnection(connectionString);
                dbConnection.Open();
                SetIsolationLevel((dbConnection as SqliteConnection)!, IsolationLevel.ReadUncommitted);

                DbTransaction = dbConnection.BeginTransaction(IsolationLevel.ReadUncommitted);
            }

            return dbConnection;
        }
    }

    private void SetIsolationLevel(SqliteConnection connection, IsolationLevel isolationLevel)
    {
        switch (isolationLevel)
        {
            case IsolationLevel.ReadUncommitted:
                using (var command = new SqliteCommand("PRAGMA read_uncommitted = true;", connection))
                {
                    command.ExecuteNonQuery();
                }
                break;
            case IsolationLevel.Serializable:
            // Serializable is the default mode in SQLite, but you can explicitly set it if needed.
            // Other isolation levels can be managed here if SQLite supports them in future versions.
            default:
                using (var command = new SqliteCommand("PRAGMA read_uncommitted = false;", connection))
                {
                    command.ExecuteNonQuery();
                }
                break;
        }
    }

    public override int ExecuteNonQuery(IDbCommand command)
    {
        try
        {
            command.Connection = DbConnection;
            command.Transaction = DbTransaction;
            return command.ExecuteNonQuery();
        }
        catch (Exception)
        {
            throw;
        }
    }

    public override int ExecuteNonQuery(string query) =>
        ExecuteNonQuery(new SqliteCommand(query));

    public override object ExecuteScalar(string query) =>
        ExecuteScalar(new SqliteCommand(query));

    public override T ExecuteScalar<T>(string query) =>
        (T)ExecuteScalar(new SqliteCommand(query));

    public override T ExecuteScalar<T>(IDbCommand command) =>
        (T)ExecuteScalar(command);

    public override object ExecuteScalar(IDbCommand command)
    {
        try
        {
            command.Connection = DbConnection;
            command.Transaction = DbTransaction;
            return command.ExecuteScalar();
        }
        catch (Exception)
        {
            throw;
        }
    }

    public override IDataLinqDataReader ExecuteReader(string query)
    {
        return ExecuteReader(new SqliteCommand(query));
    }

    /// <summary>
    /// Close this reader when done! (or use a using-statement)
    /// </summary>
    /// <param name="command"></param>
    /// <returns></returns>
    public override IDataLinqDataReader ExecuteReader(IDbCommand command)
    {
        try
        {
            command.Connection = DbConnection;
            command.Transaction = DbTransaction;

            //return command.ExecuteReader() as IDataLinqDataReader;
            return new SQLiteDataLinqDataReader(command.ExecuteReader() as SqliteDataReader);
        }
        catch (Exception)
        {
            //Rollback();
            throw;
        }
    }

    public override void Commit()
    {
        if (Status == DatabaseTransactionStatus.Open)
        {
            if (DbTransaction?.Connection?.State == ConnectionState.Open)
                DbTransaction.Commit();
        }

        SetStatus(DatabaseTransactionStatus.Committed);

        Dispose();
    }

    public override void Rollback()
    {
        if (Status == DatabaseTransactionStatus.Open)
        {
            if (DbTransaction?.Connection?.State == ConnectionState.Open)
                DbTransaction?.Rollback();
        }

        SetStatus(DatabaseTransactionStatus.RolledBack);

        Dispose();
    }

    private void Close()
    {
        if (Status == DatabaseTransactionStatus.Open)
        {
            if (DbTransaction?.Connection?.State == ConnectionState.Open)
                DbTransaction?.Rollback();

            SetStatus(DatabaseTransactionStatus.RolledBack);
        }

        dbConnection?.Close();
    }

    #region IDisposable Members

    public override void Dispose()
    {
        Close();

        dbConnection?.Dispose();
        DbTransaction?.Dispose();
    }

    #endregion IDisposable Members
}

================
File: src/DataLinq.SQLite/SQLiteDataLinqDataReader.cs
================
using System;
using System.Buffers;
using System.Linq;
using DataLinq.Metadata;
using DataLinq.Utils;
using Microsoft.Data.Sqlite;

namespace DataLinq.SQLite;

public class SQLiteDataLinqDataReader : IDataLinqDataReader
{
    public SQLiteDataLinqDataReader(SqliteDataReader dataReader)
    {
        this.dataReader = dataReader;
    }

    protected SqliteDataReader dataReader;

    public void Dispose()
    {
        dataReader.Dispose();
    }

    public bool IsDbNull(int ordinal)
    {
        return dataReader.IsDBNull(ordinal);
    }

    public string GetString(int ordinal)
    {
        return dataReader.GetString(ordinal);
    }

    public bool GetBoolean(int ordinal)
    {
        return dataReader.GetBoolean(ordinal);
    }

    public int GetInt32(int ordinal)
    {
        return dataReader.GetInt32(ordinal);
    }

    public DateOnly GetDateOnly(int ordinal)
    {
        var date = dataReader.GetDateTime(ordinal);
        return new DateOnly(date.Year, date.Month, date.Day);
    }

    public Guid GetGuid(int ordinal)
    {
        return dataReader.GetGuid(ordinal);
    }

    public int GetOrdinal(string name)
    {
        return dataReader.GetOrdinal(name);
    }

    public object GetValue(int ordinal)
    {
        return dataReader.GetValue(ordinal);
    }

    public long GetByteLength(int ordinal)
    {
        return dataReader.GetBytes(ordinal, 0, null, 0, 0);
    }

    public byte[]? GetBytes(int ordinal)
    {
        if (GetByteLength(ordinal) == 0)
            return null;

        var buffer = new byte[GetByteLength(ordinal)];
        if (GetBytes(ordinal, buffer) == 0)
            throw new Exception($"Unexpectedly read 0 bytes from column ordinal {ordinal}");

        return buffer;
    }

    public long GetBytes(int ordinal, Span<byte> buffer)
    {
        byte[] tempBuffer = ArrayPool<byte>.Shared.Rent(buffer.Length);

        try
        {
            long bytesRead = dataReader.GetBytes(ordinal, 0, tempBuffer, 0, buffer.Length);
            new ReadOnlySpan<byte>(tempBuffer, 0, (int)bytesRead).CopyTo(buffer);
            return bytesRead;
        }
        finally
        {
            ArrayPool<byte>.Shared.Return(tempBuffer);
        }
    }

    public bool ReadNextRow()
    {
        return dataReader.Read();
    }


    public T? GetValue<T>(ColumnDefinition column)
    {
        return GetValue<T>(column, GetOrdinal(column.DbName));
    }

    public T? GetValue<T>(ColumnDefinition column, int ordinal)
    {
        if (IsDbNull(ordinal))
            return default;

        else if (column.ValueProperty.CsType.Type == typeof(Guid) || column.ValueProperty.CsType.Type == typeof(Guid?))
        {
            //var dbType = column.GetDbTypeFor(DatabaseType.MySQL); // column.DbTypes.FirstOrDefault(x => x.DatabaseType == DatabaseType.MySQL) ?? column.DbTypes.FirstOrDefault(); //SqlFromMetadataFactory.GetDbType(column);
            //if (value is byte[] bytes && column.GetDbTypeFor(DatabaseType.MySQL)?.Length == 16 && column.GetDbTypeFor(DatabaseType.MySQL)?.Name == "binary")
            //    return new Guid(bytes);

            return (T?)(object)GetGuid(ordinal);
        }
        else if (column.ValueProperty.CsType.Type == typeof(string))
            return (T?)(object)GetString(ordinal);
        else if (column.ValueProperty.CsType.Type == typeof(int) || column.ValueProperty.CsType.Type == typeof(int?))
            return (T?)(object)GetInt32(ordinal);
        else if (column.ValueProperty.CsType.Type == typeof(DateOnly) || column.ValueProperty.CsType.Type == typeof(DateOnly?))
            return (T?)(object)GetDateOnly(ordinal);
        else if (column.ValueProperty.CsType.Type?.IsEnum == true)
        {
            var enumValue = GetValue(ordinal);
            if (enumValue is string stringValue)
                return (T?)Enum.ToObject(column.ValueProperty.CsType.Type, column.ValueProperty.EnumProperty.Value.EnumValues.Single(x => x.name.Equals(stringValue, StringComparison.OrdinalIgnoreCase)).value);
            else
                return (T?)Enum.ToObject(column.ValueProperty.CsType.Type, enumValue);
        }

        var value = GetValue(ordinal);
        if (column.ValueProperty.CsNullable)
            return (T?)Convert.ChangeType(value, TypeUtils.GetNullableConversionType(column.ValueProperty.CsType.Type));
        else if (value.GetType() != column.ValueProperty.CsType.Type)
            return (T?)Convert.ChangeType(value, column.ValueProperty.CsType.Type);

        return (T?)value;
    }

    //public T? GetValue<T>(Column column)
    //{
    //    return (T?)GetValue(column, GetOrdinal(column.DbName));
    //}

    //public T? GetValue<T>(Column column, int ordinal)
    //{
    //    return (T?)GetValue(column, ordinal);
    //}

    //public object? GetValue(Column column)
    //{
    //    return GetValue(column, GetOrdinal(column.DbName));
    //}

    //public object? GetValue(Column column, int ordinal)
    //{
    //    var value = GetValue(ordinal);

    //    if (value is DBNull)
    //        return null;
    //    else if (column.ValueProperty.CsType == typeof(Guid) || column.ValueProperty.CsType == typeof(Guid?))
    //    {
    //        var dbType = SqlFromMetadataFactory.GetDbType(column);
    //        if (value is byte[] bytes && dbType.Name == "binary" && dbType.Length == 16)
    //            return new Guid(bytes);
    //    }
    //    else if (column.ValueProperty.CsType == typeof(DateOnly))
    //        return GetDateOnly(ordinal);
    //    else if (column.ValueProperty.CsType.IsEnum && value is string stringValue)
    //        return Enum.ToObject(column.ValueProperty.CsType, column.ValueProperty.EnumProperty.Value.EnumValues.Single(x => x.name.Equals(stringValue, StringComparison.OrdinalIgnoreCase)).value);
    //    else if (column.ValueProperty.CsType.IsEnum)
    //        return Enum.ToObject(column.ValueProperty.CsType, value);
    //    else if (column.ValueProperty.CsNullable)
    //        return Convert.ChangeType(value, TypeUtils.GetNullableConversionType(column.ValueProperty.CsType));
    //    else if (value.GetType() != column.ValueProperty.CsType)
    //        return Convert.ChangeType(value, column.ValueProperty.CsType);

    //    return value;
    //}




}

================
File: src/DataLinq.SQLite/SQLiteDataLinqDataWriter.cs
================
using System;
using DataLinq.Metadata;

namespace DataLinq.SQLite;

/// <summary>
/// Represents a data writer for SQLite database.
/// </summary>
public class SQLiteDataLinqDataWriter : IDataLinqDataWriter
{
    /// <summary>
    /// Initializes a new instance of the <see cref="SQLiteDataLinqDataWriter"/> class.
    /// </summary>
    public SQLiteDataLinqDataWriter()
    {
    }

    /// <summary>
    /// Converts the specified value to the appropriate type for the specified column.
    /// </summary>
    /// <param name="column">The column metadata.</param>
    /// <param name="value">The value to convert.</param>
    /// <returns>The converted value.</returns>
    public object? ConvertValue(ColumnDefinition column, object? value)
    {
        if (value == null)
            return null;

        if (value is Guid guid)
        {
            var dbType = SqlFromMetadataFactory.GetDbType(column);

            if (dbType.Name == "binary" && dbType.Length == 16)
                return guid.ToByteArray();
        }

        return value;
    }
}

================
File: src/DataLinq.SQLite/SQLiteDbAccess.cs
================
using System.Data;
using Microsoft.Data.Sqlite;

namespace DataLinq.SQLite;

public class SQLiteDbAccess : DatabaseAccess
{
    private readonly string connectionString;

    public SQLiteDbAccess(string connectionString) : base()
    {
        this.connectionString = connectionString;
    }

    private void SetIsolationLevel(SqliteConnection connection, IsolationLevel isolationLevel)
    {
        switch (isolationLevel)
        {
            case IsolationLevel.ReadUncommitted:
                using (var command = new SqliteCommand("PRAGMA read_uncommitted = true;", connection))
                {
                    command.ExecuteNonQuery();
                }
                break;
            case IsolationLevel.Serializable:
            // Serializable is the default mode in SQLite, but you can explicitly set it if needed.
            // Other isolation levels can be managed here if SQLite supports them in future versions.
            default:
                using (var command = new SqliteCommand("PRAGMA read_uncommitted = false;", connection))
                {
                    command.ExecuteNonQuery();
                }
                break;
        }
    }

    public override int ExecuteNonQuery(IDbCommand command)
    {
        using (var connection = new SqliteConnection(connectionString))
        {
            connection.Open();
            command.Connection = connection;
            SetIsolationLevel(connection, IsolationLevel.ReadUncommitted);
            int result = command.ExecuteNonQuery();
            connection.Close();

            return result;
        }
    }

    public override int ExecuteNonQuery(string query) =>
        ExecuteNonQuery(new SqliteCommand(query));

    public override object? ExecuteScalar(string query) =>
        ExecuteScalar(new SqliteCommand(query));

    public override T ExecuteScalar<T>(string query) =>
        (T)ExecuteScalar(new SqliteCommand(query));

    public override T ExecuteScalar<T>(IDbCommand command) =>
        (T)ExecuteScalar(command);

    public override object? ExecuteScalar(IDbCommand command)
    {
        using (var connection = new SqliteConnection(connectionString))
        {
            connection.Open();
            command.Connection = connection;
            SetIsolationLevel(connection, IsolationLevel.ReadUncommitted);
            var result = command.ExecuteScalar();
            connection.Close();

            return result;
        }
    }

    public override IDataLinqDataReader ExecuteReader(IDbCommand command)
    {
        var connection = new SqliteConnection(connectionString);
        connection.Open();
        command.Connection = connection;
        SetIsolationLevel(connection, IsolationLevel.ReadUncommitted);

        //using (var pragma = new SqliteCommand("PRAGMA journal_mode=WAL;", connection))
        //{
        //    pragma.ExecuteNonQuery();
        //}

        return new SQLiteDataLinqDataReader((command.ExecuteReader(CommandBehavior.CloseConnection) as SqliteDataReader)!);
    }

    public override IDataLinqDataReader ExecuteReader(string query) =>
        ExecuteReader(new SqliteCommand(query));
}

================
File: src/DataLinq.SQLite/SQLiteProvider.cs
================
using System;
using System.Data;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using DataLinq.Extensions.Helpers;
using DataLinq.Interfaces;
using DataLinq.Logging;
using DataLinq.Metadata;
using DataLinq.Mutation;
using DataLinq.Query;
using Microsoft.Data.Sqlite;

namespace DataLinq.SQLite;

public enum SQLiteJournalMode
{
    OFF = 0,
    DELETE = 1,
    TRUNCATE = 2,
    PERSIST = 3,
    MEMORY = 4,
    WAL = 5
}

public class SQLiteProvider : IDatabaseProviderRegister
{
    public static bool HasBeenRegistered { get; private set; }

    //[ModuleInitializer]
    public static void RegisterProvider()
    {
        if (HasBeenRegistered)
            return;

        PluginHook.DatabaseProviders[DatabaseType.SQLite] = new SQLiteDatabaseCreator();
        PluginHook.SqlFromMetadataFactories[DatabaseType.SQLite] = new SqlFromMetadataFactory();
        PluginHook.MetadataFromSqlFactories[DatabaseType.SQLite] = new MetadataFromSQLiteFactoryCreator();

        HasBeenRegistered = true;
    }
}

public class SQLiteProviderConstants : IDatabaseProviderConstants
{
    public string ParameterSign { get; } = "@";
    public string LastInsertCommand { get; } = "last_insert_rowid()";
    public string EscapeCharacter { get; } = "\"";
    public bool SupportsMultipleDatabases { get; } = false;
}

public class SQLiteProvider<T> : DatabaseProvider<T>, IDisposable
    where T : class, IDatabaseModel
{
    private SqliteConnectionStringBuilder connectionStringBuilder;
    private SQLiteDataLinqDataWriter dataWriter = new SQLiteDataLinqDataWriter();
    private SQLiteDbAccess dbAccess;
    public override IDatabaseProviderConstants Constants { get; } = new SQLiteProviderConstants();
    public override DatabaseAccess DatabaseAccess => dbAccess;

    static SQLiteProvider()
    {
        SQLiteProvider.RegisterProvider();
    }

    public SQLiteProvider(string connectionString) : base(connectionString, DatabaseType.SQLite, DataLinqLoggingConfiguration.NullConfiguration)
    {
        connectionStringBuilder = new SqliteConnectionStringBuilder(connectionString);
        DatabaseName = Path.GetFileNameWithoutExtension(connectionStringBuilder.DataSource);
        dbAccess = new SQLiteDbAccess(connectionString);
        SetJournalMode(SQLiteJournalMode.WAL);

    }

    //public SQLiteProvider(string connectionString, string databaseName) : base(connectionString, DatabaseType.SQLite, DataLinqLoggingConfiguration.NullConfiguration, databaseName)
    //{
    //    connectionStringBuilder = new SqliteConnectionStringBuilder(connectionString);
    //    dbAccess = new SQLiteDbAccess(connectionString);
    //    SetJournalMode(SQLiteJournalMode.WAL);
    //}

    //public override void CreateDatabase(string databaseName = null)
    //{
    //    if (databaseName == null && DatabaseName == null)
    //        throw new ArgumentNullException("DatabaseName not defined");

    //    using var transaction = GetNewDatabaseTransaction(TransactionType.ReadAndWrite);

    //    var query = $"CREATE DATABASE IF NOT EXISTS `{databaseName ?? DatabaseName}`;\n" +
    //        $"USE `{databaseName ?? DatabaseName}`;\n" +
    //        GetCreateSql();

    //    transaction.ExecuteNonQuery(query);
    //}

    public void SetJournalMode(SQLiteJournalMode journalMode)
    {
        switch (journalMode)
        {
            case SQLiteJournalMode.OFF:
                dbAccess.ExecuteNonQuery("PRAGMA journal_mode = OFF");
                break;
            case SQLiteJournalMode.DELETE:
                dbAccess.ExecuteNonQuery("PRAGMA journal_mode = DELETE");
                break;
            case SQLiteJournalMode.TRUNCATE:
                dbAccess.ExecuteNonQuery("PRAGMA journal_mode = TRUNCATE");
                break;
            case SQLiteJournalMode.PERSIST:
                dbAccess.ExecuteNonQuery("PRAGMA journal_mode = PERSIST");
                break;
            case SQLiteJournalMode.MEMORY:
                dbAccess.ExecuteNonQuery("PRAGMA journal_mode = MEMORY");
                break;
            case SQLiteJournalMode.WAL:
                dbAccess.ExecuteNonQuery("PRAGMA journal_mode = WAL");
                break;
        }
    }

    public override DatabaseTransaction GetNewDatabaseTransaction(TransactionType type)
    {
        //if (type == TransactionType.ReadOnly)
        //    return new SQLiteDbAccess(ConnectionString, type);
        //else
        return new SQLiteDatabaseTransaction(ConnectionString, type);
    }

    public override DatabaseTransaction AttachDatabaseTransaction(IDbTransaction dbTransaction, TransactionType type)
    {
        return new SQLiteDatabaseTransaction(dbTransaction, type);
    }

    public override string GetLastIdQuery() => "SELECT last_insert_rowid()";

    public override Sql GetParameterValue(Sql sql, string key)
    {
        return sql.AddFormat("@{0}", key);
    }

    public override Sql GetParameterComparison(Sql sql, string field, Query.Relation relation, string[] key)
    {
        return sql.AddFormat("{0} {1} {2}", field, relation.ToSql(), GetParameterName(relation, key));
    }

    private string GetParameterName(Query.Relation relation, string[] key)
    {
        var builder = new StringBuilder();
        if (key.Length > 1 || relation == Query.Relation.In || relation == Query.Relation.NotIn)
        {
            builder.Append('(');
        }

        for (int i = 0; i < key.Length; i++)
        {
            if (i > 0)
            {
                builder.Append(", ");
            }
            builder.Append('@');
            builder.Append(key[i]);
        }

        if (key.Length > 1 || relation == Query.Relation.In || relation == Query.Relation.NotIn)
        {
            builder.Append(')');
        }

        return builder.ToString();
    }

    public override Sql GetParameter(Sql sql, string key, object? value)
    {
        return sql.AddParameters(new SqliteParameter("@" + key, value ?? DBNull.Value));
    }

    public override Sql GetLimitOffset(Sql sql, int? limit, int? offset)
    {
        if (!limit.HasValue && !offset.HasValue)
            return sql;

        if (limit.HasValue && !offset.HasValue)
            sql.AddText($"\nLIMIT {limit}");
        else if (!limit.HasValue && offset.HasValue)
            sql.AddText($"\nLIMIT -1 OFFSET {offset}");
        else
            sql.AddText($"\nLIMIT {limit} OFFSET {offset}");

        return sql;
    }

    public override Sql GetTableName(Sql sql, string tableName, string? alias = null)
    {
        sql.AddText(string.IsNullOrEmpty(alias)
        ? $"{Constants.EscapeCharacter}{tableName}{Constants.EscapeCharacter}"
        : $"{Constants.EscapeCharacter}{tableName}{Constants.EscapeCharacter} {alias}");

        return sql;
    }

    public override Sql GetCreateSql() => new SqlFromMetadataFactory().GetCreateTables(Metadata, true);

    public override IDbCommand ToDbCommand(IQuery query)
    {
        var sql = query.ToSql();
        var command = new SqliteCommand(sql.Text);
        command.Parameters.AddRange(sql.Parameters.ToArray());

        return command;
    }

    public override bool DatabaseExists(string? databaseName = null)
    {
        return FileOrServerExists();
    }

    public override bool FileOrServerExists()
    {
        var source = connectionStringBuilder.DataSource;

        if (source == "memory")
            return true;

        return File.Exists(source);
    }

    public override IDataLinqDataWriter GetWriter()
    {
        return dataWriter;
    }
}

================
File: src/DataLinq.Tests.Models/Allround/AllroundBenchmark.cs
================
using System;
using DataLinq;
using DataLinq.Interfaces;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[UseCache]
[Database("AllroundBenchmark")]
public partial class AllroundBenchmark(DataSourceAccess dataSource) : IDatabaseModel
{
    public DbRead<Discount> Discounts { get; } = new DbRead<Discount>(dataSource);
    public DbRead<Inventory> Inventory { get; } = new DbRead<Inventory>(dataSource);
    public DbRead<Location> Locations { get; } = new DbRead<Location>(dataSource);
    public DbRead<Locationhistory> Locationshistory { get; } = new DbRead<Locationhistory>(dataSource);
    public DbRead<Manufacturer> Manufacturers { get; } = new DbRead<Manufacturer>(dataSource);
    public DbRead<Orderdetail> Orderdetails { get; } = new DbRead<Orderdetail>(dataSource);
    public DbRead<Order> Orders { get; } = new DbRead<Order>(dataSource);
    public DbRead<Payment> Payments { get; } = new DbRead<Payment>(dataSource);
    public DbRead<Productcategory> Productcategories { get; } = new DbRead<Productcategory>(dataSource);
    public DbRead<Productimage> Productimages { get; } = new DbRead<Productimage>(dataSource);
    public DbRead<Productreview> Productreviews { get; } = new DbRead<Productreview>(dataSource);
    public DbRead<Product> Products { get; } = new DbRead<Product>(dataSource);
    public DbRead<Producttag> Producttags { get; } = new DbRead<Producttag>(dataSource);
    public DbRead<Shippingcompany> Shippingcompanies { get; } = new DbRead<Shippingcompany>(dataSource);
    public DbRead<Usercontact> Usercontacts { get; } = new DbRead<Usercontact>(dataSource);
    public DbRead<Userfeedback> Userfeedback { get; } = new DbRead<Userfeedback>(dataSource);
    public DbRead<Userhistory> Userhistory { get; } = new DbRead<Userhistory>(dataSource);
    public DbRead<Userprofile> Userprofiles { get; } = new DbRead<Userprofile>(dataSource);
    public DbRead<User> Users { get; } = new DbRead<User>(dataSource);
}

================
File: src/DataLinq.Tests.Models/Allround/AllroundBenchmarkBogusData.cs
================
using System;
using System.Linq;
using Bogus;

namespace DataLinq.Tests.Models.Allround;

public static class AllroundBenchmarkBogusData
{
    public static void FillAllroundBenchmarkWithBogusData(Database<AllroundBenchmark> db, decimal numMillionRows = 0.01m)
    {
        var lockObject = new object();
        lock (lockObject)
        {
            Randomizer.Seed = new Random(59345922);
            using var transaction = db.Transaction();

            // Generate data for Users table
            var userFaker = new Faker<MutableUser>()
                .RuleFor(u => u.UserId, f => f.Random.Uuid())
                .RuleFor(u => u.UserName, f => f.Internet.UserName())
                .RuleFor(u => u.Email, f => f.Internet.Email())
                .RuleFor(u => u.DateJoined, f => f.Date.PastDateOnly(3))
                .RuleFor(u => u.UserRole, f => f.PickRandom<User.UserRoleValue>());

            var users = transaction.Insert(userFaker.Generate((int)(200000 * numMillionRows)));
            var userIds = users.Select(u => u.UserId).ToList();

            // Generate data for Products table
            var productFaker = new Faker<MutableProduct>()
                .RuleFor(p => p.ProductId, f => f.Random.Uuid())
                .RuleFor(p => p.ProductName, f => f.Commerce.ProductName())
                .RuleFor(p => p.Price, f => (double?)f.Random.Decimal(1, 10000));

            var products = transaction.Insert(productFaker.Generate((int)(200000 * numMillionRows)));
            var productIds = products.Select(p => p.ProductId).ToList();

            // Generate data for Locations table
            var locationFaker = new Faker<MutableLocation>()
                .RuleFor(l => l.LocationId, f => f.Random.Uuid())
                .RuleFor(l => l.Address, f => f.Address.StreetAddress())
                .RuleFor(l => l.City, f => f.Address.City())
                .RuleFor(l => l.Country, f => f.Address.Country());

            var locations = transaction.Insert(locationFaker.Generate((int)(50000 * numMillionRows)));
            var locationIds = locations.Select(l => l.LocationId).ToList();

            // Generate data for Manufacturers table
            var manufacturerFaker = new Faker<MutableManufacturer>()
                //.RuleFor(m => m.ManufacturerId, f => f.IndexFaker)
                .RuleFor(m => m.ManufacturerName, f => f.Company.CompanyName());

            var manufacturers = transaction.Insert(manufacturerFaker.Generate((int)(1000 * numMillionRows)));
            var manufacturerIds = manufacturers.Select(m => m.ManufacturerId).ToList();

            // Generate data for ProductCategories table
            var productCategoryFaker = new Faker<MutableProductcategory>()
                .RuleFor(pc => pc.CategoryId, f => f.Random.Uuid())
                .RuleFor(pc => pc.CategoryName, f => f.Commerce.Categories(1).First());

            var productCategories = transaction.Insert(productCategoryFaker.Generate((int)(100 * numMillionRows)));
            var categoryIds = productCategories.Select(pc => pc.CategoryId).ToList();


            // Generate data for ShippingCompanies table
            var shippingCompanyFaker = new Faker<MutableShippingcompany>()
                //.RuleFor(sc => sc.ShippingCompanyId, f => f.IndexFaker)
                .RuleFor(sc => sc.CompanyName, f => f.Company.CompanyName());

            var shippingCompanies = transaction.Insert(shippingCompanyFaker.Generate((int)(100 * numMillionRows)));
            var shippingCompanyIds = shippingCompanies.Select(sc => sc.ShippingCompanyId).ToList();

            // Generate data for Orders table
            var orderFaker = new Faker<MutableOrder>()
                .RuleFor(o => o.OrderId, f => f.Random.Uuid())
                .RuleFor(o => o.ProductId, f => (Guid?)f.PickRandom(productIds))
                .RuleFor(o => o.UserId, f => f.PickRandom(userIds))
                .RuleFor(o => o.OrderDate, f => f.Date.PastDateOnly(1))
                .RuleFor(o => o.OrderStatus, f => f.PickRandom<Order.OrderStatusValue>())
                .RuleFor(o => o.ShippingCompanyId, f => f.PickRandom(shippingCompanyIds))
                .RuleFor(o => o.OrderTimestamp, f => f.Date.Past(1));

            var orders = transaction.Insert(orderFaker.Generate((int)(150000 * numMillionRows)));
            var orderIds = orders.Select(o => o.OrderId).ToList();

            // Generate data for Payments table
            var paymentFaker = new Faker<MutablePayment>()
                //.RuleFor(p => p.PaymentId, f => f.IndexFaker)
                .RuleFor(p => p.OrderId, f => f.PickRandom(orderIds))
                .RuleFor(p => p.Amount, f => f.Random.Decimal(1, 10000))
                .RuleFor(p => p.PaymentDate, f => f.Date.PastDateOnly(1))
                .RuleFor(p => p.PaymentMethod, f => f.PickRandom<Payment.PaymentMethodValue>());

            var payments = transaction.Insert(paymentFaker.Generate((int)(150000 * numMillionRows)));

            // Generate data for UserProfiles table
            var userProfileFaker = new Faker<MutableUserprofile>()
                .RuleFor(up => up.ProfileId, f => f.Random.Uuid())
                .RuleFor(up => up.UserId, f => f.PickRandom(userIds))
                .RuleFor(up => up.Bio, f => f.Lorem.Paragraph());

            var userProfiles = transaction.Insert(userProfileFaker.Generate((int)(200000 * numMillionRows)));

            // Generate data for UserContacts table
            var userContactFaker = new Faker<MutableUsercontact>()
                //.RuleFor(uc => uc.ContactId, f => f.IndexFaker)
                .RuleFor(uc => uc.ProfileId, f => f.PickRandom(userProfiles.Select(up => up.ProfileId)))
                .RuleFor(uc => uc.Phone, f => f.Phone.PhoneNumber());

            var userContacts = transaction.Insert(userContactFaker.Generate((int)(200000 * numMillionRows)));

            // Generate data for UserFeedbacks table
            var userFeedbackFaker = new Faker<MutableUserfeedback>()
                //.RuleFor(uf => uf.FeedbackId, f => f.IndexFaker)
                .RuleFor(uf => uf.ProductId, f => (Guid?)f.PickRandom(productIds))
                .RuleFor(uf => uf.UserId, f => f.PickRandom(userIds))
                .RuleFor(uf => uf.Feedback, f => f.Lorem.Sentence());

            var userFeedbacks = transaction.Insert(userFeedbackFaker.Generate((int)(150000 * numMillionRows)));

            // Generate data for UserHistories table
            var userHistoryFaker = new Faker<MutableUserhistory>()
                //.RuleFor(uh => uh.HistoryId, f => f.IndexFaker)
                .RuleFor(uh => uh.UserId, f => f.PickRandom(userIds))
                .RuleFor(uh => uh.ActivityDate, f => f.Date.PastDateOnly(2))
                .RuleFor(uh => uh.ActivityLog, f => f.Lorem.Sentence());

            var userHistories = transaction.Insert(userHistoryFaker.Generate((int)(500000 * numMillionRows)));

            // Generate data for OrderDetails table
            var orderDetailFaker = new Faker<MutableOrderdetail>()
                .RuleFor(od => od.DetailId, f => f.Random.Uuid())
                .RuleFor(od => od.OrderId, f => f.PickRandom(orderIds))
                .RuleFor(od => od.ProductId, f => (Guid?)f.PickRandom(productIds))
                .RuleFor(od => od.Quantity, f => f.Random.Int(1, 10));

            var orderDetails = transaction.Insert(orderDetailFaker.Generate((int)(50000 * numMillionRows)));


            // Generate data for Discounts table
            var discountFaker = new Faker<MutableDiscount>()
                //.RuleFor(d => d.DiscountId, f => f.IndexFaker)
                .RuleFor(d => d.ProductId, f => (Guid?)f.PickRandom(productIds))
                .RuleFor(d => d.DiscountPercentage, f => f.Random.Decimal(0.05m, 0.5m))  // assuming a percentage discount between 5% to 50%
                .RuleFor(d => d.StartDate, f => f.Date.PastDateOnly(1))
                .RuleFor(d => d.EndDate, f => f.Date.FutureDateOnly(1));

            var discounts = transaction.Insert(discountFaker.Generate((int)(50000 * numMillionRows)));

            // Generate data for Inventories table
            var inventoryFaker = new Faker<MutableInventory>()
                //.RuleFor(i => i.InventoryId, f => f.IndexFaker)
                .RuleFor(i => i.ProductId, f => (Guid?)f.PickRandom(productIds))
                .RuleFor(i => i.LocationId, f => f.PickRandom(locationIds))
                .RuleFor(i => i.Stock, f => f.Random.Int(1, 1000));

            var inventories = transaction.Insert(inventoryFaker.Generate((int)(200000 * numMillionRows)));

            // Generate data for LocationHistories table
            var locationHistoryFaker = new Faker<MutableLocationhistory>()
                .RuleFor(lh => lh.HistoryId, f => f.Random.Uuid())
                .RuleFor(lh => lh.LocationId, f => f.PickRandom(locationIds))
                .RuleFor(lh => lh.ChangeDate, f => f.Date.PastDateOnly(2))
                .RuleFor(lh => lh.ChangeLog, f => f.Lorem.Sentence());

            var locationHistories = transaction.Insert(locationHistoryFaker.Generate((int)(500000 * numMillionRows)));

            // Generate data for ProductImages table
            var productImageFaker = new Faker<MutableProductimage>()
                .RuleFor(pi => pi.ImageId, f => f.Random.Uuid())
                .RuleFor(pi => pi.ProductId, f => (Guid?)f.PickRandom(productIds))
                .RuleFor(pi => pi.ImageURL, f => f.Internet.Url());

            var productImages = transaction.Insert(productImageFaker.Generate((int)(250000 * numMillionRows)));

            // Generate data for ProductReviews table
            var productReviewFaker = new Faker<MutableProductreview>()
                .RuleFor(pr => pr.ReviewId, f => f.Random.Uuid())
                .RuleFor(pr => pr.ProductId, f => (Guid?)f.PickRandom(productIds))
                .RuleFor(pr => pr.UserId, f => f.PickRandom(userIds))
                .RuleFor(pr => pr.Rating, f => f.Random.Int(1, 5))  // Assuming a 5-star rating system
                .RuleFor(pr => pr.Review, f => f.Lorem.Paragraph());

            var productReviews = transaction.Insert(productReviewFaker.Generate((int)(500000 * numMillionRows)));

            // Generate data for ProductTags table
            var productTagFaker = new Faker<MutableProducttag>()
                //.RuleFor(pt => pt.TagId, f => f.IndexFaker)  // AutoIncremented
                .RuleFor(pt => pt.CategoryId, f => f.PickRandom(categoryIds))
                .RuleFor(pt => pt.TagName, f => f.Random.Word());

            var productTags = transaction.Insert(productTagFaker.Generate((int)(1000 * numMillionRows)));


            transaction.Commit();
        }
    }
}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Discount.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("discounts")]
public abstract partial class Discount(RowData rowData, DataSourceAccess dataSource) : Immutable<Discount, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    [PrimaryKey]
    [AutoIncrement]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Column("DiscountId")]
    public abstract int? DiscountId { get; }

    [ForeignKey("products", "ProductId", "discounts_ibfk_1")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("ProductId")]
    public abstract Guid? ProductId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "decimal", 5, 2)]
    [Column("DiscountPercentage")]
    public abstract decimal? DiscountPercentage { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "date")]
    [Column("EndDate")]
    public abstract DateOnly? EndDate { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "date")]
    [Column("StartDate")]
    public abstract DateOnly? StartDate { get; }

    [Relation("products", "ProductId", "discounts_ibfk_1")]
    public abstract Product products { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Inventory.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("inventory")]
public abstract partial class Inventory(RowData rowData, DataSourceAccess dataSource) : Immutable<Inventory, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    [PrimaryKey]
    [AutoIncrement]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Column("InventoryId")]
    public abstract int? InventoryId { get; }

    [ForeignKey("locations", "LocationId", "inventory_ibfk_2")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("LocationId")]
    public abstract Guid? LocationId { get; }

    [ForeignKey("products", "ProductId", "inventory_ibfk_1")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("ProductId")]
    public abstract Guid? ProductId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Column("Stock")]
    public abstract int? Stock { get; }

    [Relation("locations", "LocationId", "inventory_ibfk_2")]
    public abstract Location locations { get; }

    [Relation("products", "ProductId", "inventory_ibfk_1")]
    public abstract Product products { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Location.cs
================
using System;
using System.Collections.Generic;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("locations")]
public abstract partial class Location(RowData rowData, DataSourceAccess dataSource) : Immutable<Location, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    [PrimaryKey]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("LocationId")]
    public abstract Guid LocationId { get; }

    [Index("idx_address", IndexCharacteristic.Simple, IndexType.BTREE)]
    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 500)]
    [Column("Address")]
    public abstract string Address { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 255)]
    [Column("City")]
    public abstract string City { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 255)]
    [Column("Country")]
    public abstract string Country { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "float")]
    [Column("Latitude")]
    public abstract float? Latitude { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "float")]
    [Column("Longitude")]
    public abstract float? Longitude { get; }

    [Relation("inventory", "LocationId", "inventory_ibfk_2")]
    public abstract IImmutableRelation<Inventory> inventory { get; }

    [Relation("locationshistory", "LocationId", "locationshistory_ibfk_1")]
    public abstract IImmutableRelation<Locationhistory> locationshistory { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Locationhistory.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("locationshistory")]
public abstract partial class Locationhistory(RowData rowData, DataSourceAccess dataSource) : Immutable<Locationhistory, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    [PrimaryKey]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("HistoryId")]
    public abstract Guid HistoryId { get; }

    [ForeignKey("locations", "LocationId", "locationshistory_ibfk_1")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("LocationId")]
    public abstract Guid? LocationId { get; }

    [Index("idx_changedate", IndexCharacteristic.Simple, IndexType.BTREE)]
    [Nullable]
    [Type(DatabaseType.MySQL, "date")]
    [Column("ChangeDate")]
    public abstract DateOnly? ChangeDate { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "longtext", 4294967295)]
    [Column("ChangeLog")]
    public abstract string ChangeLog { get; }

    [Relation("locations", "LocationId", "locationshistory_ibfk_1")]
    public abstract Location locations { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Manufacturer.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("manufacturers")]
public abstract partial class Manufacturer(RowData rowData, DataSourceAccess dataSource) : Immutable<Manufacturer, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    [PrimaryKey]
    [AutoIncrement]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Column("ManufacturerId")]
    public abstract int? ManufacturerId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "longblob", 4294967295)]
    [Column("Logo")]
    public abstract byte[] Logo { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 255)]
    [Column("ManufacturerName")]
    public abstract string ManufacturerName { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Order.cs
================
using System;
using System.Collections.Generic;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("orders")]
public abstract partial class Order(RowData rowData, DataSourceAccess dataSource) : Immutable<Order, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    public enum OrderStatusValue
    {
        Placed = 1,
        Shipped = 2,
        Delivered = 3,
        Cancelled = 4,
    }
    
    [PrimaryKey]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("OrderId")]
    public abstract Guid OrderId { get; }

    [ForeignKey("products", "ProductId", "orders_ibfk_2")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("ProductId")]
    public abstract Guid? ProductId { get; }

    [ForeignKey("users", "UserId", "orders_ibfk_1")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("UserId")]
    public abstract Guid? UserId { get; }

    [Index("idx_orderdate", IndexCharacteristic.Simple, IndexType.BTREE)]
    [Nullable]
    [Type(DatabaseType.MySQL, "date")]
    [Column("OrderDate")]
    public abstract DateOnly? OrderDate { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "enum")]
    [Enum("Placed", "Shipped", "Delivered", "Cancelled")]
    [Column("OrderStatus")]
    public abstract OrderStatusValue? OrderStatus { get; }

    [Type(DatabaseType.MySQL, "timestamp")]
    [DefaultCurrentTimestamp]
    [Column("OrderTimestamp")]
    public abstract DateTime OrderTimestamp { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Default(0)]
    [Column("ShippingCompanyId")]
    public abstract int? ShippingCompanyId { get; }

    [Relation("orderdetails", "OrderId", "orderdetails_ibfk_1")]
    public abstract IImmutableRelation<Orderdetail> orderdetails { get; }

    [Relation("payments", "OrderId", "payments_ibfk_1")]
    public abstract IImmutableRelation<Payment> payments { get; }

    [Relation("products", "ProductId", "orders_ibfk_2")]
    public abstract Product products { get; }

    [Relation("users", "UserId", "orders_ibfk_1")]
    public abstract User users { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Orderdetail.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("orderdetails")]
public abstract partial class Orderdetail(RowData rowData, DataSourceAccess dataSource) : Immutable<Orderdetail, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    [PrimaryKey]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("DetailId")]
    public abstract Guid DetailId { get; }

    [ForeignKey("orders", "OrderId", "orderdetails_ibfk_1")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("OrderId")]
    public abstract Guid? OrderId { get; }

    [ForeignKey("products", "ProductId", "orderdetails_ibfk_2")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("ProductId")]
    public abstract Guid? ProductId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "double")]
    [Column("Discount")]
    public abstract double? Discount { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Column("Quantity")]
    public abstract int? Quantity { get; }

    [Relation("orders", "OrderId", "orderdetails_ibfk_1")]
    public abstract Order orders { get; }

    [Relation("products", "ProductId", "orderdetails_ibfk_2")]
    public abstract Product products { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Payment.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("payments")]
public abstract partial class Payment(RowData rowData, DataSourceAccess dataSource) : Immutable<Payment, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    public enum PaymentMethodValue
    {
        CreditCard = 1,
        DebitCard = 2,
        PayPal = 3,
        BankTransfer = 4,
    }
    
    [PrimaryKey]
    [AutoIncrement]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Column("PaymentId")]
    public abstract int? PaymentId { get; }

    [ForeignKey("orders", "OrderId", "payments_ibfk_1")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("OrderId")]
    public abstract Guid? OrderId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "decimal", 10, 2)]
    [Column("Amount")]
    public abstract decimal? Amount { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "date")]
    [Column("PaymentDate")]
    public abstract DateOnly? PaymentDate { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "longtext", 4294967295)]
    [Column("PaymentDetails")]
    public abstract string PaymentDetails { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "enum")]
    [Enum("CreditCard", "DebitCard", "PayPal", "BankTransfer")]
    [Column("PaymentMethod")]
    public abstract PaymentMethodValue? PaymentMethod { get; }

    [Relation("orders", "OrderId", "payments_ibfk_1")]
    public abstract Order orders { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Product.cs
================
using System;
using System.Collections.Generic;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("products")]
public abstract partial class Product(RowData rowData, DataSourceAccess dataSource) : Immutable<Product, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    [PrimaryKey]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("ProductId")]
    public abstract Guid ProductId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Column("CategoryId")]
    public abstract int? CategoryId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Column("ManufacturerId")]
    public abstract int? ManufacturerId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "double")]
    [Column("Price")]
    public abstract double? Price { get; }

    [Index("idx_productname", IndexCharacteristic.Simple, IndexType.BTREE)]
    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 255)]
    [Column("ProductName")]
    public abstract string ProductName { get; }

    [Relation("discounts", "ProductId", "discounts_ibfk_1")]
    public abstract IImmutableRelation<Discount> discounts { get; }

    [Relation("inventory", "ProductId", "inventory_ibfk_1")]
    public abstract IImmutableRelation<Inventory> inventory { get; }

    [Relation("orderdetails", "ProductId", "orderdetails_ibfk_2")]
    public abstract IImmutableRelation<Orderdetail> orderdetails { get; }

    [Relation("orders", "ProductId", "orders_ibfk_2")]
    public abstract IImmutableRelation<Order> orders { get; }

    [Relation("productimages", "ProductId", "productimages_ibfk_1")]
    public abstract IImmutableRelation<Productimage> productimages { get; }

    [Relation("productreviews", "ProductId", "productreviews_ibfk_2")]
    public abstract IImmutableRelation<Productreview> productreviews { get; }

    [Relation("userfeedback", "ProductId", "userfeedback_ibfk_2")]
    public abstract IImmutableRelation<Userfeedback> userfeedback { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Productcategory.cs
================
using System;
using System.Collections.Generic;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("productcategories")]
public abstract partial class Productcategory(RowData rowData, DataSourceAccess dataSource) : Immutable<Productcategory, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    [PrimaryKey]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("CategoryId")]
    public abstract Guid CategoryId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 255)]
    [Column("CategoryName")]
    public abstract string CategoryName { get; }

    [Relation("producttags", "CategoryId", "producttags_ibfk_1")]
    public abstract IImmutableRelation<Producttag> producttags { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Productimage.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("productimages")]
public abstract partial class Productimage(RowData rowData, DataSourceAccess dataSource) : Immutable<Productimage, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    [PrimaryKey]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("ImageId")]
    public abstract Guid ImageId { get; }

    [ForeignKey("products", "ProductId", "productimages_ibfk_1")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("ProductId")]
    public abstract Guid? ProductId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "mediumblob", 16777215)]
    [Column("ImageData")]
    public abstract byte[] ImageData { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "text", 65535)]
    [Column("ImageURL")]
    public abstract string ImageURL { get; }

    [Relation("products", "ProductId", "productimages_ibfk_1")]
    public abstract Product products { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Productreview.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("productreviews")]
public abstract partial class Productreview(RowData rowData, DataSourceAccess dataSource) : Immutable<Productreview, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    [PrimaryKey]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("ReviewId")]
    public abstract Guid ReviewId { get; }

    [ForeignKey("products", "ProductId", "productreviews_ibfk_2")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("ProductId")]
    public abstract Guid? ProductId { get; }

    [ForeignKey("users", "UserId", "productreviews_ibfk_1")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("UserId")]
    public abstract Guid? UserId { get; }

    [Index("idx_rating", IndexCharacteristic.Simple, IndexType.BTREE)]
    [Nullable]
    [Type(DatabaseType.MySQL, "tinyint", 4)]
    [Column("Rating")]
    public abstract int? Rating { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "mediumtext", 16777215)]
    [Column("Review")]
    public abstract string Review { get; }

    [Relation("products", "ProductId", "productreviews_ibfk_2")]
    public abstract Product products { get; }

    [Relation("users", "UserId", "productreviews_ibfk_1")]
    public abstract User users { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Producttag.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("producttags")]
public abstract partial class Producttag(RowData rowData, DataSourceAccess dataSource) : Immutable<Producttag, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    [PrimaryKey]
    [AutoIncrement]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Column("TagId")]
    public abstract int? TagId { get; }

    [ForeignKey("productcategories", "CategoryId", "producttags_ibfk_1")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("CategoryId")]
    public abstract Guid? CategoryId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "text", 65535)]
    [Column("Description")]
    public abstract string Description { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 255)]
    [Column("TagName")]
    public abstract string TagName { get; }

    [Relation("productcategories", "CategoryId", "producttags_ibfk_1")]
    public abstract Productcategory productcategories { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Shippingcompany.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("shippingcompanies")]
public abstract partial class Shippingcompany(RowData rowData, DataSourceAccess dataSource) : Immutable<Shippingcompany, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    [PrimaryKey]
    [AutoIncrement]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Column("ShippingCompanyId")]
    public abstract int? ShippingCompanyId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 255)]
    [Column("CompanyName")]
    public abstract string CompanyName { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/User.cs
================
using System;
using System.Collections.Generic;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("users")]
public abstract partial class User(RowData rowData, DataSourceAccess dataSource) : Immutable<User, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    public enum UserRoleValue
    {
        Admin = 1,
        User = 2,
        Guest = 3,
    }
    
    [PrimaryKey]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("UserId")]
    public abstract Guid UserId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "date")]
    [Column("DateJoined")]
    public abstract DateOnly? DateJoined { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 255)]
    [Column("Email")]
    public abstract string Email { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "time")]
    [Column("LastLoginTime")]
    public abstract TimeOnly? LastLoginTime { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "tinyint", 4)]
    [Column("UserAge")]
    public abstract int? UserAge { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "float")]
    [Column("UserHeight")]
    public abstract float? UserHeight { get; }

    [Index("idx_username", IndexCharacteristic.Simple, IndexType.BTREE)]
    [Nullable]
    [Type(DatabaseType.MySQL, "varchar", 255)]
    [Column("UserName")]
    public abstract string UserName { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "enum")]
    [Enum("Admin", "User", "Guest")]
    [Column("UserRole")]
    public abstract UserRoleValue? UserRole { get; }

    [Relation("orders", "UserId", "orders_ibfk_1")]
    public abstract IImmutableRelation<Order> orders { get; }

    [Relation("productreviews", "UserId", "productreviews_ibfk_1")]
    public abstract IImmutableRelation<Productreview> productreviews { get; }

    [Relation("userfeedback", "UserId", "userfeedback_ibfk_1")]
    public abstract IImmutableRelation<Userfeedback> userfeedback { get; }

    [Relation("userhistory", "UserId", "userhistory_ibfk_1")]
    public abstract IImmutableRelation<Userhistory> userhistory { get; }

    [Relation("userprofiles", "UserId", "userprofiles_ibfk_1")]
    public abstract IImmutableRelation<Userprofile> userprofiles { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Usercontact.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("usercontacts")]
public abstract partial class Usercontact(RowData rowData, DataSourceAccess dataSource) : Immutable<Usercontact, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    [PrimaryKey]
    [AutoIncrement]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Column("ContactId")]
    public abstract int? ContactId { get; }

    [ForeignKey("userprofiles", "ProfileId", "usercontacts_ibfk_1")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("ProfileId")]
    public abstract Guid? ProfileId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "char", 30)]
    [Column("Phone")]
    public abstract string Phone { get; }

    [Relation("userprofiles", "ProfileId", "usercontacts_ibfk_1")]
    public abstract Userprofile userprofiles { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Userfeedback.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("userfeedback")]
public abstract partial class Userfeedback(RowData rowData, DataSourceAccess dataSource) : Immutable<Userfeedback, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    [PrimaryKey]
    [AutoIncrement]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Column("FeedbackId")]
    public abstract int? FeedbackId { get; }

    [ForeignKey("products", "ProductId", "userfeedback_ibfk_2")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("ProductId")]
    public abstract Guid? ProductId { get; }

    [ForeignKey("users", "UserId", "userfeedback_ibfk_1")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("UserId")]
    public abstract Guid? UserId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "text", 65535)]
    [Column("Feedback")]
    public abstract string Feedback { get; }

    [Relation("products", "ProductId", "userfeedback_ibfk_2")]
    public abstract Product products { get; }

    [Relation("users", "UserId", "userfeedback_ibfk_1")]
    public abstract User users { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Userhistory.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("userhistory")]
public abstract partial class Userhistory(RowData rowData, DataSourceAccess dataSource) : Immutable<Userhistory, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    [PrimaryKey]
    [AutoIncrement]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Column("HistoryId")]
    public abstract int? HistoryId { get; }

    [ForeignKey("users", "UserId", "userhistory_ibfk_1")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("UserId")]
    public abstract Guid? UserId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "tinyblob", 255)]
    [Column("ActivityBlob")]
    public abstract byte[] ActivityBlob { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "date")]
    [Column("ActivityDate")]
    public abstract DateOnly? ActivityDate { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "text", 65535)]
    [Column("ActivityLog")]
    public abstract string ActivityLog { get; }

    [Relation("users", "UserId", "userhistory_ibfk_1")]
    public abstract User users { get; }

}

================
File: src/DataLinq.Tests.Models/Allround/Tables/Userprofile.cs
================
using System;
using System.Collections.Generic;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Allround;

[Table("userprofiles")]
public abstract partial class Userprofile(RowData rowData, DataSourceAccess dataSource) : Immutable<Userprofile, AllroundBenchmark>(rowData, dataSource), ITableModel<AllroundBenchmark>
{
    [PrimaryKey]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("ProfileId")]
    public abstract Guid ProfileId { get; }

    [ForeignKey("users", "UserId", "userprofiles_ibfk_1")]
    [Nullable]
    [Type(DatabaseType.MySQL, "binary", 16)]
    [Column("UserId")]
    public abstract Guid? UserId { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "text", 65535)]
    [Column("Bio")]
    public abstract string Bio { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "blob", 65535)]
    [Column("ProfileImage")]
    public abstract byte[] ProfileImage { get; }

    [Relation("usercontacts", "ProfileId", "usercontacts_ibfk_1")]
    public abstract IImmutableRelation<Usercontact> usercontacts { get; }

    [Relation("users", "UserId", "userprofiles_ibfk_1")]
    public abstract User users { get; }

}

================
File: src/DataLinq.Tests.Models/employees/gen/EmployeesDb.cs
================
using System;
using DataLinq;
using DataLinq.Interfaces;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Employees;

[UseCache]
[CacheLimit(CacheLimitType.Megabytes, 200)]
[CacheLimit(CacheLimitType.Minutes, 60)]
[CacheCleanup(CacheCleanupType.Minutes, 30)]
[Database("employees")]
public partial class EmployeesDb(DataSourceAccess dataSource) : IDatabaseModel
{
    public DbRead<current_dept_emp> current_dept_emp { get; } = new DbRead<current_dept_emp>(dataSource);
    public DbRead<Department> Departments { get; } = new DbRead<Department>(dataSource);
    public DbRead<dept_emp_latest_date> dept_emp_latest_date { get; } = new DbRead<dept_emp_latest_date>(dataSource);
    public DbRead<Manager> Managers { get; } = new DbRead<Manager>(dataSource);
    public DbRead<Dept_emp> DepartmentEmployees { get; } = new DbRead<Dept_emp>(dataSource);
    public DbRead<Employee> Employees { get; } = new DbRead<Employee>(dataSource);
    public DbRead<Salaries> salaries { get; } = new DbRead<Salaries>(dataSource);
    public DbRead<Titles> titles { get; } = new DbRead<Titles>(dataSource);
}

================
File: src/DataLinq.Tests.Models/employees/gen/Tables/Department.cs
================
using System;
using System.Collections.Generic;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Employees;

public partial interface IDepartmentWithChangedName
{
}

[Table("departments")]
[Interface<IDepartmentWithChangedName>]
public abstract partial class Department(RowData rowData, DataSourceAccess dataSource) : Immutable<Department, EmployeesDb>(rowData, dataSource), ITableModel<EmployeesDb>
{
    [PrimaryKey]
    [Type(DatabaseType.MySQL, "char", 4)]
    [Type(DatabaseType.SQLite, "text")]
    [Column("dept_no")]
    public abstract string DeptNo { get; }

    [Index("dept_name", IndexCharacteristic.Unique, IndexType.BTREE)]
    [Type(DatabaseType.MySQL, "varchar", 40)]
    [Type(DatabaseType.SQLite, "text")]
    [Column("dept_name")]
    public abstract string Name { get; }

    [Relation("dept-emp", "dept_no", "dept_emp_ibfk_2")]
    public abstract IImmutableRelation<Dept_emp> DepartmentEmployees { get; }

    [Relation("dept_manager", "dept_fk", "dept_manager_ibfk_2")]
    public abstract IImmutableRelation<Manager> Managers { get; }

}

================
File: src/DataLinq.Tests.Models/employees/gen/Tables/dept_emp.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Employees;

public partial interface Idept
{
}

[Table("dept-emp")]
[Interface<Idept>]
public abstract partial class Dept_emp(RowData rowData, DataSourceAccess dataSource) : Immutable<Dept_emp, EmployeesDb>(rowData, dataSource), ITableModel<EmployeesDb>
{
    [PrimaryKey]
    [ForeignKey("departments", "dept_no", "dept_emp_ibfk_2")]
    [Type(DatabaseType.MySQL, "char", 4)]
    [Type(DatabaseType.SQLite, "text")]
    [Column("dept_no")]
    public abstract string dept_no { get; }

    [PrimaryKey]
    [ForeignKey("employees", "emp_no", "dept_emp_ibfk_1")]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Type(DatabaseType.SQLite, "integer")]
    [Column("emp_no")]
    public abstract int emp_no { get; }

    [Type(DatabaseType.MySQL, "date")]
    [Type(DatabaseType.SQLite, "text")]
    [Column("from_date")]
    public abstract DateOnly from_date { get; }

    [Type(DatabaseType.MySQL, "date")]
    [Type(DatabaseType.SQLite, "text")]
    [Column("to_date")]
    public abstract DateOnly to_date { get; }

    [Relation("departments", "dept_no", "dept_emp_ibfk_2")]
    public abstract Department departments { get; }

    [Relation("employees", "emp_no", "dept_emp_ibfk_1")]
    public abstract Employee employees { get; }

}

================
File: src/DataLinq.Tests.Models/employees/gen/Tables/Employee.cs
================
using System;
using System.Collections.Generic;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Employees;

public partial interface IEmployee
{
}

[Table("employees")]
[Interface<IEmployee>]
public abstract partial class Employee(RowData rowData, DataSourceAccess dataSource) : Immutable<Employee, EmployeesDb>(rowData, dataSource), ITableModel<EmployeesDb>
{
    public enum Employeegender
    {
        M = 1,
        F = 2,
    }
    
    [PrimaryKey]
    [AutoIncrement]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Type(DatabaseType.SQLite, "integer")]
    [Column("emp_no")]
    public abstract int? emp_no { get; }

    [Type(DatabaseType.MySQL, "date")]
    [Type(DatabaseType.SQLite, "text")]
    [Column("birth_date")]
    public abstract DateOnly birth_date { get; }

    [Type(DatabaseType.MySQL, "varchar", 14)]
    [Type(DatabaseType.SQLite, "text")]
    [Column("first_name")]
    public abstract string first_name { get; }

    [Type(DatabaseType.MySQL, "enum")]
    [Type(DatabaseType.SQLite, "integer")]
    [Enum("M", "F")]
    [Column("gender")]
    public abstract Employeegender gender { get; }

    [Type(DatabaseType.MySQL, "date")]
    [Type(DatabaseType.SQLite, "text")]
    [Column("hire_date")]
    public abstract DateOnly hire_date { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "bit", 1)]
    [Type(DatabaseType.SQLite, "integer")]
    [Column("IsDeleted")]
    public abstract bool? IsDeleted { get; }

    [Type(DatabaseType.MySQL, "varchar", 16)]
    [Type(DatabaseType.SQLite, "text")]
    [Column("last_name")]
    public abstract string last_name { get; }

    [Relation("dept-emp", "emp_no", "dept_emp_ibfk_1")]
    public abstract IImmutableRelation<Dept_emp> dept_emp { get; }

    [Relation("dept_manager", "emp_no", "dept_manager_ibfk_1")]
    public abstract IImmutableRelation<Manager> dept_manager { get; }

    [Relation("salaries", "emp_no", "salaries_ibfk_1")]
    public abstract IImmutableRelation<Salaries> salaries { get; }

    [Relation("titles", "emp_no", "titles_ibfk_1")]
    public abstract IImmutableRelation<Titles> titles { get; }

}

================
File: src/DataLinq.Tests.Models/employees/gen/Tables/Manager.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Employees;

public partial interface IManager
{
}

[Table("dept_manager")]
[Interface<IManager>]
public abstract partial class Manager(RowData rowData, DataSourceAccess dataSource) : Immutable<Manager, EmployeesDb>(rowData, dataSource), ITableModel<EmployeesDb>
{
    [PrimaryKey]
    [ForeignKey("departments", "dept_no", "dept_manager_ibfk_2")]
    [Type(DatabaseType.MySQL, "char", 4)]
    [Type(DatabaseType.SQLite, "text")]
    [Column("dept_fk")]
    public abstract string dept_fk { get; }

    [PrimaryKey]
    [ForeignKey("employees", "emp_no", "dept_manager_ibfk_1")]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Type(DatabaseType.SQLite, "integer")]
    [Column("emp_no")]
    public abstract int emp_no { get; }

    [Type(DatabaseType.MySQL, "date")]
    [Type(DatabaseType.SQLite, "text")]
    [Column("from_date")]
    public abstract DateOnly from_date { get; }

    [Type(DatabaseType.MySQL, "date")]
    [Type(DatabaseType.SQLite, "text")]
    [Column("to_date")]
    public abstract DateOnly to_date { get; }

    [Type(DatabaseType.MySQL, "tinyint", 3, false)]
    [Column("type")]
    public abstract ManagerType Type { get; }

    [Relation("departments", "dept_no", "dept_manager_ibfk_2")]
    public abstract Department Department { get; }

    [Relation("employees", "emp_no", "dept_manager_ibfk_1")]
    public abstract Employee employees { get; }

}

================
File: src/DataLinq.Tests.Models/employees/gen/Tables/Salaries.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Employees;

public partial interface Isalaries
{
}

[Table("salaries")]
[Interface<Isalaries>]
public abstract partial class Salaries(RowData rowData, DataSourceAccess dataSource) : Immutable<Salaries, EmployeesDb>(rowData, dataSource), ITableModel<EmployeesDb>
{
    [PrimaryKey]
    [ForeignKey("employees", "emp_no", "salaries_ibfk_1")]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Type(DatabaseType.SQLite, "integer")]
    [Column("emp_no")]
    public abstract int emp_no { get; }

    [PrimaryKey]
    [Type(DatabaseType.MySQL, "date")]
    [Type(DatabaseType.SQLite, "text")]
    [Column("from_date")]
    public abstract DateOnly FromDate { get; }

    [Type(DatabaseType.MySQL, "int", 11)]
    [Type(DatabaseType.SQLite, "integer")]
    [Column("salary")]
    public abstract int salary { get; }

    [Type(DatabaseType.MySQL, "date")]
    [Type(DatabaseType.SQLite, "text")]
    [Column("to_date")]
    public abstract DateOnly ToDate { get; }

    [Relation("employees", "emp_no", "salaries_ibfk_1")]
    public abstract Employee employees { get; }

}

================
File: src/DataLinq.Tests.Models/employees/gen/Tables/titles.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Employees;

public partial interface Ititles
{
}

[Table("titles")]
[Interface<Ititles>]
public abstract partial class Titles(RowData rowData, DataSourceAccess dataSource) : Immutable<Titles, EmployeesDb>(rowData, dataSource), ITableModel<EmployeesDb>
{
    [PrimaryKey]
    [ForeignKey("employees", "emp_no", "titles_ibfk_1")]
    [Type(DatabaseType.MySQL, "int", 11)]
    [Type(DatabaseType.SQLite, "integer")]
    [Column("emp_no")]
    public abstract int emp_no { get; }

    [PrimaryKey]
    [Type(DatabaseType.MySQL, "date")]
    [Type(DatabaseType.SQLite, "text")]
    [Column("from_date")]
    public abstract DateOnly from_date { get; }

    [PrimaryKey]
    [Type(DatabaseType.MySQL, "varchar", 50)]
    [Type(DatabaseType.SQLite, "text")]
    [Column("title")]
    public abstract string title { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "date")]
    [Type(DatabaseType.SQLite, "text")]
    [Column("to_date")]
    public abstract DateOnly? to_date { get; }

    [Relation("employees", "emp_no", "titles_ibfk_1")]
    public abstract Employee employees { get; }

}

================
File: src/DataLinq.Tests.Models/employees/gen/Views/current_dept_emp.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Employees;

public partial interface Icurrent_dept_emp
{
}

[Definition("select `l`.`emp_no` AS `emp_no`,`d`.`dept_no` AS `dept_no`,`l`.`from_date` AS `from_date`,`l`.`to_date` AS `to_date` from (`dept-emp` `d` join `dept_emp_latest_date` `l` on(`d`.`emp_no` = `l`.`emp_no` and `d`.`from_date` = `l`.`from_date` and `l`.`to_date` = `d`.`to_date`))")]
[View("current_dept_emp")]
[Interface<Icurrent_dept_emp>]
public abstract partial class current_dept_emp(RowData rowData, DataSourceAccess dataSource) : Immutable<current_dept_emp, EmployeesDb>(rowData, dataSource), IViewModel<EmployeesDb>
{
    [Type(DatabaseType.MySQL, "char", 4)]
    [Column("dept_no")]
    public abstract string dept_no { get; }

    [Type(DatabaseType.MySQL, "int", 11)]
    [Column("emp_no")]
    public abstract int emp_no { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "date")]
    [Column("from_date")]
    public abstract DateOnly? from_date { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "date")]
    [Column("to_date")]
    public abstract DateOnly? to_date { get; }

}

================
File: src/DataLinq.Tests.Models/employees/gen/Views/dept_emp_latest_date.cs
================
using System;
using DataLinq;
using DataLinq.Attributes;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Mutation;

namespace DataLinq.Tests.Models.Employees;

public partial interface Idept_emp_latest_date
{
}

[Definition("select `dept-emp`.`emp_no` AS `emp_no`,max(`dept-emp`.`from_date`) AS `from_date`,max(`dept-emp`.`to_date`) AS `to_date` from `dept-emp` group by `dept-emp`.`emp_no`")]
[View("dept_emp_latest_date")]
[Interface<Idept_emp_latest_date>]
public abstract partial class dept_emp_latest_date(RowData rowData, DataSourceAccess dataSource) : Immutable<dept_emp_latest_date, EmployeesDb>(rowData, dataSource), IViewModel<EmployeesDb>
{
    [Type(DatabaseType.MySQL, "int", 11)]
    [Column("emp_no")]
    public abstract int emp_no { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "date")]
    [Column("from_date")]
    public abstract DateOnly? from_date { get; }

    [Nullable]
    [Type(DatabaseType.MySQL, "date")]
    [Column("to_date")]
    public abstract DateOnly? to_date { get; }

}

================
File: src/DataLinq.Tests.Models/employees/partials/IDepartmentWithChangedName.cs
================
using DataLinq.Instances;

namespace DataLinq.Tests.Models.Employees;

public partial interface IDepartmentWithChangedName : IModelInstance<EmployeesDb> { }

public abstract partial class Department
{
    public string NameTest { get; }
}

================
File: src/DataLinq.Tests.Models/employees/partials/IEmployee.cs
================
using DataLinq.Instances;

namespace DataLinq.Tests.Models.Employees;

public partial class Employee
{
    public string Name => $"{first_name} {last_name}";
}

================
File: src/DataLinq.Tests.Models/employees/src/Tables/IDepartment.cs
================
//using System.Collections.Generic;
//using DataLinq.Attributes;
//using DataLinq.Interfaces;

//namespace DataLinq.Tests.Models.Employees;

//[Table("departments")]
//public interface IDepartment : ICustomTableModel
//{
//    [Column("dept_no")]
//    public string DeptNo { get; set; }

//    [Relation("dept-emp", "dept_no")]
//    public IEnumerable<Dept_emp> DepartmentEmployees { get; }

//    [Relation("dept_manager", "dept_fk")]
//    public IEnumerable<IManager> Managers { get; }

//    [Column("dept_name")]
//    public string Name { get; set; }

//    public string ToString()
//    {
//        return $"Department: {DeptNo}";
//    }
//}

================
File: src/DataLinq.Tests.Models/employees/src/Tables/IEmployee.cs
================
//using DataLinq.Attributes;
//using DataLinq.Interfaces;

//namespace DataLinq.Tests.Models.Employees;

//[Table("employees")]
//public interface IEmployee : ICustomTableModel
//{
//}

================
File: src/DataLinq.Tests.Models/employees/src/Tables/IManager.cs
================
//using DataLinq.Attributes;
//using DataLinq.Interfaces;

//namespace DataLinq.Tests.Models.Employees;

public enum ManagerType
{
    Unknown,
    Manager,
    AssistantManager,
    FestiveManager
}


//[Table("dept_manager")]
//public interface IManager : ICustomTableModel
//{
//    [Relation("departments", "dept_no")]
//    public IDepartment Department { get; }
//}

================
File: src/DataLinq.Tests/BaseTests.cs
================
using System.Collections.Generic;

namespace DataLinq.Tests;

public abstract class BaseTests
{
    public static DatabaseFixture Fixture { get; }

    static BaseTests()
    {
        Fixture = new DatabaseFixture();
    }

    public BaseTests()
    {
    }

    public static IEnumerable<object[]> GetEmployees()
    {
        foreach (var db in Fixture.AllEmployeesDb)
            yield return new object[] { db };
    }

    public static IEnumerable<object[]> GetEmployeeConnections()
    {
        foreach (var db in Fixture.EmployeeConnections)
            yield return new object[] { db };
    }
}

================
File: src/DataLinq.Tests/CacheTests.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Attributes;
using DataLinq.Tests.Models;
using DataLinq.Tests.Models.Employees;
using Xunit;

namespace DataLinq.Tests;

public class SharedSetup
{
    public Employee TestEmployee { get; }
    public int TestEmployeeDeptCount { get; }
    public int Dept2Count { get; }
    public int Dept6Count { get; }
    public int Dept7Count { get; }


    public SharedSetup(Database<EmployeesDb> employeesDb)
    {
        TestEmployee = employeesDb.Query().Employees.Single(x => x.emp_no == 1010);
        TestEmployeeDeptCount = TestEmployee.dept_emp.Count();
        Dept2Count = employeesDb.Query().Departments.Single(x => x.DeptNo == "d002").DepartmentEmployees.Count();
        Dept6Count = employeesDb.Query().Departments.Single(x => x.DeptNo == "d006").DepartmentEmployees.Count();
        Dept7Count = employeesDb.Query().Departments.Single(x => x.DeptNo == "d007").DepartmentEmployees.Count();

        employeesDb.Provider.State.ClearCache();
    }
}

public class CacheTests
{
    public static DatabaseFixture fixture;

    static CacheTests()
    {
        fixture = new DatabaseFixture();
    }

    public static IEnumerable<object[]> GetEmployees()
    {
        foreach (var db in fixture.AllEmployeesDb)
            yield return new object[] { db };
    }

    public CacheTests()
    {
        foreach (var employeesDb in fixture.AllEmployeesDb)
        {
            employeesDb.Provider.State.ClearCache();
        }
    }


    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void CheckRowDuplicates(Database<EmployeesDb> employeesDb)
    {
        var setup = new SharedSetup(employeesDb);

        for (var i = 0; i < 10; i++)
        {
            var employee = employeesDb.Query().Employees.Single(x => x.emp_no == setup.TestEmployee.emp_no);

            Assert.NotNull(employee);
            Assert.NotEmpty(employee.dept_emp);
            Assert.Equal(setup.TestEmployeeDeptCount, employee.dept_emp.Count());

            var dept = employeesDb.Query().Departments.Single(x => x.DeptNo == "d002");
            Assert.NotNull(dept);
            Assert.NotEmpty(dept.DepartmentEmployees);
            Assert.True(dept.DepartmentEmployees.Count() > 0);
            Assert.Equal(setup.Dept2Count, dept.DepartmentEmployees.Count());

            var dept6 = employeesDb.Query().Departments.Single(x => x.DeptNo == "d006");
            Assert.NotNull(dept6);
            Assert.NotEmpty(dept6.DepartmentEmployees);
            Assert.Equal(setup.Dept6Count, dept6.DepartmentEmployees.Count());

            var table = employeesDb.Provider.Metadata
                .TableModels.Single(x => x.Table.DbName == "dept-emp").Table;

            Assert.Equal(setup.Dept2Count + setup.Dept6Count + 2 - 1, employeesDb.Provider.GetTableCache(table).RowCount);
        }
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void TimeLimit(Database<EmployeesDb> employeesDb)
    {
        var setup = new SharedSetup(employeesDb);

        var table = employeesDb.Provider.Metadata
                .TableModels.Single(x => x.Table.DbName == "dept-emp").Table;

        var cache = employeesDb.Provider.GetTableCache(table);
        cache.ClearRows();

        var employee = employeesDb.Query().Employees.Single(x => x.emp_no == setup.TestEmployee.emp_no);
        Assert.Equal(setup.TestEmployeeDeptCount, employee.dept_emp.Count());

        var ticks = DateTime.Now.Ticks;

        var dept = employeesDb.Query().Departments.Single(x => x.DeptNo == "d002");
        Assert.Equal(setup.Dept2Count, dept.DepartmentEmployees.Count());

        var ticks2 = DateTime.Now.Ticks;

        var dept6 = employeesDb.Query().Departments.Single(x => x.DeptNo == "d006");
        Assert.Equal(setup.Dept6Count, dept6.DepartmentEmployees.Count());
        Assert.Equal(setup.Dept2Count + setup.Dept6Count + 2 - 1, cache.RowCount);

        var tables = employeesDb.Provider.State.Cache
            .RemoveRowsInsertedBeforeTick(ticks)
            .OrderBy(x => x.numRows)
            .ToList();

        Assert.Equal(2, tables.Count);
        Assert.Equal("employees", tables[1].table.Table.DbName);
        Assert.Equal(1, tables[1].numRows);
        Assert.Equal("dept-emp", tables[0].table.Table.DbName);
        Assert.Equal(1, tables[0].numRows);
        Assert.Equal(setup.Dept2Count + setup.Dept6Count, cache.RowCount);

        tables = employeesDb.Provider.State.Cache
            .RemoveRowsInsertedBeforeTick(ticks2)
            .OrderBy(x => x.numRows)
            .ToList();

        Assert.Equal(2, tables.Count);
        Assert.Equal("departments", tables[0].table.Table.DbName);
        Assert.Equal(1, tables[0].numRows);
        Assert.Equal("dept-emp", tables[1].table.Table.DbName);
        Assert.Equal(setup.Dept2Count, tables[1].numRows);
        Assert.Equal(setup.Dept6Count, cache.RowCount);

        tables = employeesDb.Provider.State.Cache
            .RemoveRowsInsertedBeforeTick(DateTime.Now.Ticks)
            .OrderBy(x => x.numRows)
            .ToList();

        Assert.Equal(2, tables.Count);
        Assert.Equal("departments", tables[0].table.Table.DbName);
        Assert.Equal(1, tables[0].numRows);
        Assert.Equal("dept-emp", tables[1].table.Table.DbName);
        Assert.Equal(setup.Dept6Count, tables[1].numRows);
        Assert.Equal(0, cache.RowCount);

        tables = employeesDb.Provider.State.Cache
            .RemoveRowsInsertedBeforeTick(DateTime.Now.Ticks)
            .OrderBy(x => x.numRows)
            .ToList();

        Assert.Empty(tables);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void RowLimit(Database<EmployeesDb> employeesDb)
    {
        var setup = new SharedSetup(employeesDb);

        var table = employeesDb.Provider.Metadata
                .TableModels.Single(x => x.Table.DbName == "dept-emp").Table;

        var cache = employeesDb.Provider.GetTableCache(table);
        cache.ClearRows();

        var dept = employeesDb.Query().Departments.Single(x => x.DeptNo == "d007");
        Assert.Equal(setup.Dept7Count, dept.DepartmentEmployees.Count());
        Assert.Equal(setup.Dept7Count, cache.RowCount);

        var tables = employeesDb.Provider.State.Cache
            .RemoveRowsByLimit(CacheLimitType.Rows, 100)
            .OrderBy(x => x.numRows)
            .ToList();

        Assert.Single(tables);
        Assert.Equal("dept-emp", tables[0].table.Table.DbName);
        Assert.Equal(setup.Dept7Count - 100, tables[0].numRows);
        Assert.Equal(100, cache.RowCount);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SizeLimit(Database<EmployeesDb> employeesDb)
    {
        var setup = new SharedSetup(employeesDb);

        var table = employeesDb.Provider.Metadata
                .TableModels.Single(x => x.Table.DbName == "dept-emp").Table;

        var cache = employeesDb.Provider.GetTableCache(table);
        cache.ClearRows();

        var dept = employeesDb.Query().Departments.Single(x => x.DeptNo == "d007");
        Assert.Equal(setup.Dept7Count, dept.DepartmentEmployees.Count());
        Assert.True(cache.TotalBytes > 0);

        var tables = employeesDb.Provider.State.Cache
            .RemoveRowsByLimit(CacheLimitType.Kilobytes, 10)
            .OrderBy(x => x.numRows)
            .ToList();

        Assert.Single(tables);
        Assert.Equal("dept-emp", tables[0].table.Table.DbName);
        Assert.True(tables[0].numRows > 0);
        Assert.True(cache.TotalBytes <= 1024 * 1024);
    }
}

================
File: src/DataLinq.Tests/CoreTests.cs
================
using System;
using System.IO;
using System.Linq;
using DataLinq.Attributes;
using DataLinq.Config;
using DataLinq.Core.Factories;
using DataLinq.Core.Factories.Models;
using DataLinq.Metadata;
using DataLinq.MySql.Models;
using DataLinq.Tests.Models.Employees;
using Microsoft.CodeAnalysis;
using Xunit;

namespace DataLinq.Tests;

public class CoreTests : BaseTests
{
    private static DatabaseDefinition GetDatabaseDefinitionFromFiles(string databaseName, string dir = "DataLinq.Tests.Models")
    {
        var projectRoot = Path.Combine(Directory.GetParent(Environment.CurrentDirectory).Parent.Parent.Parent.FullName, dir);
        var srcPaths = DatabaseFixture.DataLinqConfig.Databases.Single(x => x.Name == databaseName).SourceDirectories
            .Select(x => Path.Combine(projectRoot, x))
            .ToList();

        var metadata = new MetadataFromFileFactory(new MetadataFromFileFactoryOptions { }).ReadFiles("", srcPaths);

        return metadata;
    }

    [Fact]
    public void TestMetadataFromFixture()
    {
        Assert.Equal(2, DatabaseDefinition.LoadedDatabases.Count);
        Assert.Contains(DatabaseDefinition.LoadedDatabases, x => x.Key == typeof(EmployeesDb));
        Assert.Contains(DatabaseDefinition.LoadedDatabases, x => x.Key == typeof(information_schema));
    }

    [Fact]
    public void TestMetadataFromFilesFactory()
    {
        var metadata = GetDatabaseDefinitionFromFiles("employees");

        var employees = metadata.TableModels.Single(x => x.Table.DbName == "employees").Table;
        Assert.Equal("Employee", employees.Model.CsType.Name);
        Assert.Single(employees.Model.OriginalInterfaces);
        Assert.DoesNotContain(employees.Model.OriginalInterfaces, x => x.Name == "IEmployee");
        Assert.Contains(employees.Model.OriginalInterfaces, x => x.Name == "ITableModel<EmployeesDb>");
        Assert.DoesNotContain(employees.Model.OriginalInterfaces, x => x.Name.StartsWith("Immutable"));

        Assert.NotNull(employees.Model.ModelInstanceInterface);
        Assert.Equal("IEmployee", employees.Model.ModelInstanceInterface.Value.Name);

        var departments = metadata.TableModels.Single(x => x.Table.DbName == "departments").Table;
        Assert.Equal("Department", departments.Model.CsType.Name);
        Assert.NotNull(departments.Model.ModelInstanceInterface);
        Assert.Equal("IDepartmentWithChangedName", departments.Model.ModelInstanceInterface.Value.Name);

        TestDatabaseAttributes(metadata);
        TestDatabase(metadata, false);
    }

    [Fact]
    public void TestMetadataFromInterfaceFactory()
    {
        var metadata = MetadataFromTypeFactory.ParseDatabaseFromDatabaseModel(typeof(EmployeesDb));

        var employees = metadata.TableModels.Single(x => x.Table.DbName == "employees").Table;
        Assert.Equal("Employee", employees.Model.CsType.Name);
        Assert.True(employees.Model.OriginalInterfaces.Length > 1);
        Assert.DoesNotContain(employees.Model.OriginalInterfaces, x => x.Name == "IEmployee");
        Assert.Contains(employees.Model.OriginalInterfaces, x => x.Name == "ITableModel<EmployeesDb>");
        Assert.DoesNotContain(employees.Model.OriginalInterfaces, x => x.Name.StartsWith("Immutable"));

        Assert.NotNull(employees.Model.ModelInstanceInterface);
        Assert.Equal("IEmployee", employees.Model.ModelInstanceInterface.Value.Name);

        //var departments = metadata.TableModels.Single(x => x.Table.DbName == "departments").Table;
        //Assert.Equal("Department", departments.Model.CsType.Name);
        //Assert.Single(departments.Model.ModelInstanceInterfaces);
        //Assert.Equal("IDepartmentWithChangedName", departments.Model.ModelInstanceInterfaces.Single().Name);

        TestDatabaseAttributes(metadata);
        TestDatabase(metadata, true);
    }

    [Theory]
    [MemberData(nameof(GetEmployeeConnections))]
    public void TestMetadataFromSqlFactory(DataLinqDatabaseConnection connection)
    {
        var factory = PluginHook.MetadataFromSqlFactories[connection.Type]
            .GetMetadataFromSqlFactory(new MetadataFromDatabaseFactoryOptions());

        var metadata = factory.ParseDatabase("employees", "Employees", "DataLinq.Tests.Models.Employees", connection.DataSourceName, connection.ConnectionString.Original).Value;

        var employees = metadata.TableModels.Single(x => x.Table.DbName == "employees").Table;
        Assert.Equal("employees", employees.Model.CsType.Name);

        TestDatabase(metadata, false);
    }

    [Theory]
    [MemberData(nameof(GetEmployeeConnections))]
    public void TestMetadataFromSqlAndMergeWithFiles(DataLinqDatabaseConnection connection)
    {
        var factory = PluginHook.MetadataFromSqlFactories[connection.Type]
            .GetMetadataFromSqlFactory(new MetadataFromDatabaseFactoryOptions());

        var metadataDB = factory.ParseDatabase("employees", "Employees", "DataLinq.Tests.Models.Employees", connection.DataSourceName, connection.ConnectionString.Original).Value;

        var metadataFiles = GetDatabaseDefinitionFromFiles("employees");

        var transformer = new MetadataTransformer(new MetadataTransformerOptions());
        transformer.TransformDatabase(metadataFiles, metadataDB);

        Assert.Equal("EmployeesDb", metadataDB.CsType.Name);
        Assert.Equal("Department", metadataDB.TableModels.Single(x => x.CsPropertyName == "Departments").Model.CsType.Name);

        var employees = metadataDB.TableModels.Single(x => x.Table.DbName == "employees").Table;
        Assert.Equal("Employee", employees.Model.CsType.Name);

        TestDatabase(metadataDB, false);
    }

    private void TestDatabaseAttributes(DatabaseDefinition database)
    {
        Assert.Equal(2, database.CacheLimits.Count);
        Assert.Equal(CacheLimitType.Megabytes, database.CacheLimits[0].limitType);
        Assert.Equal(200, database.CacheLimits[0].amount);
        Assert.Equal(CacheLimitType.Minutes, database.CacheLimits[1].limitType);
        Assert.Equal(60, database.CacheLimits[1].amount);

        Assert.Single(database.CacheCleanup);
        Assert.Equal(CacheCleanupType.Minutes, database.CacheCleanup[0].cleanupType);
        Assert.Equal(30, database.CacheCleanup[0].amount);

        Assert.Single(database.CacheCleanup);
    }

    private void TestDatabase(DatabaseDefinition database, bool testCsType)
    {
        Assert.NotEmpty(database.TableModels);
        Assert.Equal(8, database.TableModels.Length);
        Assert.Equal(2, database.TableModels.Count(x => x.Table.Type == TableType.View));
        Assert.Equal(12, database.TableModels.Sum(x => x.Model.RelationProperties.Count()));
        Assert.Contains(database.TableModels, x => x.Table.Columns.Any(y => y.ColumnIndices.Any(z => z.RelationParts.Any())));

        var employees = database.TableModels.Single(x => x.Table.DbName == "employees").Table;
        Assert.Same(employees, employees.Model.Table);
        Assert.Equal("employees", employees.DbName);
        Assert.Equal(7, employees.Columns.Length);
        Assert.Equal(1, employees.Columns.Count(x => x.PrimaryKey));
        Assert.Equal(1, employees.Columns.Count(x => x.AutoIncrement));


        var emp_no = employees.Columns.Single(x => x.DbName == "emp_no");
        Assert.True(emp_no.PrimaryKey);
        Assert.True(emp_no.AutoIncrement);

        Assert.NotEmpty(emp_no.DbTypes);

        if (emp_no.DbTypes.Any(x => x.DatabaseType == DatabaseType.MySQL))
            Assert.Equal("int", emp_no.DbTypes.Single(x => x.DatabaseType == DatabaseType.MySQL).Name);

        if (emp_no.DbTypes.Any(x => x.DatabaseType == DatabaseType.SQLite))
            Assert.Equal("integer", emp_no.DbTypes.Single(x => x.DatabaseType == DatabaseType.SQLite).Name);

        Assert.Equal("int", emp_no.ValueProperty.CsType.Name);

        var dept_name = database.TableModels.Single(x => x.Table.DbName == "departments").Table.Columns.Single(x => x.DbName == "dept_name");
        Assert.Equal("string", dept_name.ValueProperty.CsType.Name);
        Assert.False(dept_name.PrimaryKey);
        Assert.False(dept_name.AutoIncrement);
        Assert.Single(dept_name.ColumnIndices);
        Assert.Equal(IndexCharacteristic.Unique, dept_name.ColumnIndices.Single().Characteristic);
        Assert.Equal("dept_name", dept_name.ColumnIndices.Single().Name);
        Assert.Same(dept_name, dept_name.ColumnIndices.First().Columns.Single());

        if (testCsType)
        {
            Assert.Equal(typeof(int), emp_no.ValueProperty.CsType.Type);
            Assert.DoesNotContain(database.TableModels, x => x.Model.CsType.Type == null);
        }
    }
}

================
File: src/DataLinq.Tests/DatabaseFixture.cs
================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Bogus;
using DataLinq.Config;
using DataLinq.Metadata;
using DataLinq.MySql;
using DataLinq.MySql.Models;
using DataLinq.SQLite;
using DataLinq.Tests.Models;
using DataLinq.Tests.Models.Employees;
using Microsoft.Extensions.Logging;
using Serilog;
using Xunit;

namespace DataLinq.Tests;

public class DatabaseFixture : IDisposable
{
    static DatabaseFixture()
    {
        MySQLProvider.RegisterProvider();
        SQLiteProvider.RegisterProvider();

        DataLinqConfig = DataLinqConfig.FindAndReadConfigs($"{Directory.GetCurrentDirectory()}{Path.DirectorySeparatorChar}datalinq.json", _ => { });
    }

    public DatabaseFixture()
    {
        var employees = DataLinqConfig.Databases.Single(x => x.Name == "employees");

        EmployeeConnections = employees.Connections;
        var lockObject = new object();

        // Configure Serilog
        Log.Logger = new LoggerConfiguration()
            .MinimumLevel.Debug()
            .WriteTo.File("D:\\git\\DataLinq\\logs\\tests.txt", rollingInterval: RollingInterval.Day, flushToDiskInterval: TimeSpan.FromSeconds(1))
            .CreateLogger();

        // Set up logging with Serilog
        var loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.ClearProviders();
            builder.AddSerilog();
        });

        //var loggerFactory = LoggerFactory.Create(builder => builder.AddDebug().SetMinimumLevel(LogLevel.Debug));

        foreach (var connection in employees.Connections)
        {
            var provider = PluginHook.DatabaseProviders.Single(x => x.Key == connection.Type).Value;
            provider.UseLoggerFactory(loggerFactory);

            var dbEmployees = provider.GetDatabaseProvider<EmployeesDb>(connection.ConnectionString.Original, connection.DataSourceName);

            lock (lockObject)
            {
                if (!dbEmployees.FileOrServerExists() || !dbEmployees.Exists())
                {
                    var result = PluginHook.CreateDatabaseFromMetadata(connection.Type,
                        dbEmployees.Provider.Metadata, connection.DataSourceName, connection.ConnectionString.Original, true);

                    if (result.HasFailed)
                        Assert.Fail(result.Failure.ToString());
                }

                if (!dbEmployees.Query().Employees.Any())
                {
                    FillEmployeesWithBogusData(dbEmployees);
                }
            }

            AllEmployeesDb.Add(dbEmployees);
        }

        information_schema = new MySqlDatabase<information_schema>(EmployeeConnections.Single(x => x.Type == DatabaseType.MySQL).ConnectionString.Original);
    }

    public static DataLinqConfig DataLinqConfig { get; set; }
    public List<DataLinqDatabaseConnection> EmployeeConnections { get; set; } = new();
    public List<Database<EmployeesDb>> AllEmployeesDb { get; set; } = new();
    public MySqlDatabase<information_schema> information_schema { get; set; }

    public void FillEmployeesWithBogusData(Database<EmployeesDb> database)
    {
        Randomizer.Seed = new Random(59345922);

        var numEmployees = 10000;
        using var transaction = database.Transaction();

        var employeeFaker = new Faker<MutableEmployee>()
            .StrictMode(false)
            .RuleFor(x => x.first_name, x => x.Person.FirstName)
            .RuleFor(x => x.last_name, x => x.Person.LastName)
            .RuleFor(x => x.birth_date, x => DateOnly.FromDateTime(x.Person.DateOfBirth.Date))
            .RuleFor(x => x.hire_date, x => x.Date.PastDateOnly(20))
            .RuleFor(x => x.gender, x => (Employee.Employeegender)(((int)x.Person.Gender) + 1));
        var employees = transaction.Insert(employeeFaker.Generate(numEmployees));

        var deptNo = 1;
        var departmentFaker = new Faker<MutableDepartment>()
            .StrictMode(false)
            .RuleFor(x => x.DeptNo, x => $"d{deptNo++:000}")
            .RuleFor(x => x.Name, x => x.Commerce.Department());
        var departments = transaction.Insert(departmentFaker.Generate(20));

        var empNo = 0;
        var dept_empFaker = new Faker<MutableDept_emp>()
           .StrictMode(false)
           .RuleFor(x => x.from_date, x => x.Date.PastDateOnly(20))
           .RuleFor(x => x.to_date, x => x.Date.PastDateOnly(20))
           .RuleFor(x => x.emp_no, x => employees[empNo++].emp_no)
           .RuleFor(x => x.dept_no, x => x.PickRandom(departments).DeptNo);
        transaction.Insert(dept_empFaker.Generate(numEmployees));

        empNo = 0;
        var titlesFaker = new Faker<MutableTitles>()
           .StrictMode(false)
           .RuleFor(x => x.from_date, x => x.Date.PastDateOnly(20))
           .RuleFor(x => x.to_date, x => x.Date.PastDateOnly(20))
           .RuleFor(x => x.emp_no, x => employees[empNo++].emp_no)
           .RuleFor(x => x.title, x => x.Name.JobTitle());
        transaction.Insert(titlesFaker.Generate(numEmployees));

        empNo = 0;
        var salariesFaker = new Faker<MutableSalaries>()
           .StrictMode(false)
           .RuleFor(x => x.FromDate, x => x.Date.PastDateOnly(20))
           .RuleFor(x => x.ToDate, x => x.Date.PastDateOnly(20))
           .RuleFor(x => x.emp_no, x => employees[empNo++].emp_no)
           .RuleFor(x => x.salary, x => (int)x.Finance.Amount(10000, 200000, 0));
        transaction.Insert(salariesFaker.Generate(numEmployees));

        var dept_managerFaker = new Faker<MutableManager>()
           .StrictMode(false)
           .RuleFor(x => x.from_date, x => x.Date.PastDateOnly(20))
           .RuleFor(x => x.to_date, x => x.Date.PastDateOnly(20))
           .RuleFor(x => x.Type, x => x.PickRandom<ManagerType>())
           .RuleFor(x => x.emp_no, x => x.PickRandom(employees).emp_no)
           .RuleFor(x => x.dept_fk, x => x.PickRandom(departments).DeptNo);

        var dept_managers = dept_managerFaker.Generate(numEmployees / 10);

        foreach (var dm in dept_managers)
        {
            if (!transaction.Query().Managers.Any(x => x.dept_fk == dm.dept_fk && x.emp_no == dm.emp_no))
                transaction.Insert(dm);
        }

        transaction.Commit();
    }

    public void Dispose()
    {
        foreach (var db in AllEmployeesDb)
            db.Dispose();

        information_schema.Dispose();
    }
}

================
File: src/DataLinq.Tests/Extensions/Helpers/LinqExtensions.cs
================
using System;
using System.Collections.Generic;

namespace DataLinq.Extensions.Helpers;

internal static class LinqExtensions
{
    internal static string ToJoinedString<T>(this IEnumerable<T> source, string separator = "\n") =>
        string.Join(separator, source);

    //https://stackoverflow.com/a/11463800
    internal static IEnumerable<List<T>> SplitList<T>(this List<T> locations, int nSize = 30)
    {
        for (int i = 0; i < locations.Count; i += nSize)
        {
            yield return locations.GetRange(i, Math.Min(nSize, locations.Count - i));
        }
    }

    internal static IEnumerable<T> Yield<T>(this T item)
    {
#pragma warning disable RCS1165 // Unconstrained type parameter checked for null.
        if (item != null)
#pragma warning restore RCS1165 // Unconstrained type parameter checked for null.
            yield return item;
    }
}

================
File: src/DataLinq.Tests/Extensions/Helpers/QueryExtensions.cs
================
using DataLinq.Query;

namespace DataLinq.Extensions.Helpers;

internal static class QueryExtensions
{
    internal static string ToSql(this Relation relation)
    {
        switch (relation)
        {
            case Relation.Equal:
                return "=";

            case Relation.EqualNull:
                return "IS";

            case Relation.NotEqual:
                return "<>";

            case Relation.NotEqualNull:
                return "IS NOT";

            case Relation.Like:
                return "LIKE";

            case Relation.GreaterThan:
                return ">";

            case Relation.GreaterThanOrEqual:
                return ">=";

            case Relation.LessThan:
                return "<";

            case Relation.LessThanOrEqual:
                return "<=";

            case Relation.In:
                return "IN";

            case Relation.NotIn:
                return "NOT IN";
        }

        return null;
    }
}

================
File: src/DataLinq.Tests/Extensions/Helpers/StringExtensions.cs
================
using System;

namespace DataLinq.Extensions.Helpers;

internal static class StringExtensions
{
    //https://stackoverflow.com/a/4405876
    internal static string FirstCharToUpper(this string input) =>
        input switch
        {
            null => throw new ArgumentNullException(nameof(input)),
            "" => throw new ArgumentException($"{nameof(input)} cannot be empty", nameof(input)),
            _ => string.Concat(input[0].ToString().ToUpper(), input.Substring(1))
        };
}

================
File: src/DataLinq.Tests/Helpers.cs
================
using System;
using System.Linq;
using DataLinq.Tests.Models;
using DataLinq.Tests.Models.Employees;

namespace DataLinq.Tests;

internal class Helpers
{
    private Random rnd = new Random();
    //private DatabaseFixture fixture { get; }

    public Helpers()
    {
        //this.fixture = fixture;
    }

    public Employee GetEmployee(int? emp_no, Database<EmployeesDb> employeesDb)
    {
        var employee = employeesDb.Query().Employees.SingleOrDefault(x => x.emp_no == emp_no);

        if (employee == null)
            return employeesDb.Insert(NewEmployee(emp_no));

        return employee;
    }

    public MutableEmployee NewEmployee(int? emp_no = null)
    {
        return new MutableEmployee
        {
            birth_date = RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20)),
            emp_no = emp_no,
            first_name = "Test employee",
            last_name = "Test",
            gender = Employee.Employeegender.M,
            hire_date = DateOnly.FromDateTime(DateTime.Now)
        };
    }

    public DateOnly RandomDate(DateTime rangeStart, DateTime rangeEnd)
    {
        TimeSpan span = rangeEnd - rangeStart;

        int randomMinutes = rnd.Next(0, (int)span.TotalMinutes);
        return DateOnly.FromDateTime(rangeStart + TimeSpan.FromMinutes(randomMinutes));
    }
}

================
File: src/DataLinq.Tests/MutationTests.cs
================
using System;
using System.Linq;
using DataLinq.Tests.Models.Employees;
using Xunit;

namespace DataLinq.Tests;

public class MutationTests : BaseTests
{
    private Helpers helpers = new Helpers();

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void TestMutateNull(Database<EmployeesDb> employeesDb)
    {
        Assert.Throws<ArgumentNullException>(() =>
        {
            var employee = employeesDb.Query().Employees
                .Where(x => x.emp_no == 423692592)
                .FirstOrDefault().Mutate();
        });
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void TestMutateNullNew(Database<EmployeesDb> employeesDb)
    {
        var employee = employeesDb.Query().Employees
            .Where(x => x.emp_no == 423692592)
            .FirstOrDefault().MutateOrNew(birth_date: DateOnly.Parse("1990-01-01"), "name", Employee.Employeegender.M, DateOnly.Parse("2022-12-02"), "last name");

        Assert.NotNull(employee);
        Assert.NotEqual(423692592, employee.emp_no);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void Reset_Should_ResetToNewInstance(Database<EmployeesDb> employeesDb)
    {
        // Arrange
        var employee = employeesDb.Query().Employees.First();
        var mutable = new MutableEmployee(employee);

        // Act
        mutable.Reset();

        // Assert
        Assert.False(mutable.IsNew());
        Assert.False(mutable.HasChanges());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void Reset_WithModel_Should_ResetToModelInstance(Database<EmployeesDb> employeesDb)
    {
        // Arrange
        var employee = employeesDb.Query().Employees.First();
        var mutable = new MutableEmployee(employee);
        
        // Act
        mutable.birth_date = DateOnly.Parse("1990-01-01");
        mutable.Reset(employee);

        // Assert
        Assert.Equal(employee.birth_date, mutable.birth_date);
        Assert.False(mutable.HasChanges());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void Reset_WithRowData_Should_ResetToRowDataInstance(Database<EmployeesDb> employeesDb)
    {
        // Arrange
        var employee = employeesDb.Query().Employees.First();
        var rowData = employee.GetRowData();
        var mutable = new MutableEmployee(employee);

        // Act
        mutable.birth_date = DateOnly.Parse("1990-01-01");
        mutable.Reset(rowData);

        // Assert
        Assert.Equal(employee.birth_date, mutable.birth_date);
        Assert.False(mutable.HasChanges());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void TestMutationSave_Should_NotHaveChanges(Database<EmployeesDb> employeesDb)
    {
        // Arrange
        var emp_no = 998999;
        var newBirthDate = DateOnly.FromDateTime(DateTime.Now.AddYears(Random.Shared.Next(0, 50) * -1).AddDays(Random.Shared.Next(0, 365) * -1));
        var employee = helpers.GetEmployee(emp_no, employeesDb);
        var mutable = employee.Mutate();

        // Act
        mutable.birth_date = newBirthDate;
        var dbEmployee = mutable.Save(employeesDb);

        // Assert
        Assert.False(mutable.HasChanges());
        Assert.NotEqual(newBirthDate, employee.birth_date);
        Assert.Equal(newBirthDate, dbEmployee.birth_date);
        Assert.Equal(newBirthDate, mutable.birth_date);
        Assert.False(mutable.IsNew());
        Assert.False(mutable.HasChanges());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void TestMutation_Should_HaveChanges(Database<EmployeesDb> employeesDb)
    {
        // Arrange
        var emp_no = 998998;
        var newBirthDate = DateOnly.Parse("1990-01-01");
        var employee = helpers.GetEmployee(emp_no, employeesDb);
        var mutable = employee.Mutate();

        // Act
        mutable.birth_date = newBirthDate;

        // Assert
        Assert.True(mutable.HasChanges());
    }
}

================
File: src/DataLinq.Tests/QueryTests.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using DataLinq.Instances;
using DataLinq.Tests.Models;
using DataLinq.Tests.Models.Employees;
using Xunit;

namespace DataLinq.Tests;

public class QueryTests : BaseTests
{
    private string lastDepartmentName;

    private void SharedSetup(Database<EmployeesDb> employeesDb)
    {
        lastDepartmentName = $"d{employeesDb.Query().Departments.Count():000}";
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void ToList(Database<EmployeesDb> employeesDb)
    {
        Assert.True(10 < employeesDb.Query().Departments.ToList().Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void ToListView(Database<EmployeesDb> employeesDb)
    {
        Assert.NotEmpty(employeesDb.Query().current_dept_emp.ToList());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void Count(Database<EmployeesDb> employeesDb)
    {
        Assert.True(10 < employeesDb.Query().Departments.Count());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void CountView(Database<EmployeesDb> employeesDb)
    {
        Assert.NotEqual(0, employeesDb.Query().dept_emp_latest_date.Count());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void StaticGet(Database<EmployeesDb> employeesDb)
    {
        var dep = employeesDb.Get<Department>(new StringKey("d005"));
        Assert.NotNull(dep);
        Assert.Equal("d005", dep.DeptNo);
        Assert.Same(employeesDb.Provider, dep.GetDataSource().Provider);

        dep = employeesDb.Get<Department>(new StringKey("xxxx"));
        Assert.Null(dep);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhere(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Departments.Where(x => x.DeptNo == "d005").ToList();
        Assert.Single(where);
        Assert.Equal("d005", where[0].DeptNo);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereReverse(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Departments.Where(x => "d005" == x.DeptNo).ToList();
        Assert.Single(where);
        Assert.Equal("d005", where[0].DeptNo);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereNot(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Departments.Where(x => x.DeptNo != "d005").ToList();
        Assert.Equal(employeesDb.Query().Departments.Count() - 1, where.Count);
        Assert.DoesNotContain(where, x => x.DeptNo == "d005");
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereStartsWith(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Departments.Where(x => x.DeptNo.StartsWith("d00")).ToList();
        Assert.Equal(9, where.Count);
        Assert.DoesNotContain(where, x => x.DeptNo == "d010");
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereStartsWithAndToList(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => x.dept_fk.StartsWith("d00") && x.from_date > DateOnly.Parse("2010-01-01")).ToList();
        Assert.Equal(employeesDb.Query().Managers.ToList().Count(x => x.dept_fk.StartsWith("d00") && x.from_date > DateOnly.Parse("2010-01-01")), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereNotStartsWithAndToList(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => !x.dept_fk.StartsWith("d00") && x.from_date > DateOnly.Parse("2010-01-01")).ToList();
        Assert.Equal(employeesDb.Query().Managers.ToList().Count(x => !x.dept_fk.StartsWith("d00") && x.from_date > DateOnly.Parse("2010-01-01")), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereNotStartsWithAndStartsWithAndToList(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => !x.dept_fk.StartsWith("d00") && x.dept_fk.EndsWith("2") && x.from_date > DateOnly.Parse("2010-01-01")).ToList();
        Assert.Equal(employeesDb.Query().Managers.ToList().Count(x => !x.dept_fk.StartsWith("d00") && x.dept_fk.EndsWith("2") && x.from_date > DateOnly.Parse("2010-01-01")), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereNotStartsWithAndStartsWithAndNotToList(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => !x.dept_fk.StartsWith("d00") && x.dept_fk.EndsWith("2") && !(x.from_date > DateOnly.Parse("2010-01-01"))).ToList();
        Assert.Equal(employeesDb.Query().Managers.ToList().Count(x => !x.dept_fk.StartsWith("d00") && x.dept_fk.EndsWith("2") && !(x.from_date > DateOnly.Parse("2010-01-01"))), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereNotStartsWithAndGroupNotStartsWithToList(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => !x.dept_fk.StartsWith("d00") && !(x.dept_fk.EndsWith("2") && (x.from_date > DateOnly.Parse("2010-01-01")))).ToList();
        Assert.Equal(employeesDb.Query().Managers.ToList().Count(x => !x.dept_fk.StartsWith("d00") && !(x.dept_fk.EndsWith("2") && (x.from_date > DateOnly.Parse("2010-01-01")))), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereNotStartsWithAndGroupNotStartsWithAndNotToList(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => !x.dept_fk.StartsWith("d00") && !(x.dept_fk.EndsWith("2") && !(x.from_date > DateOnly.Parse("2010-01-01")))).ToList();
        Assert.Equal(employeesDb.Query().Managers.ToList().Count(x => !x.dept_fk.StartsWith("d00") && !(x.dept_fk.EndsWith("2") && !(x.from_date > DateOnly.Parse("2010-01-01")))), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereNotStartsWithOrGroupNotStartsWithToList(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => !x.dept_fk.StartsWith("d00") || !(x.dept_fk.EndsWith("2") && (x.from_date > DateOnly.Parse("2010-01-01")))).ToList();
        Assert.Equal(employeesDb.Query().Managers.ToList().Count(x => !x.dept_fk.StartsWith("d00") || !(x.dept_fk.EndsWith("2") && (x.from_date > DateOnly.Parse("2010-01-01")))), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereNotStartsWithAndGroupNotStartsWithOrNotToList(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => !x.dept_fk.StartsWith("d00") && !(x.dept_fk.EndsWith("2") || !(x.from_date > DateOnly.Parse("2010-01-01")))).ToList();
        Assert.Equal(employeesDb.Query().Managers.ToList().Count(x => !x.dept_fk.StartsWith("d00") && !(x.dept_fk.EndsWith("2") || !(x.from_date > DateOnly.Parse("2010-01-01")))), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereNotStartsWithOrGroupNotStartsWithOrNotToList(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => !x.dept_fk.StartsWith("d00") || !(x.dept_fk.EndsWith("2") || !(x.from_date > DateOnly.Parse("2010-01-01")))).ToList();
        Assert.Equal(employeesDb.Query().Managers.ToList().Count(x => !x.dept_fk.StartsWith("d00") || !(x.dept_fk.EndsWith("2") || !(x.from_date > DateOnly.Parse("2010-01-01")))), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereTwoPropertiesEquals(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => x.emp_no == x.emp_no).ToList();
        Assert.Equal(employeesDb.Query().Managers.ToList().Where(x => x.emp_no == x.emp_no).Count(), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereTwoPropertiesNotEquals(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => x.emp_no != x.emp_no).ToList();
        Assert.Equal(employeesDb.Query().Managers.ToList().Where(x => x.emp_no != x.emp_no).Count(), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereIntEnumEqualsBackwards(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => ManagerType.FestiveManager == x.Type).ToList();
        Assert.Equal(employeesDb.Query().Managers.ToList().Where(x => ManagerType.FestiveManager == x.Type).Count(), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereIntEnumNotEqualsBackwards(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => ManagerType.AssistantManager != x.Type).ToList();
        Assert.Equal(employeesDb.Query().Managers.ToList().Where(x => ManagerType.AssistantManager != x.Type).Count(), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereIntEnumEquals(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => x.Type == ManagerType.FestiveManager).ToList();
        Assert.Equal(employeesDb.Query().Managers.ToList().Where(x => x.Type == ManagerType.FestiveManager).Count(), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereIntEnumNotEquals(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => x.Type != ManagerType.AssistantManager).ToList();
        Assert.Equal(employeesDb.Query().Managers.ToList().Where(x => x.Type != ManagerType.AssistantManager).Count(), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereValueEnumTypeEquals(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Employees.Where(x => x.gender == Employee.Employeegender.M).ToList();
        Assert.Equal(employeesDb.Query().Employees.ToList().Where(x => x.gender == Employee.Employeegender.M).Count(), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereValueEnumTypeNotEquals(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Employees.Where(x => x.gender != Employee.Employeegender.M).ToList();
        Assert.Equal(employeesDb.Query().Employees.ToList().Where(x => x.gender != Employee.Employeegender.M).Count(), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereValueEqualsNegated(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Employees.Where(x => !(x.gender == Employee.Employeegender.F)).ToList();
        Assert.Equal(employeesDb.Query().Employees.ToList().Where(x => !(x.gender == Employee.Employeegender.F)).Count(), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereValueNotEqualsNegated(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Employees.Where(x => !(x.gender != Employee.Employeegender.F)).ToList();
        Assert.Equal(employeesDb.Query().Employees.ToList().Where(x => !(x.gender != Employee.Employeegender.F)).Count(), where.Count);
    }

    //[Theory]
    //[MemberData(nameof(GetEmployees))]
    //public void SimpleWhereHasValue(Database<EmployeesDb> employeesDb)
    //{
    //    var where = employeesDb.Query().Employees.Where(x => x.gender.HasValue).ToList();
    //    Assert.Equal(employeesDb.Query().Employees.ToList().Where(x => x.gender.HasValue).Count(), where.Count);
    //}

    //[Theory]
    //[MemberData(nameof(GetEmployees))]
    //public void SimpleWhereNotHasValue(Database<EmployeesDb> employeesDb)
    //{
    //    var where = employeesDb.Query().Employees.Where(x => !x.gender.HasValue).ToList();
    //    Assert.Equal(employeesDb.Query().Employees.ToList().Where(x => !x.gender.HasValue).Count(), where.Count);
    //}

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereNotStartsWith(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Departments.Where(x => !x.DeptNo.StartsWith("d00")).ToList();
        Assert.Equal(11, where.Count);
        Assert.DoesNotContain(where, x => x.DeptNo == "d001");
    }


    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereEndsWith(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Departments.Where(x => x.DeptNo.EndsWith("2")).ToList();
        Assert.Equal(2, where.Count);
        Assert.DoesNotContain(where, x => x.DeptNo == "d010");
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereNotEndsWith(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Departments.Where(x => !x.DeptNo.EndsWith("2")).ToList();
        Assert.Equal(18, where.Count);
        Assert.DoesNotContain(where, x => x.DeptNo == "d002");
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereContains(Database<EmployeesDb> employeesDb)
    {
        var ids = new[] { "d001", "d002", "d003" };
        var where = employeesDb.Query().Departments.Where(x => ids.Contains(x.DeptNo)).ToList();

        Assert.Equal(ids.Length, where.Count);
        foreach (var id in ids)
        {
            Assert.Contains(where, x => x.DeptNo == id);
        }
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereNotContains(Database<EmployeesDb> employeesDb)
    {
        var ids = new[] { "d001", "d002", "d003" };
        var where = employeesDb.Query().Departments.Where(x => !ids.Contains(x.DeptNo)).ToList();

        Assert.True(where.Count > ids.Length);
        foreach (var id in ids)
        {
            Assert.DoesNotContain(where, x => x.DeptNo == id);
        }
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereContainsWithList(Database<EmployeesDb> employeesDb)
    {
        var ids = new List<string> { "d001", "d002", "d003" };
        var where = employeesDb.Query().Departments.Where(x => ids.Contains(x.DeptNo)).ToList();

        Assert.Equal(ids.Count, where.Count);
        foreach (var id in ids)
        {
            Assert.Contains(where, x => x.DeptNo == id);
        }
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereContainsWithHashSet(Database<EmployeesDb> employeesDb)
    {
        var ids = new HashSet<string> { "d001", "d002", "d003" };
        var where = employeesDb.Query().Departments.Where(x => ids.Contains(x.DeptNo)).ToList();

        Assert.Equal(ids.Count, where.Count);
        foreach (var id in ids)
        {
            Assert.Contains(where, x => x.DeptNo == id);
        }
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereMultipleContains(Database<EmployeesDb> employeesDb)
    {
        var deptIds = new[] { "d001", "d002", "d003" };
        var empIds = new[] { 5, 2668, 100 };
        var where = employeesDb.Query().DepartmentEmployees
            .Where(x => deptIds.Contains(x.dept_no) && empIds.Contains(x.emp_no))
            .ToList();

        Assert.Equal(deptIds.Length, where.Count);
        foreach (var id in deptIds)
        {
            Assert.Contains(where, x => x.dept_no == id);
        }
        foreach (var id in empIds)
        {
            Assert.Contains(where, x => x.emp_no == id);
        }
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereContainsAndStartsWith(Database<EmployeesDb> employeesDb)
    {
        var deptIds = new[] { "d001", "d002", "d003" };
        var where = employeesDb.Query().DepartmentEmployees
            .Where(x => deptIds.Contains(x.dept_no) && x.dept_no.EndsWith("02"))
            .ToList();

        Assert.Contains(where, x => x.dept_no == "d002");
        Assert.DoesNotContain(where, x => x.dept_no == "d001");
        Assert.DoesNotContain(where, x => x.dept_no == "d003");
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereContainsAndGreaterThan(Database<EmployeesDb> employeesDb)
    {
        var deptIds = new[] { "d001", "d002", "d003" };
        var where = employeesDb.Query().DepartmentEmployees
            .Where(x => deptIds.Contains(x.dept_no) && x.emp_no >= 1000 && x.emp_no <= 2000)
            .ToList();

        Assert.True(where.Count >= deptIds.Length);
        foreach (var id in deptIds)
        {
            Assert.Contains(where, x => x.dept_no == id);
            Assert.DoesNotContain(where, x => x.emp_no < 1000 || x.emp_no > 2000);
        }
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereMultipleContainsAndStartsWith(Database<EmployeesDb> employeesDb)
    {
        var deptIds = new[] { "d001", "d002", "d003" };
        var empIds = new[] { 5, 2668, 100 };
        var where = employeesDb.Query().DepartmentEmployees
            .Where(x => deptIds.Contains(x.dept_no) && empIds.Contains(x.emp_no) && x.dept_no.StartsWith("d"))
            .ToList();

        Assert.Equal(deptIds.Length, where.Count);
        foreach (var id in deptIds)
        {
            Assert.Contains(where, x => x.dept_no == id);
        }
        foreach (var id in empIds)
        {
            Assert.Contains(where, x => x.emp_no == id);
        }
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void TestContainsAndNullableBool(Database<EmployeesDb> employeesDb)
    {
        int?[] empIds = [5, 2668, 10, 100];

        foreach (var title in employeesDb.Query().Employees.Where(x => empIds.Contains(x.emp_no)))
            employeesDb.Update(title, x => x.IsDeleted = null);

        foreach (var title in employeesDb.Query().Employees.Where(x => x.emp_no == 100))
            employeesDb.Update(title, x => x.IsDeleted = true);

        //Should return all rows except the one with emp_no == 100
        var result = employeesDb.Query().Employees
            .Where(x => empIds.Contains(x.emp_no) && x.IsDeleted != true)
            .ToList();

        var resultList = employeesDb.Query().Employees.ToList()
            .Where(x => empIds.Contains(x.emp_no) && x.IsDeleted != true)
            .ToList();

        Assert.NotEmpty(result);
        Assert.DoesNotContain(result, x => x.emp_no == 100);
        Assert.Equal(resultList, result);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereAndToList(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => x.dept_fk == "d004" && x.from_date > DateOnly.Parse("2010-01-01")).ToList();
        Assert.NotEqual(employeesDb.Query().Managers.Count(x => x.dept_fk == "d004"), where.Count);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereAndCount(Database<EmployeesDb> employeesDb)
    {
        var where = employeesDb.Query().Managers.Where(x => x.dept_fk == "d004" && x.from_date > DateOnly.Parse("2010-01-01"));
        Assert.NotEqual(employeesDb.Query().Managers.Count(x => x.dept_fk == "d004"), where.Count());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void Single(Database<EmployeesDb> employeesDb)
    {
        var dept = employeesDb.Query().Departments.Single(x => x.DeptNo == "d005");
        Assert.NotNull(dept);
        Assert.Equal("d005", dept.DeptNo);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SingleOrDefault(Database<EmployeesDb> employeesDb)
    {
        var dept = employeesDb.Query().Departments.SingleOrDefault(x => x.DeptNo == "d005");
        Assert.NotNull(dept);
        Assert.Equal("d005", dept.DeptNo);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SingleOrDefaultNull(Database<EmployeesDb> employeesDb)
    {
        var dept = employeesDb.Query().Departments.SingleOrDefault(x => x.DeptNo == "1234");
        Assert.Null(dept);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SingleThrow(Database<EmployeesDb> employeesDb)
    {
        Assert.Throws<InvalidOperationException>(() => employeesDb.Query().salaries.Single(x => x.salary > 70000));
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SingleOrDefaultThrow(Database<EmployeesDb> employeesDb)
    {
        Assert.Throws<InvalidOperationException>(() => employeesDb.Query().salaries.SingleOrDefault(x => x.salary > 70000));
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void First(Database<EmployeesDb> employeesDb)
    {
        var salary = employeesDb.Query().salaries.First(x => x.salary > 70000);
        Assert.NotNull(salary);
        Assert.True(70000 <= salary.salary);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void FirstOrDefault(Database<EmployeesDb> employeesDb)
    {
        var salary = employeesDb.Query().salaries.FirstOrDefault(x => x.salary > 70000);
        Assert.NotNull(salary);
        Assert.True(70000 <= salary.salary);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void FirstOrderBy(Database<EmployeesDb> employeesDb)
    {
        var salary = employeesDb.Query().salaries.OrderBy(x => x.salary).First(x => x.salary > 70000);
        Assert.NotNull(salary);
        Assert.True(70000 <= salary.salary);
        Assert.NotEqual(salary.salary, employeesDb.Query().salaries.First(x => x.salary > 70000).salary);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void FirstOrDefaultOrderBy(Database<EmployeesDb> employeesDb)
    {
        var salary = employeesDb.Query().salaries.OrderBy(x => x.salary).FirstOrDefault(x => x.salary > 70000);
        Assert.NotNull(salary);
        Assert.True(70000 <= salary.salary);
        Assert.NotEqual(salary.salary, employeesDb.Query().salaries.FirstOrDefault(x => x.salary > 70000).salary);
        Assert.NotEqual(salary.salary, employeesDb.Query().salaries.OrderBy(x => x.salary).LastOrDefault(x => x.salary > 70000).salary);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void LastOrDefaultOrderBy(Database<EmployeesDb> employeesDb)
    {
        var salary = employeesDb.Query().salaries.OrderByDescending(x => x.salary).LastOrDefault(x => x.salary > 70000);
        Assert.NotNull(salary);
        Assert.True(70000 <= salary.salary);
        Assert.NotEqual(salary.salary, employeesDb.Query().salaries.FirstOrDefault(x => x.salary > 70000).salary);
        Assert.NotEqual(salary.salary, employeesDb.Query().salaries.OrderByDescending(x => x.salary).FirstOrDefault(x => x.salary > 70000).salary);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void FirstOrDefaultNull(Database<EmployeesDb> employeesDb)
    {
        var salary = employeesDb.Query().salaries.FirstOrDefault(x => x.salary < 10000);
        Assert.Null(salary);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void LastOrDefaultNull(Database<EmployeesDb> employeesDb)
    {
        var salary = employeesDb.Query().salaries.LastOrDefault(x => x.salary < 10000);
        Assert.Null(salary);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void Any(Database<EmployeesDb> employeesDb)
    {
        Assert.True(employeesDb.Query().Departments.Any(x => x.DeptNo == "d005"));
        Assert.True(employeesDb.Query().Departments.Where(x => x.DeptNo == "d005").Any());
        Assert.False(employeesDb.Query().Departments.Any(x => x.DeptNo == "not_existing"));
        Assert.False(employeesDb.Query().Departments.Where(x => x.DeptNo == "not_existing").Any());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void OrderBy(Database<EmployeesDb> employeesDb)
    {
        SharedSetup(employeesDb);

        var deptByDeptNo = employeesDb.Query().Departments.OrderBy(x => x.DeptNo);
        Assert.Equal("d001", deptByDeptNo.First().DeptNo);
        Assert.Equal("d001", deptByDeptNo.FirstOrDefault().DeptNo);
        Assert.Equal(lastDepartmentName, deptByDeptNo.Last().DeptNo);
        Assert.Equal(lastDepartmentName, deptByDeptNo.LastOrDefault().DeptNo);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void OrderBySelect(Database<EmployeesDb> employeesDb)
    {
        SharedSetup(employeesDb);

        var deptByDeptNo = employeesDb.Query().Departments.OrderBy(x => x.DeptNo).Select(x => x.DeptNo);
        Assert.Equal("d001", deptByDeptNo.First());
        Assert.Equal("d001", deptByDeptNo.FirstOrDefault());
        Assert.Equal(lastDepartmentName, deptByDeptNo.Last());
        Assert.Equal(lastDepartmentName, deptByDeptNo.LastOrDefault());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void OrderBySelectAnonymous(Database<EmployeesDb> employeesDb)
    {
        SharedSetup(employeesDb);

        var deptByDeptNo = employeesDb.Query().Departments.OrderBy(x => x.DeptNo).Select(x => new
        {
            no = x.DeptNo,
            name = x.Name
        });
        Assert.Equal("d001", deptByDeptNo.First().no);
        Assert.Equal("d001", deptByDeptNo.FirstOrDefault().no);
        Assert.Equal(lastDepartmentName, deptByDeptNo.Last().no);
        Assert.Equal(lastDepartmentName, deptByDeptNo.LastOrDefault().no);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void TakeAndSkip(Database<EmployeesDb> employeesDb)
    {
        var tenEmployees = employeesDb.Query().Employees.Take(10).ToList();
        Assert.Equal(10, tenEmployees.Count);

        var tenEmployeesSkip1 = employeesDb.Query().Employees.Skip(1).Take(10).ToList();
        Assert.Equal(10, tenEmployeesSkip1.Count);
        Assert.Equal(tenEmployees[1], tenEmployeesSkip1[0]);
        Assert.Same(tenEmployees[1], tenEmployeesSkip1[0]);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SkipAndTakeWithOrderBy(Database<EmployeesDb> employeesDb)
    {
        var employeesOrderedOrm = employeesDb.Query().Employees.OrderBy(e => e.birth_date).Skip(5).Take(10).ToList();
        var employeesOrderedList = employeesDb.Query().Employees.ToList().OrderBy(e => e.birth_date).Skip(5).Take(10).ToList();

        Assert.Equal(employeesOrderedList, employeesOrderedOrm);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SkipAndTakeWithOrderByDescending(Database<EmployeesDb> employeesDb)
    {
        var employeesOrderedDescOrm = employeesDb.Query().Employees.OrderByDescending(e => e.birth_date).Skip(5).Take(10).ToList();
        var employeesOrderedDescList = employeesDb.Query().Employees.ToList().OrderByDescending(e => e.birth_date).Skip(5).Take(10).ToList();

        Assert.Equal(employeesOrderedDescList, employeesOrderedDescOrm);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SkipWithOrderBy(Database<EmployeesDb> employeesDb)
    {
        var employeesSkippedOrm = employeesDb.Query().Employees.OrderBy(e => e.birth_date).Skip(10).ToList();
        var employeesSkippedList = employeesDb.Query().Employees.ToList().OrderBy(e => e.birth_date).Skip(10).ToList();

        Assert.Equal(employeesSkippedList, employeesSkippedOrm);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void TakeWithOrderByDescending(Database<EmployeesDb> employeesDb)
    {
        var topEmployeesOrm = employeesDb.Query().Employees.OrderByDescending(e => e.hire_date).Take(5).ToList();
        var topEmployeesList = employeesDb.Query().Employees.ToList().OrderByDescending(e => e.hire_date).Take(5).ToList();

        Assert.Equal(topEmployeesList, topEmployeesOrm);
    }


    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void ComplexQueryWithTakeSkipAndMultipleOrderings(Database<EmployeesDb> employeesDb)
    {
        var complexQueryResultOrm = employeesDb.Query().Employees
            .OrderBy(e => e.first_name)
            .ThenByDescending(e => e.birth_date)
            .Skip(5)
            .Take(10)
            .ToList();

        var complexQueryResultList = employeesDb.Query().Employees.ToList()
            .OrderBy(e => e.first_name)
            .ThenByDescending(e => e.birth_date)
            .Skip(5)
            .Take(10)
            .ToList();

        Assert.Equal(complexQueryResultList, complexQueryResultOrm);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public async Task TakeLastThrowsNotImplementedException(Database<EmployeesDb> employeesDb)
    {
        await Assert.ThrowsAsync<NotSupportedException>(() =>
            Task.FromResult(employeesDb.Query().Employees.TakeLast(5).ToList()));
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public async Task SkipLastThrowsNotImplementedException(Database<EmployeesDb> employeesDb)
    {
        await Assert.ThrowsAsync<NotSupportedException>(() =>
            Task.FromResult(employeesDb.Query().Employees.SkipLast(5).ToList()));
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void TakeWhileThrowsNotImplementedException(Database<EmployeesDb> employeesDb)
    {
        Assert.Throws<NotSupportedException>(() =>
            employeesDb.Query().Employees.TakeWhile(e => e.first_name.StartsWith("A")).ToList());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SkipWhileThrowsNotImplementedException(Database<EmployeesDb> employeesDb)
    {
        Assert.Throws<NotSupportedException>(() =>
            employeesDb.Query().Employees.SkipWhile(e => e.first_name.StartsWith("A")).ToList());
    }
}

================
File: src/DataLinq.Tests/RelationTests.cs
================
using System.Linq;
using DataLinq.Tests.Models;
using DataLinq.Tests.Models.Employees;
using Xunit;

namespace DataLinq.Tests;

public class RelationTests : BaseTests
{
    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void LazyLoadSingleValue(Database<EmployeesDb> employeesDb)
    {
        var manager = employeesDb.Query().Managers.Single(x => x.dept_fk == "d005" && x.emp_no == 1251);

        Assert.NotNull(manager.Department);
        Assert.Equal("d005", manager.Department.DeptNo);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void LazyLoadList(Database<EmployeesDb> employeesDb)
    {
        var department = employeesDb.Query().Departments.Single(x => x.DeptNo == "d005");

        Assert.NotNull(department.Managers);
        Assert.NotEmpty(department.Managers);
        Assert.True(10 < department.Managers.Count());
        Assert.Equal("d005", department.Managers.First().Department.DeptNo);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void EmptyList(Database<EmployeesDb> employeesDb)
    {
        var employee = employeesDb.Query().Employees.Single(x => x.emp_no == 1000);

        Assert.NotNull(employee.dept_manager);
        Assert.Empty(employee.dept_manager);
    }
}

================
File: src/DataLinq.Tests/SourceGeneratorTests.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Attributes;
using DataLinq.Extensions.Helpers;
using DataLinq.SourceGenerators;
using DataLinq.Tests.Models;
//using DataLinq.Tests.Models.Allround;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using Xunit;

namespace DataLinq.Tests;

public class SourceGeneratorTests
{
    public static DatabaseFixture fixture;

    static SourceGeneratorTests()
    {
        fixture = new DatabaseFixture();
    }

    public static IEnumerable<object[]> GetEmployees()
    {
        foreach (var db in fixture.AllEmployeesDb)
            yield return new object[] { db };
    }

    public SourceGeneratorTests()
    {
        foreach (var employeesDb in fixture.AllEmployeesDb)
        {
            employeesDb.Provider.State.ClearCache();
        }
    }


    

    //[Theory]
    //[MemberData(nameof(GetEmployees))]
    //public void CheckBasics(Database<EmployeesDb> employeesDb)
    //{
    //    //var proxy = new Titles();
    //    //var event2 = proxy.Event;
    //    //ITitles iTitle = ITitles
    //    //var temp = proxy.Event;
    //    //Assert.Equal("Generator: Discount", proxy.Generated);
    //    //Assert.NotNull(proxy);
    //}
}

================
File: src/DataLinq.Tests/SqlQueryTests.cs
================
using System.Linq;
using DataLinq.Tests.Models;
using DataLinq.Tests.Models.Employees;
using Xunit;

namespace DataLinq.Tests;

public class SqlQueryTests : BaseTests
{
    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhere(Database<EmployeesDb> employeesDb)
    {
        var departement = employeesDb
            .From<Department>()
            .Where("dept_no").EqualTo("d005")
            .Select();

        Assert.Single(departement);
        Assert.Equal("d005", departement.Single().DeptNo);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void GetFromQueryWhere(Database<EmployeesDb> employeesDb)
    {
        var departement = employeesDb.Transaction().GetFromQuery<Department>("SELECT * FROM departments WHERE dept_no = 'd005'");

        Assert.Single(departement);
        Assert.Equal("d005", departement.Single().DeptNo);
    }
}

================
File: src/DataLinq.Tests/SqlTests.cs
================
using DataLinq.Query;
using DataLinq.Tests.Models;
using DataLinq.Tests.Models.Employees;
using Xunit;

namespace DataLinq.Tests;

public class SqlTests : BaseTests
{
    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhere(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .Where("dept_no").EqualTo("d005")
            .SelectQuery()
            .ToSql();


        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
{escape}dept_no{escape} = {sign}w0", sql.Text);
        Assert.Single(sql.Parameters);
        Assert.Equal($"{sign}w0", sql.Parameters[0].ParameterName);
        Assert.Equal("d005", sql.Parameters[0].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereAnd(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = new SqlQuery("departments", employeesDb.Transaction())
            .Where("dept_no").EqualTo("d005")
            .And("dept_name").EqualTo("Development")
            .And("dept_name").EqualTo("Development")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
{escape}dept_no{escape} = {sign}w0 AND {escape}dept_name{escape} = {sign}w1 AND {escape}dept_name{escape} = {sign}w2", sql.Text);
        Assert.Equal(3, sql.Parameters.Count);
        Assert.Equal($"{sign}w1", sql.Parameters[1].ParameterName);
        Assert.Equal("Development", sql.Parameters[1].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereOr(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = new SqlQuery("departments", employeesDb.Transaction())
            .Where("dept_no").EqualTo("d005")
            .Or("dept_name").EqualTo("Development")
            .Or("dept_name").EqualTo("Development")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
{escape}dept_no{escape} = {sign}w0 OR {escape}dept_name{escape} = {sign}w1 OR {escape}dept_name{escape} = {sign}w2", sql.Text);
        Assert.Equal(3, sql.Parameters.Count);
        Assert.Equal($"{sign}w1", sql.Parameters[1].ParameterName);
        Assert.Equal("Development", sql.Parameters[1].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void ComplexWhereOR(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = new SqlQuery("departments", employeesDb.Transaction())
            .Where(x => x("dept_no").EqualTo("d001").And("dept_name").EqualTo("Marketing"))
            .Or(x => x("dept_no").EqualTo("d005").And("dept_name").EqualTo("Development"))
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
({escape}dept_no{escape} = {sign}w0 AND {escape}dept_name{escape} = {sign}w1) OR ({escape}dept_no{escape} = {sign}w2 AND {escape}dept_name{escape} = {sign}w3)", sql.Text);
        Assert.Equal(4, sql.Parameters.Count);
        Assert.Equal($"{sign}w1", sql.Parameters[1].ParameterName);
        Assert.Equal("Marketing", sql.Parameters[1].Value);
        Assert.Equal($"{sign}w3", sql.Parameters[3].ParameterName);
        Assert.Equal("Development", sql.Parameters[3].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void ComplexWhereAND(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = new SqlQuery("departments", employeesDb.Transaction())
            .Where(x => x("dept_no").EqualTo("d001").And("dept_name").EqualTo("Marketing"))
            .And(x => x("dept_no").EqualTo("d005").And("dept_name").EqualTo("Development"))
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
({escape}dept_no{escape} = {sign}w0 AND {escape}dept_name{escape} = {sign}w1) AND ({escape}dept_no{escape} = {sign}w2 AND {escape}dept_name{escape} = {sign}w3)", sql.Text);
        Assert.Equal(4, sql.Parameters.Count);
        Assert.Equal($"{sign}w1", sql.Parameters[1].ParameterName);
        Assert.Equal("Marketing", sql.Parameters[1].Value);
        Assert.Equal($"{sign}w3", sql.Parameters[3].ParameterName);
        Assert.Equal("Development", sql.Parameters[3].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereNot(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .Where("dept_no").NotEqualTo("d005")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
{escape}dept_no{escape} <> {sign}w0", sql.Text);
        Assert.Single(sql.Parameters);
        Assert.Equal($"{sign}w0", sql.Parameters[0].ParameterName);
        Assert.Equal("d005", sql.Parameters[0].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void WhereGroupNot(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .WhereNot("dept_no").EqualTo("d005")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
NOT ({escape}dept_no{escape} = {sign}w0)", sql.Text);
        Assert.Single(sql.Parameters);
        Assert.Equal($"{sign}w0", sql.Parameters[0].ParameterName);
        Assert.Equal("d005", sql.Parameters[0].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereGreaterThan(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .Where("dept_no").GreaterThan("d005")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
{escape}dept_no{escape} > {sign}w0", sql.Text);
        Assert.Single(sql.Parameters);
        Assert.Equal($"{sign}w0", sql.Parameters[0].ParameterName);
        Assert.Equal("d005", sql.Parameters[0].Value);
    }

    private (string sign, string escape, string dbName) GetConstants(Database<EmployeesDb> employeesDb) =>
        (employeesDb.Provider.Constants.ParameterSign,
        employeesDb.Provider.Constants.EscapeCharacter,
        employeesDb.Provider.Constants.SupportsMultipleDatabases
            ? $"{employeesDb.Provider.Constants.EscapeCharacter}{employeesDb.Provider.DatabaseName}{employeesDb.Provider.Constants.EscapeCharacter}."
            : "");

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereGreaterThanOrEqual(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .Where("dept_no").GreaterThanOrEqual("d005")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
{escape}dept_no{escape} >= {sign}w0", sql.Text);
        Assert.Single(sql.Parameters);
        Assert.Equal($"{sign}w0", sql.Parameters[0].ParameterName);
        Assert.Equal("d005", sql.Parameters[0].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereLessThan(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .Where("dept_no").LessThan("d005")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
{escape}dept_no{escape} < {sign}w0", sql.Text);
        Assert.Single(sql.Parameters);
        Assert.Equal($"{sign}w0", sql.Parameters[0].ParameterName);
        Assert.Equal("d005", sql.Parameters[0].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereLessThanOrEqual(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .Where("dept_no").LessThanOrEqual("d005")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
{escape}dept_no{escape} <= {sign}w0", sql.Text);
        Assert.Single(sql.Parameters);
        Assert.Equal($"{sign}w0", sql.Parameters[0].ParameterName);
        Assert.Equal("d005", sql.Parameters[0].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleLike(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .Where("dept_no").Like("d005%")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
{escape}dept_no{escape} LIKE {sign}w0", sql.Text);
        Assert.Single(sql.Parameters);
        Assert.Equal($"{sign}w0", sql.Parameters[0].ParameterName);
        Assert.Equal("d005%", sql.Parameters[0].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleOrderBy(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .OrderBy("dept_no")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
ORDER BY {escape}dept_no{escape}", sql.Text);
        Assert.Empty(sql.Parameters);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleOrderByDesc(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .OrderByDesc("dept_no")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
ORDER BY {escape}dept_no{escape} DESC", sql.Text);
        Assert.Empty(sql.Parameters);
    }


    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleOrderByTwice(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .OrderBy("dept_no")
            .OrderBy("dept_name")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
ORDER BY {escape}dept_no{escape}, {escape}dept_name{escape}", sql.Text);
        Assert.Empty(sql.Parameters);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleOrderByDescTwice(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .OrderByDesc("dept_no")
            .OrderByDesc("dept_name")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
ORDER BY {escape}dept_no{escape} DESC, {escape}dept_name{escape} DESC", sql.Text);
        Assert.Empty(sql.Parameters);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleOrderByTwiceMixed(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .OrderBy("dept_no")
            .OrderByDesc("dept_name")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
ORDER BY {escape}dept_no{escape}, {escape}dept_name{escape} DESC", sql.Text);
        Assert.Empty(sql.Parameters);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleOrderByDescTwiceMixed(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .OrderByDesc("dept_no")
            .OrderBy("dept_name")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
ORDER BY {escape}dept_no{escape} DESC, {escape}dept_name{escape}", sql.Text);
        Assert.Empty(sql.Parameters);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereOrderBy(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .Where("dept_no").EqualTo("d005")
            .OrderBy("dept_no")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
{escape}dept_no{escape} = {sign}w0
ORDER BY {escape}dept_no{escape}", sql.Text);
        Assert.Single(sql.Parameters);
        Assert.Equal($"{sign}w0", sql.Parameters[0].ParameterName);
        Assert.Equal("d005", sql.Parameters[0].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereOrderByDesc(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .Where("dept_no").EqualTo("d005")
            .OrderByDesc("dept_no")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
{escape}dept_no{escape} = {sign}w0
ORDER BY {escape}dept_no{escape} DESC", sql.Text);
        Assert.Single(sql.Parameters);
        Assert.Equal($"{sign}w0", sql.Parameters[0].ParameterName);
        Assert.Equal("d005", sql.Parameters[0].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void Limit1(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .Limit(1)
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
LIMIT 1", sql.Text);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void Limit2(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .Limit(2)
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
LIMIT 2", sql.Text);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void Limit2Offset5(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .Limit(2, 5)
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
LIMIT 2 OFFSET 5", sql.Text);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereOrderByDescLimit1(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .Where("dept_no").EqualTo("d005")
            .OrderByDesc("dept_no")
            .Limit(1)
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
{escape}dept_no{escape} = {sign}w0
ORDER BY {escape}dept_no{escape} DESC
LIMIT 1", sql.Text);
        Assert.Single(sql.Parameters);
        Assert.Equal($"{sign}w0", sql.Parameters[0].ParameterName);
        Assert.Equal("d005", sql.Parameters[0].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereLimit1OrderByDesc(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .Where("dept_no").EqualTo("d005")
            .Limit(1)
            .OrderByDesc("dept_no")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
{escape}dept_no{escape} = {sign}w0
ORDER BY {escape}dept_no{escape} DESC
LIMIT 1", sql.Text);
        Assert.Single(sql.Parameters);
        Assert.Equal($"{sign}w0", sql.Parameters[0].ParameterName);
        Assert.Equal("d005", sql.Parameters[0].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhat(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .What("dept_name")
            .SelectQuery()
            .ToSql();

        Assert.Equal($"SELECT {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}", sql.Text);
        Assert.Empty(sql.Parameters);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleJoinExplicitAlias(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments", "d")
            .Join("dept_manager", "m").On("dept_no", "d").EqualToColumn("dept_no", "m")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT d.{escape}dept_no{escape}, d.{escape}dept_name{escape} FROM {dbName}{escape}departments{escape} d
JOIN {dbName}{escape}dept_manager{escape} m ON d.{escape}dept_no{escape} = m.{escape}dept_no{escape}", sql.Text);
        Assert.Empty(sql.Parameters);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleJoinIncludedAlias(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments d")
            .Join("dept_manager m").On("d.dept_no").EqualToColumn("m.dept_no")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT d.{escape}dept_no{escape}, d.{escape}dept_name{escape} FROM {dbName}{escape}departments{escape} d
JOIN {dbName}{escape}dept_manager{escape} m ON d.{escape}dept_no{escape} = m.{escape}dept_no{escape}", sql.Text);
        Assert.Empty(sql.Parameters);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleJoinIncludedAliasWhere(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments d")
            .Join("dept_manager m").On("d.dept_no").EqualToColumn("m.dept_no")
            .Where("m.dept_no").EqualTo("d005")
            .Limit(1)
            .OrderByDesc("d.dept_no")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT d.{escape}dept_no{escape}, d.{escape}dept_name{escape} FROM {dbName}{escape}departments{escape} d
JOIN {dbName}{escape}dept_manager{escape} m ON d.{escape}dept_no{escape} = m.{escape}dept_no{escape}
WHERE
m.{escape}dept_no{escape} = {sign}w0
ORDER BY d.{escape}dept_no{escape} DESC
LIMIT 1", sql.Text);
        Assert.NotEmpty(sql.Parameters);
    }


    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleJoinIncludedAliasLimit(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments d")
            .Join("dept_manager m").On("d.dept_no").EqualToColumn("m.dept_no")
            .Limit(1)
            .OrderByDesc("d.dept_no")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT d.{escape}dept_no{escape}, d.{escape}dept_name{escape} FROM {dbName}{escape}departments{escape} d
JOIN {dbName}{escape}dept_manager{escape} m ON d.{escape}dept_no{escape} = m.{escape}dept_no{escape}
ORDER BY d.{escape}dept_no{escape} DESC
LIMIT 1", sql.Text);
        Assert.Empty(sql.Parameters);
    }


    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleJoinIncludedAliasOrderByDesc(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments d")
            .Join("dept_manager m").On("d.dept_no").EqualToColumn("m.dept_no")
            .OrderByDesc("d.dept_no")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT d.{escape}dept_no{escape}, d.{escape}dept_name{escape} FROM {dbName}{escape}departments{escape} d
JOIN {dbName}{escape}dept_manager{escape} m ON d.{escape}dept_no{escape} = m.{escape}dept_no{escape}
ORDER BY d.{escape}dept_no{escape} DESC", sql.Text);
        Assert.Empty(sql.Parameters);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void DoubleJoinIncludedAliasOrderByDesc(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments d")
            .Join("dept_manager m").On("d.dept_no").EqualToColumn("m.dept_no")
            .Join("dept-emp e").On("e.dept_no").EqualToColumn("m.dept_no")
            .OrderByDesc("d.dept_no")
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT d.{escape}dept_no{escape}, d.{escape}dept_name{escape} FROM {dbName}{escape}departments{escape} d
JOIN {dbName}{escape}dept_manager{escape} m ON d.{escape}dept_no{escape} = m.{escape}dept_no{escape}
JOIN {dbName}{escape}dept-emp{escape} e ON e.{escape}dept_no{escape} = m.{escape}dept_no{escape}
ORDER BY d.{escape}dept_no{escape} DESC", sql.Text);
        Assert.Empty(sql.Parameters);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleInsert(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var sql = employeesDb
            .From("departments")
            .Set("dept_no", "d005")
            .InsertQuery()
            .ToSql();

        Assert.Equal($@"INSERT INTO {dbName}{escape}departments{escape} ({escape}dept_no{escape}) VALUES ({sign}v0)", sql.Text);
        Assert.Single(sql.Parameters);
        Assert.Equal($"{sign}v0", sql.Parameters[0].ParameterName);
        Assert.Equal("d005", sql.Parameters[0].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleInsertWithLastId(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var lastInsert = employeesDb.Provider.Constants.LastInsertCommand;
        var sql = employeesDb
            .From("departments")
            .Set("dept_no", "d005")
            .AddLastIdQuery()
            .InsertQuery()
            .ToSql();

        Assert.Equal($@"INSERT INTO {dbName}{escape}departments{escape} ({escape}dept_no{escape}) VALUES ({sign}v0);
SELECT {lastInsert}", sql.Text);
        Assert.Single(sql.Parameters);
        Assert.Equal($"{sign}v0", sql.Parameters[0].ParameterName);
        Assert.Equal("d005", sql.Parameters[0].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereInOne(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var ids = new[] { 3 };
        var sql = employeesDb
            .From("departments d")
            .Where("Id").In(ids)
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT d.{escape}dept_no{escape}, d.{escape}dept_name{escape} FROM {dbName}{escape}departments{escape} d
WHERE
{escape}Id{escape} IN ({sign}w0)", sql.Text);
        Assert.Single(sql.Parameters);
        Assert.Equal($"{sign}w0", sql.Parameters[0].ParameterName);
        Assert.Equal(ids[0], sql.Parameters[0].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereIn(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var ids = new[] { 1, 2, 3 };
        var sql = employeesDb
            .From("departments d")
            .Where("Id").In(ids)
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT d.{escape}dept_no{escape}, d.{escape}dept_name{escape} FROM {dbName}{escape}departments{escape} d
WHERE
{escape}Id{escape} IN ({sign}w0, {sign}w1, {sign}w2)", sql.Text);
        Assert.Equal(3, sql.Parameters.Count);
        Assert.Equal($"{sign}w0", sql.Parameters[0].ParameterName);
        Assert.Equal(ids[0], sql.Parameters[0].Value);
        Assert.Equal($"{sign}w1", sql.Parameters[1].ParameterName);
        Assert.Equal(ids[1], sql.Parameters[1].Value);
        Assert.Equal($"{sign}w2", sql.Parameters[2].ParameterName);
        Assert.Equal(ids[2], sql.Parameters[2].Value);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void SimpleWhereNotIn(Database<EmployeesDb> employeesDb)
    {
        var (sign, escape, dbName) = GetConstants(employeesDb);
        var ids = new[] { 1, 2, 3 };
        var sql = employeesDb
            .From("departments")
            .Where("Id").NotIn(ids)
            .SelectQuery()
            .ToSql();

        Assert.Equal($@"SELECT {escape}dept_no{escape}, {escape}dept_name{escape} FROM {dbName}{escape}departments{escape}
WHERE
{escape}Id{escape} NOT IN ({sign}w0, {sign}w1, {sign}w2)", sql.Text);
        Assert.Equal(3, sql.Parameters.Count);
        Assert.Equal($"{sign}w0", sql.Parameters[0].ParameterName);
        Assert.Equal(ids[0], sql.Parameters[0].Value);
        Assert.Equal($"{sign}w1", sql.Parameters[1].ParameterName);
        Assert.Equal(ids[1], sql.Parameters[1].Value);
        Assert.Equal($"{sign}w2", sql.Parameters[2].ParameterName);
        Assert.Equal(ids[2], sql.Parameters[2].Value);
    }

}

================
File: src/DataLinq.Tests/ThreadingTests.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using DataLinq.Tests.Models;
using DataLinq.Tests.Models.Employees;
using Xunit;

namespace DataLinq.Tests;

public class ThreadingTests : BaseTests
{
    private Helpers helpers = new Helpers();
    
    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void StressTest(Database<EmployeesDb> employeesDb)
    {
        var amount = 100;

        var employees = employeesDb.Query().Employees
            .Where(x => x.emp_no <= amount)
            .OrderBy(x => x.emp_no)
            .ToList();

        Parallel.For(0, amount, i =>
        {
            var employee = employees[i];
            Assert.False(employee.dept_emp.Count() == 0,
                    $"Collection dept_emp is empty for employee '{employee.emp_no}'");

            foreach (var dept_emp in employee.dept_emp)
            {
                Assert.NotNull(dept_emp.employees);
                Assert.Equal(employee, dept_emp.employees);
                Assert.NotNull(dept_emp.departments);
                Assert.False(dept_emp.departments.DepartmentEmployees.Count() == 0, 
                    $"Collection DepartmentEmployees is empty for Department '{dept_emp.departments.DeptNo}', Employee '{employee.emp_no}'");
                Assert.False(dept_emp.departments.Managers.Count() == 0,
                    $"Collection Managers is empty for Department '{dept_emp.departments.DeptNo}', Employee '{employee.emp_no}'");
            }
        });
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void ReadParallel(Database<EmployeesDb> employeesDb)
    {
        Parallel.For(0, 100, i =>
        {
            SetAndTest(1004, employeesDb);
            SetAndTest(1005, employeesDb);
            SetAndTest(1006, employeesDb);
            SetAndTest(1007, employeesDb);
            SetAndTest(1008, employeesDb);
        });
    }

    private void SetAndTest(int value, Database<EmployeesDb> employeesDb)
    {
        var employee = employeesDb.Query().Employees.Single(x => x.emp_no == value);
        Assert.Equal(value, employee.emp_no);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void CommitTransactionParallel(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999990;

        Parallel.For(0, 10, i =>
        {
            var id = emp_no - i;

            var employee = helpers.GetEmployee(id, employeesDb);
            var orgBirthDate = employee.birth_date;
            var employeeMut = employee.Mutate();

            var newBirthDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20));
            employeeMut.birth_date = newBirthDate;
            Assert.Equal(newBirthDate, employeeMut.birth_date);

            using var transaction = employeesDb.Transaction();
            var dbEmployeeReturn = transaction.Update(employeeMut);

            transaction.Commit();

            var dbEmployee = employeesDb.Query().Employees.Single(x => x.emp_no == id);
            Assert.NotEqual(orgBirthDate.ToShortDateString(), dbEmployee.birth_date.ToShortDateString());
            Assert.Equal(newBirthDate.ToShortDateString(), dbEmployee.birth_date.ToShortDateString());
        });
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void LazyLoadSingleValue(Database<EmployeesDb> employeesDb)
    {
        Parallel.For(1, 10, i =>
        {
            var manager = employeesDb.Query().Managers.FirstOrDefault(x => x.dept_fk == "d00" + i);

            Assert.NotNull(manager.Department);
            Assert.Equal("d00" + i, manager.Department.DeptNo);
        });
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void LazyLoadList(Database<EmployeesDb> employeesDb)
    {
        Parallel.For(0, 100, i =>
        {
            var department = employeesDb.Query().Departments.Single(x => x.DeptNo == "d005");

            Assert.NotNull(department.Managers);
            Assert.NotEmpty(department.Managers);
            Assert.True(10 < department.Managers.Count());
            Assert.Equal("d005", department.Managers.First().Department.DeptNo);
        });
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void MakeSnapshot(Database<EmployeesDb> employeesDb)
    {
        var rand = Random.Shared;

        Parallel.For(0, 100, i =>
        {
            
            List<Salaries> salaries;
            do
            {
                var salaryLow = rand.Next(0, 200000);
                var salaryHigh = rand.Next(salaryLow, 200000);

                var snapshot = employeesDb.Provider.State.Cache.MakeSnapshot();
                salaries = [.. employeesDb.Query().salaries.Where(x => x.salary > salaryLow && x.salary < salaryHigh).Take(10)];
                var snapshot2 = employeesDb.Provider.State.Cache.MakeSnapshot();

                Assert.True(snapshot.Timestamp < snapshot2.Timestamp);
            }
            while (salaries.Count == 0);
        });
    }
}

================
File: src/DataLinq.Tests/TransactionTests.cs
================
using System;
using System.Data;
using System.Linq;
using DataLinq.Mutation;
using DataLinq.Tests.Models;
using DataLinq.Tests.Models.Employees;
using Microsoft.Data.Sqlite;
using MySqlConnector;
using Xunit;

namespace DataLinq.Tests;

public class TransactionTests : BaseTests
{
    private Helpers helpers = new Helpers();

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void AttachTransaction(Database<EmployeesDb> employeesDb)
    {
        using IDbConnection dbConnection = employeesDb.DatabaseType == DatabaseType.MySQL
            ? new MySqlConnection(employeesDb.Provider.ConnectionString)
            : new SqliteConnection(employeesDb.Provider.ConnectionString);

        dbConnection.Open();
        using var dbTransaction = dbConnection.BeginTransaction(IsolationLevel.ReadCommitted);

        var command = employeesDb
            .From("departments")
            .Set("dept_no", "d099")
            .Set("dept_name", "Transactions")
            .InsertQuery()
            .ToDbCommand();

        command.Connection = dbConnection;
        command.Transaction = dbTransaction;
        command.ExecuteNonQuery();

        using var transaction = employeesDb.AttachTransaction(dbTransaction);
        Assert.Equal(DatabaseTransactionStatus.Open, transaction.Status);

        var dept = transaction.Query().Departments.Single(x => x.DeptNo == "d099");
        Assert.Equal("Transactions", dept.Name);

        var numDept = employeesDb.Query().Departments.Count(x => x.DeptNo == "d099");
        Assert.Equal(0, numDept);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void AttachMutateTransaction(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999700;

        foreach (var alreadyExists in employeesDb.Query().Employees.Where(x => x.emp_no == emp_no).ToList())
            employeesDb.Delete(alreadyExists);

        var employee = employeesDb.Query().Employees.SingleOrDefault(x => x.emp_no == emp_no)?.Mutate() ?? helpers.NewEmployee(emp_no);
        employee.first_name = "Bob";
        employeesDb.Save(employee);

        var dbEmployee = employeesDb.Query().Employees.SingleOrDefault(x => x.emp_no == emp_no).Mutate();
        Assert.Equal("Bob", dbEmployee.first_name);


        using IDbConnection dbConnection = employeesDb.DatabaseType == DatabaseType.MySQL
            ? new MySqlConnection(employeesDb.Provider.ConnectionString)
            : new SqliteConnection(employeesDb.Provider.ConnectionString);

        dbConnection.Open();
        using var dbTransaction = dbConnection.BeginTransaction(IsolationLevel.ReadCommitted);
        using var transaction = employeesDb.AttachTransaction(dbTransaction);

        dbEmployee.first_name = "Rick";
        transaction.Save(dbEmployee);
        dbTransaction.Commit();
        transaction.Commit();

        var dbEmployee2 = employeesDb.Query().Employees.SingleOrDefault(x => x.emp_no == emp_no);
        Assert.Equal("Rick", dbEmployee2.first_name);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void GetTransaction(Database<EmployeesDb> employeesDb)
    {
        using var transaction = employeesDb.Transaction();

        transaction.Insert(new MutableDepartment
        {
            DeptNo = "d099",
            Name = "Transactions"
        });

        var command = employeesDb
            .From("departments")
            .Where("dept_no")
            .EqualTo("d099")
            .SelectQuery()
            .ToDbCommand();

        var dbTransaction = transaction.DatabaseAccess.DbTransaction;

        command.Connection = dbTransaction.Connection;
        command.Transaction = dbTransaction;
        using var reader = command.ExecuteReader();

        var rows = 0;
        while (reader.Read())
        {
            rows++;
            Assert.Equal("d099", reader.GetString(0));
            Assert.Equal("Transactions", reader.GetString(1));
        }

        Assert.Equal(1, rows);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void Insert(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999999;

        foreach (var alreadyExists in employeesDb.Query().Employees.Where(x => x.emp_no == emp_no).ToList())
            employeesDb.Delete(alreadyExists);

        var employee = helpers.NewEmployee(emp_no);
        Assert.True(employee.HasPrimaryKeysSet());

        using var transaction = employeesDb.Transaction();
        Assert.Equal(DatabaseTransactionStatus.Closed, transaction.Status);

        transaction.OnStatusChanged += (x, args) =>
        {
            Assert.Same(transaction, x);
            Assert.Same(transaction, args.Transaction);
            Assert.Equal(transaction.Status, args.Status);
        };

        transaction.Insert(employee);
        Assert.True(employee.HasPrimaryKeysSet());
        var dbTransactionEmployee = transaction.Query().Employees.Single(x => x.emp_no == emp_no);
        Assert.NotSame(employee, dbTransactionEmployee);
        Assert.Equal(employee.birth_date, dbTransactionEmployee.birth_date);

        var table = employeesDb.Provider.Metadata
                .TableModels.Single(x => x.Table.DbName == "employees").Table;

        var cache = employeesDb.Provider.State.Cache.TableCaches[table];
        Assert.True(cache.IsTransactionInCache(transaction));
        Assert.Single(cache.GetTransactionRows(transaction));
        Assert.Same(dbTransactionEmployee, cache.GetTransactionRows(transaction).First());
        Assert.Equal(DatabaseTransactionStatus.Open, transaction.Status);

        transaction.Commit();
        Assert.False(cache.IsTransactionInCache(transaction));
        Assert.Equal(DatabaseTransactionStatus.Committed, transaction.Status);

        var dbEmployee = employeesDb.Query().Employees.Single(x => x.emp_no == emp_no);

        Assert.Equal(employee.birth_date, dbEmployee.birth_date);
        Assert.Equal(dbTransactionEmployee, dbEmployee);
        Assert.NotSame(dbTransactionEmployee, dbEmployee);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void InsertAutoIncrement(Database<EmployeesDb> employeesDb)
    {
        var employee = helpers.NewEmployee();
        Assert.False(employee.HasPrimaryKeysSet());

        using (var transaction = employeesDb.Transaction())
        {
            transaction.Insert(employee);
            Assert.NotNull(employee.emp_no);
            Assert.True(employee.HasPrimaryKeysSet());

            var dbTransactionEmployee = transaction.Query().Employees.Single(x => x.emp_no == employee.emp_no);
            Assert.Equal(employee.birth_date.ToShortDateString(), dbTransactionEmployee.birth_date.ToShortDateString());
            Assert.True(dbTransactionEmployee.HasPrimaryKeysSet());

            transaction.Commit();
        }

        var dbEmployee = employeesDb.Query().Employees.Single(x => x.emp_no == employee.emp_no);

        Assert.Equal(employee.birth_date.ToShortDateString(), dbEmployee.birth_date.ToShortDateString());
        Assert.True(dbEmployee.HasPrimaryKeysSet());

        employeesDb.Delete(dbEmployee);
        Assert.False(employeesDb.Query().Employees.Any(x => x.emp_no == employee.emp_no));
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void InsertAndUpdateAutoIncrement(Database<EmployeesDb> employeesDb)
    {
        var employee = helpers.NewEmployee();
        Assert.False(employee.HasPrimaryKeysSet());

        MutableEmployee dbEmployee;
        using (var transaction = employeesDb.Transaction())
        {
            dbEmployee = transaction.Insert(employee).Mutate();
            Assert.NotNull(employee.emp_no);
            Assert.True(employee.HasPrimaryKeysSet());

            transaction.Commit();
        }

        Assert.True(employee.HasPrimaryKeysSet());
        dbEmployee.birth_date = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20));


        using (var transaction = employeesDb.Transaction())
        {
            transaction.Update(dbEmployee);
            Assert.True(dbEmployee.HasPrimaryKeysSet());
            transaction.Commit();
        }

        var dbEmployee2 = employeesDb.Query().Employees.Single(x => x.emp_no == employee.emp_no);
        Assert.Equal(dbEmployee.birth_date, dbEmployee2.birth_date);
        Assert.True(dbEmployee2.HasPrimaryKeysSet());

        employeesDb.Delete(dbEmployee2);
        Assert.False(employeesDb.Query().Employees.Any(x => x.emp_no == employee.emp_no));
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void UpdateNoChanges(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999795;

        var employee = helpers.GetEmployee(emp_no, employeesDb);
        
        var employeeMut = employee.Mutate();
        Assert.Empty(employeeMut.GetChanges());
        var dbEmployee = employeeMut.Update(employeesDb);
        Assert.Equal(employee, dbEmployee);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void UpdateImplicitTransaction(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999998;

        var employee = helpers.GetEmployee(emp_no, employeesDb);
        var orgBirthDate = employee.birth_date;
        var employeeMut = employee.Mutate();
        Assert.False(employeeMut.IsNew());

        var newBirthDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20));
        employeeMut.birth_date = newBirthDate;
        Assert.Equal(newBirthDate, employeeMut.birth_date);

        var dbEmployeeReturn = employeesDb.Update(employeeMut);
        var dbEmployee = employeesDb.Query().Employees.Single(x => x.emp_no == emp_no);

        Assert.NotSame(dbEmployeeReturn, dbEmployee);
        Assert.NotEqual(orgBirthDate.ToShortDateString(), dbEmployee.birth_date.ToShortDateString());
        Assert.Equal(employeeMut.birth_date.ToShortDateString(), dbEmployee.birth_date.ToShortDateString());
    }


    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void UpdateExplicitTransaction(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999997;

        var employee = helpers.GetEmployee(emp_no, employeesDb);
        var orgBirthDate = employee.birth_date;
        var employeeMut = employee.Mutate();

        var newBirthDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20));
        employeeMut.birth_date = newBirthDate;
        Assert.Equal(newBirthDate, employeeMut.birth_date);

        using var transaction = employeesDb.Transaction();
        var dbEmployeeReturn = transaction.Update(employeeMut);
        var dbEmployee = transaction.Query().Employees.Single(x => x.emp_no == emp_no);
        Assert.Same(dbEmployeeReturn, dbEmployee);
        transaction.Commit();

        var dbEmployee2 = employeesDb.Query().Employees.Single(x => x.emp_no == emp_no);

        Assert.NotSame(dbEmployeeReturn, dbEmployee2);
        Assert.NotEqual(orgBirthDate.ToShortDateString(), dbEmployee2.birth_date.ToShortDateString());
        Assert.Equal(employeeMut.birth_date.ToShortDateString(), dbEmployee2.birth_date.ToShortDateString());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void RollbackTransaction(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999996;

        var employee = helpers.GetEmployee(emp_no, employeesDb);
        var orgBirthDate = employee.birth_date;
        var employeeMut = employee.Mutate();

        var newBirthDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20));
        employeeMut.birth_date = newBirthDate;
        Assert.Equal(newBirthDate, employeeMut.birth_date);

        using var transaction = employeesDb.Transaction();
        var dbEmployeeReturn = transaction.Update(employeeMut);
        var dbEmployee = transaction.Query().Employees.Single(x => x.emp_no == emp_no);
        Assert.Same(dbEmployeeReturn, dbEmployee);

        var table = employeesDb.Provider.Metadata
                .TableModels.Single(x => x.Table.DbName == "employees").Table;
        //Assert.Equal(1, table.Cache.TransactionRowsCount);
        Assert.Equal(DatabaseTransactionStatus.Open, transaction.Status);

        transaction.Rollback();
        //Assert.Equal(0, table.Cache.TransactionRowsCount);
        Assert.Equal(DatabaseTransactionStatus.RolledBack, transaction.Status);

        var dbEmployee2 = employeesDb.Query().Employees.Single(x => x.emp_no == emp_no);

        Assert.NotSame(dbEmployeeReturn, dbEmployee2);
        Assert.NotEqual(employeeMut.birth_date.ToShortDateString(), dbEmployee2.birth_date.ToShortDateString());
        Assert.Equal(orgBirthDate.ToShortDateString(), dbEmployee2.birth_date.ToShortDateString());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void DoubleCommitTransaction(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999995;

        var employee = helpers.GetEmployee(emp_no, employeesDb);
        var orgBirthDate = employee.birth_date;
        var employeeMut = employee.Mutate();

        var newBirthDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20));
        employeeMut.birth_date = newBirthDate;
        Assert.Equal(newBirthDate, employeeMut.birth_date);

        using var transaction = employeesDb.Transaction();
        var dbEmployeeReturn = transaction.Update(employeeMut);

        transaction.Commit();
        Assert.Throws<Exception>(() => transaction.Commit());
        Assert.Throws<Exception>(() => transaction.Rollback());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void DoubleRollbackTransaction(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999994;

        var employee = helpers.GetEmployee(emp_no, employeesDb);
        var orgBirthDate = employee.birth_date;
        var employeeMut = employee.Mutate();

        var newBirthDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20));
        employeeMut.birth_date = newBirthDate;
        Assert.Equal(newBirthDate, employeeMut.birth_date);

        using var transaction = employeesDb.Transaction();
        var dbEmployeeReturn = transaction.Update(employeeMut);

        transaction.Rollback();
        Assert.Throws<Exception>(() => transaction.Rollback());
        Assert.Throws<Exception>(() => transaction.Commit());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void CommitRollbackTransaction(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999993;

        var employee = helpers.GetEmployee(emp_no, employeesDb);
        var orgBirthDate = employee.birth_date;
        var employeeMut = employee.Mutate();

        var newBirthDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20));
        employeeMut.birth_date = newBirthDate;
        Assert.Equal(newBirthDate, employeeMut.birth_date);

        using var transaction = employeesDb.Transaction();
        var dbEmployeeReturn = transaction.Update(employeeMut);

        transaction.Commit();
        Assert.Throws<Exception>(() => transaction.Rollback());
        Assert.Throws<Exception>(() => transaction.Commit());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void RollbackCommitTransaction(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999992;

        var employee = helpers.GetEmployee(emp_no, employeesDb);
        var orgBirthDate = employee.birth_date;
        var employeeMut = employee.Mutate();

        var newBirthDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20));
        employeeMut.birth_date = newBirthDate;
        Assert.Equal(newBirthDate, employeeMut.birth_date);

        using var transaction = employeesDb.Transaction();
        var dbEmployeeReturn = transaction.Update(employeeMut);

        transaction.Rollback();
        Assert.Throws<Exception>(() => transaction.Commit());
        Assert.Throws<Exception>(() => transaction.Rollback());
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void TransactionCache(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999991;
        var employee = helpers.GetEmployee(emp_no, employeesDb);
        Transaction<EmployeesDb>[] transactions = new Transaction<EmployeesDb>[10];

        for (int i = 0; i < 10; i++)
        {
            transactions[i] = employeesDb.Transaction(TransactionType.ReadAndWrite);
            var dbEmployee = transactions[i].Query().Employees.Single(x => x.emp_no == emp_no);
            var dbEmployee2 = transactions[i].Query().Employees.Single(x => x.emp_no == emp_no);
            Assert.Same(dbEmployee, dbEmployee2);

            if (i > 0)
            {
                var dbEmployeePrev = transactions[i - 1].Query().Employees.Single(x => x.emp_no == emp_no);
                Assert.NotSame(dbEmployee, dbEmployeePrev);
            }
        }

        foreach (var transaction in transactions)
            transaction.Dispose();
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void Save(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999800;
        var employee = helpers.GetEmployee(emp_no, employeesDb).Mutate();

        var newBirthDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20));
        var dbEmployee = employee.Save(x => { x.birth_date = newBirthDate; }, employeesDb);
        Assert.Equal(emp_no, dbEmployee.emp_no);
        Assert.Equal(newBirthDate.ToShortDateString(), dbEmployee.birth_date.ToShortDateString());
    }


    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void InsertRelations(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999799;
        var employee = helpers.GetEmployee(emp_no, employeesDb);

        foreach (var salary in employee.salaries)
            employeesDb.Delete(salary);

        using (var transaction = employeesDb.Transaction())
        {
            Assert.Empty(employee.salaries);

            var newSalary = new MutableSalaries
            {
                emp_no = employee.emp_no.Value,
                salary = 50000,
                FromDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20)),
                ToDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20))
            };

            Assert.Empty(employee.salaries);
            transaction.Insert(newSalary);
            Assert.Empty(employee.salaries);
            transaction.Commit();
        }

        Assert.Single(employee.salaries);
        employeesDb.Delete(employee.salaries.First());
        Assert.Empty(employee.salaries);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void InsertRelationsInTransaction(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999798;
        var employee = helpers.GetEmployee(emp_no, employeesDb);

        foreach (var salary in employee.salaries)
            employeesDb.Delete(salary);

        using (var transaction = employeesDb.Transaction())
        {
            var employeeDb = transaction.Query().Employees.Single(x => x.emp_no == emp_no);
            Assert.Empty(employeeDb.salaries);

            var newSalary = new MutableSalaries
            {
                emp_no = employeeDb.emp_no.Value,
                salary = 50000,
                FromDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20)),
                ToDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20))
            };

            //Assert.Null(newSalary.employees);
            Assert.Empty(employeeDb.salaries);
            var salary = transaction.Insert(newSalary);
            Assert.NotNull(salary);
            Assert.NotNull(salary.employees);
            Assert.Single(employeeDb.salaries);
            Assert.Same(salary, salary.employees.salaries.First());
            Assert.Same(salary, employeeDb.salaries.First().employees.salaries.First());
            Assert.Same(employeeDb, employeeDb.salaries.First().employees);
            Assert.Same(employeeDb, salary.employees.salaries.First().employees);
            transaction.Commit();
        }

        Assert.Single(employee.salaries);
        employeesDb.Delete(employee.salaries.First());
        Assert.Empty(employee.salaries);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void InsertRelationsReadAfterTransaction(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999797;
        var employee = helpers.GetEmployee(emp_no, employeesDb);

        foreach (var s in employee.salaries)
            employeesDb.Delete(s);

        Salaries salary = null;
        Employee employeeDb = null;

        var table = employeesDb.Provider.Metadata
                .TableModels.Single(x => x.Table.DbName == "salaries").Table;

        var cache = employeesDb.Provider.State.Cache.TableCaches[table];

        using var transaction = employeesDb.Transaction();

        Assert.False(cache.IsTransactionInCache(transaction));
        Assert.Empty(cache.GetTransactionRows(transaction));
        employeeDb = transaction.Query().Employees.Single(x => x.emp_no == emp_no);
        Assert.Empty(employeeDb.salaries);

        var newSalary = new MutableSalaries
        {
            emp_no = employeeDb.emp_no.Value,
            salary = 50000,
            FromDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20)),
            ToDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20))
        };

        //Assert.Empty(employeeDb.salaries);
        salary = transaction.Insert(newSalary);
        Assert.True(cache.IsTransactionInCache(transaction));
        Assert.Single(cache.GetTransactionRows(transaction));
        //Assert.Single(employeeDb.salaries);
        transaction.Commit();
        Assert.Equal(DatabaseTransactionStatus.Committed, transaction.Status);
        Assert.False(cache.IsTransactionInCache(transaction));
        Assert.Empty(cache.GetTransactionRows(transaction));


        Assert.Equal(salary, salary.employees.salaries.First());
        Assert.Equal(salary, employeeDb.salaries.First().employees.salaries.First());
        Assert.Equal(employeeDb, employeeDb.salaries.First().employees);
        Assert.Equal(employeeDb, salary.employees.salaries.First().employees);

        Assert.False(cache.IsTransactionInCache(transaction));
        Assert.Empty(cache.GetTransactionRows(transaction));

        Assert.Single(employee.salaries);
        employeesDb.Delete(employee.salaries.First());
        Assert.Empty(employee.salaries);
    }

    [Theory]
    [MemberData(nameof(GetEmployees))]
    public void UpdateOldModel(Database<EmployeesDb> employeesDb)
    {
        var emp_no = 999796;
        var employee = helpers.GetEmployee(emp_no, employeesDb).Mutate();

        var newBirthDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20));
        var dbEmployee = employee.Save(x => { x.birth_date = newBirthDate; }, employeesDb);
        Assert.Equal(emp_no, dbEmployee.emp_no);
        Assert.Equal(newBirthDate, dbEmployee.birth_date);

        var newHireDate = helpers.RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20));
        var dbEmployee2 = employee.Save(x => { x.hire_date = newHireDate; }, employeesDb);
        Assert.Equal(emp_no, dbEmployee2.emp_no);
        Assert.Equal(newBirthDate, dbEmployee2.birth_date);
        Assert.Equal(newHireDate, dbEmployee2.hire_date);
    }



    //[Fact]
    //public void InsertUpdateTwice()
    //{
    //    var employee = NewEmployee();

    //    using (var transaction = employeesDb.Transaction())
    //    {
    //        transaction.Insert(employee);
    //        transaction.Commit();
    //    }

    //    employee.birth_date = RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20));

    //    using (var transaction = employeesDb.Transaction())
    //    {
    //        Assert.Throws<InvalidMutationObjectException>(() => transaction.Insert(employee));
    //    }
    //}

    //[Fact]
    //public void UpdateTwice()
    //{
    //    var emp_no = 999996;

    //    var employeeMut = GetEmployee(emp_no).Mutate();

    //    employeeMut.birth_date = RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20)); ;
    //    employeesDb.Update(employeeMut);

    //    employeeMut.birth_date = RandomDate(DateTime.Now.AddYears(-60), DateTime.Now.AddYears(-20)); ;
    //    Assert.Throws<InvalidMutationObjectException>(() => employeesDb.Update(employeeMut));
    //}


}

================
File: src/DataLinq.Tools/DatabaseCreator.cs
================
using System;
using System.IO;
using System.Linq;
using DataLinq.Config;
using DataLinq.Core.Factories.Models;
using DataLinq.ErrorHandling;
using DataLinq.Extensions;
using DataLinq.Extensions.Helpers;
using DataLinq.Metadata;
using DataLinq.MySql;
using DataLinq.SQLite;
using ThrowAway;
using ThrowAway.Extensions;

namespace DataLinq.Tools;

public enum DatabaseCreatorError
{
    DestDirectoryNotFound,
    UnableToParseModelFiles,
    CouldNotCreateDatabase
}

public struct DatabaseCreatorOptions
{
}


public class DatabaseCreator : Generator
{
    private readonly DatabaseCreatorOptions options;

    static DatabaseCreator()
    {
        MySQLProvider.RegisterProvider();
        SQLiteProvider.RegisterProvider();
    }

    public DatabaseCreator(Action<string> log, DatabaseCreatorOptions options) : base(log)
    {
        this.options = options;
    }

    public Option<int, IDLOptionFailure> Create(DataLinqDatabaseConnection connection, string basePath, string databaseName)
    {
        log($"Type: {connection.Type}");

        var db = connection.DatabaseConfig;
        var fileEncoding = db.FileEncoding;

        var destDir = basePath + Path.DirectorySeparatorChar + db.DestinationDirectory;
        if (!Directory.Exists(destDir))
        {
            log($"Couldn't find dir: {destDir}");
            return DLOptionFailure.Fail(DatabaseCreatorError.DestDirectoryNotFound);
        }

        //var assemblyPathsExists = ParseExistingFilesAndDirs(basePath, db.AssemblyDirectories).ToList();
        //if (assemblyPathsExists.Any())
        //{
        //    log($"Reading assemblies from:");
        //    foreach (var path in assemblyPathsExists)
        //        log($"{path}");
        //}

        var options = new MetadataFromFileFactoryOptions { FileEncoding = fileEncoding, RemoveInterfacePrefix = db.RemoveInterfacePrefix };
        if (!new MetadataFromFileFactory(options, log).ReadFiles(db.CsType, destDir.Yield().ToList()).TryUnwrap(out var dbMetadata, out var metaDataFailure))
            return metaDataFailure;

        //if (dbMetadata.HasFailed)
        //{
        //    log("Error: Unable to parse model files.");
        //    return DatabaseCreatorError.UnableToParseModelFiles;
        //}

        log($"Tables in model files: {dbMetadata.TableModels.Length}");

        if (connection.Type == DatabaseType.SQLite && !Path.IsPathRooted(databaseName))
            databaseName = Path.Combine(basePath, databaseName);

        log($"Creating database '{databaseName}'");

        var sql = PluginHook.CreateDatabaseFromMetadata(connection.Type, dbMetadata, databaseName, connection.ConnectionString.Original, true);

        if (sql.HasFailed)
        {
            log(sql.Failure.ToString());
            return DLOptionFailure.Fail(DatabaseCreatorError.CouldNotCreateDatabase);
        }

        return sql.Value;
    }
}

================
File: src/DataLinq.Tools/Extensions/Helpers/LinqExtensions.cs
================
using System;
using System.Collections.Generic;

namespace DataLinq.Extensions.Helpers;

internal static class LinqExtensions
{
    internal static string ToJoinedString<T>(this IEnumerable<T> source, string separator = "\n") =>
        string.Join(separator, source);

    //https://stackoverflow.com/a/11463800
    internal static IEnumerable<List<T>> SplitList<T>(this List<T> locations, int nSize = 30)
    {
        for (int i = 0; i < locations.Count; i += nSize)
        {
            yield return locations.GetRange(i, Math.Min(nSize, locations.Count - i));
        }
    }

    internal static IEnumerable<T> Yield<T>(this T item)
    {
#pragma warning disable RCS1165 // Unconstrained type parameter checked for null.
        if (item != null)
#pragma warning restore RCS1165 // Unconstrained type parameter checked for null.
            yield return item;
    }
}

================
File: src/DataLinq.Tools/Extensions/Helpers/QueryExtensions.cs
================
using DataLinq.Query;

namespace DataLinq.Extensions.Helpers;

internal static class QueryExtensions
{
    internal static string ToSql(this Relation relation)
    {
        switch (relation)
        {
            case Relation.Equal:
                return "=";

            case Relation.EqualNull:
                return "IS";

            case Relation.NotEqual:
                return "<>";

            case Relation.NotEqualNull:
                return "IS NOT";

            case Relation.Like:
                return "LIKE";

            case Relation.GreaterThan:
                return ">";

            case Relation.GreaterThanOrEqual:
                return ">=";

            case Relation.LessThan:
                return "<";

            case Relation.LessThanOrEqual:
                return "<=";

            case Relation.In:
                return "IN";

            case Relation.NotIn:
                return "NOT IN";
        }

        return null;
    }
}

================
File: src/DataLinq.Tools/Extensions/Helpers/StringExtensions.cs
================
using System;

namespace DataLinq.Extensions.Helpers;

internal static class StringExtensions
{
    //https://stackoverflow.com/a/4405876
    internal static string FirstCharToUpper(this string input) =>
        input switch
        {
            null => throw new ArgumentNullException(nameof(input)),
            "" => throw new ArgumentException($"{nameof(input)} cannot be empty", nameof(input)),
            _ => string.Concat(input[0].ToString().ToUpper(), input.Substring(1))
        };
}

================
File: src/DataLinq.Tools/ModelGenerator.cs
================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using DataLinq.Config;
using DataLinq.Core.Factories;
using DataLinq.Core.Factories.Models;
using DataLinq.ErrorHandling;
using DataLinq.Metadata;
using ThrowAway;
using ThrowAway.Extensions;

namespace DataLinq.Tools;

public class Generator
{

    protected Action<string> log;

    public Generator(Action<string> log)
    {
        this.log = log;
    }

    protected IEnumerable<Option<string, IDLOptionFailure>> ParseExistingFilesAndDirs(string basePath, List<string> paths)
    {
        foreach (var relativePath in paths)
        {
            // Use Path.Combine to properly join paths instead of manual concatenation
            var srcPath = Path.GetFullPath(Path.Combine(basePath, relativePath));

            // Get the normalized path with correct case
            if (Directory.Exists(srcPath))
            {
                yield return new DirectoryInfo(srcPath).FullName;
            }
            else if (File.Exists(srcPath))
            {
                yield return new FileInfo(srcPath).FullName;
            }
            else
            {
                yield return DLOptionFailure.Fail(DLFailureType.FileNotFound, $"Couldn't find path '{srcPath}'");
            }
        }
    }
}

public enum ModelGeneratorError
{
    UnableToParseSourceFiles
}

public struct ModelGeneratorOptions
{
    public bool ReadSourceModels { get; set; } = false;
    public bool OverwriteExistingModels { get; set; } = false;
    public bool CapitalizeNames { get; set; } = false;
    public bool DeclareEnumsInClass { get; set; } = false;
    public bool SeparateTablesAndViews { get; set; } = false;
    public List<string> Tables { get; set; } = new List<string>();
    public List<string> Views { get; set; } = new List<string>();

    public ModelGeneratorOptions()
    {
    }
}

public class ModelGenerator : Generator
{
    private readonly ModelGeneratorOptions options;

    public ModelGenerator(Action<string> log, ModelGeneratorOptions options) : base(log)
    {
        this.options = options;
    }

    public Option<DatabaseDefinition, IDLOptionFailure> CreateModels(DataLinqDatabaseConnection connection, string basePath, string databaseName)
    {
        var db = connection.DatabaseConfig;

        var sqlOptions = new MetadataFromDatabaseFactoryOptions
        {
            CapitaliseNames = this.options.CapitalizeNames,
            DeclareEnumsInClass = this.options.DeclareEnumsInClass,
            Tables = this.options.Tables,
            Views = this.options.Views
        };

        if (connection.Type == DatabaseType.SQLite && !Path.IsPathRooted(databaseName))
            databaseName = connection.GetRootedPath(basePath); // Path.Combine(basePath, databaseName);

        //var connectionString = connection.ConnectionString;
        //if (connection.Type == DatabaseType.SQLite)
        //    connectionString = $"Data Source={databaseName};Cache=Shared;";

        var connectionString = connection.ConnectionString;
        if (connection.Type == DatabaseType.SQLite)
            connectionString = connectionString.ChangeValue("Data Source", databaseName);

        var fileEncoding = connection.DatabaseConfig.FileEncoding;

        log($"Reading from database: {databaseName}");
        log($"Type: {connection.Type}");

        if (!PluginHook.MetadataFromSqlFactories[connection.Type]
            .GetMetadataFromSqlFactory(sqlOptions)
            .ParseDatabase(db.Name, db.CsType, db.Namespace, databaseName, connectionString.Original)
            .TryUnwrap(out var dbMetadata, out var dbFailure))
            return DLOptionFailure.Fail(dbFailure);

        //var dbMetadata = connection.ParsedType switch
        //{
        //    DatabaseType.MySQL =>
        //        new MySql.MetadataFromSqlFactory(sqlOptions).ParseDatabase(db.Name, db.CsType, databaseName, new MySqlDatabase<information_schema>(connection.ConnectionString, "information_schema").Query()),
        //    DatabaseType.SQLite =>
        //        new SQLite.MetadataFromSqlFactory(sqlOptions).ParseDatabase(db.Name, db.CsType, databaseName, $"Data Source={databaseName};Cache=Shared;")
        //};

        log($"Tables read from database: {dbMetadata.TableModels.Length}");
        log("");

        var destDir = basePath + Path.DirectorySeparatorChar + db.DestinationDirectory;
        if (this.options.ReadSourceModels)
        {
            if (db.SourceDirectories == null || !db.SourceDirectories.Any())
            {
                log($"No source directory set. Skipping reading of sources.");
            }
            else
            {
                if (!ParseExistingFilesAndDirs(basePath, db.SourceDirectories).Transpose().TryUnwrap(out var srcPathsExists, out var srcPathsFailures))
                    return DLOptionFailure.AggregateFail(srcPathsFailures);

                log($"Reading models from:");
                foreach (var srcPath in srcPathsExists)
                {
                    //if (srcPath.HasFailed)
                    //    return DLOptionFailure.Fail($"Error: {srcPath.Failure}");

                    log($"{srcPath}");
                }

                //var assemblyPathsExists = ParseExistingFilesAndDirs(basePath, db.AssemblyDirectories).ToList();
                //if (assemblyPathsExists.Any())
                //{ 
                //    log($"Reading assemblies from:");
                //    foreach (var path in assemblyPathsExists)
                //        log($"{path}");
                //}

                var metadataOptions = new MetadataFromFileFactoryOptions { FileEncoding = fileEncoding, RemoveInterfacePrefix = db.RemoveInterfacePrefix };
                if (!new MetadataFromFileFactory(metadataOptions, log).ReadFiles(db.CsType, srcPathsExists).TryUnwrap(out var srcMetadata, out var srcFailure))
                    return srcFailure;
                //if (srcMetadata.HasFailed)
                //{
                //    //log("Error: Unable to parse source files.");
                //    return "Error: Unable to parse source files";
                //}

                log($"Tables in source model files: {srcMetadata.TableModels.Length}");
                log("");

                var transformer = new MetadataTransformer(new MetadataTransformerOptions(db.RemoveInterfacePrefix));
                transformer.TransformDatabase(srcMetadata, dbMetadata);
            }
        }


        var options = new ModelFileFactoryOptions
        {
            NamespaceName = db.Namespace,
            UseRecords = db.UseRecord,
            UseFileScopedNamespaces = db.UseFileScopedNamespaces,
            UseNullableReferenceTypes = db.UseNullableReferenceTypes,
            SeparateTablesAndViews = db.SeparateTablesAndViews
        };

        //log($"Writing models to:");
        foreach (var file in new ModelFileFactory(options).CreateModelFiles(dbMetadata))
        {
            var filepath = $"{destDir}{Path.DirectorySeparatorChar}{file.path}";
            log($"Writing {filepath}");

            if (!File.Exists(filepath))
                Directory.CreateDirectory(Path.GetDirectoryName(filepath));

            File.WriteAllText(filepath, file.contents, fileEncoding);
        }

        return dbMetadata;
    }

}

================
File: src/DataLinq.Tools/ModelReader.cs
================
using System;
using System.IO;
using System.Linq;
using DataLinq.Config;
using DataLinq.Core.Factories;
using DataLinq.Core.Factories.Models;
using DataLinq.Metadata;
using ThrowAway;

namespace DataLinq.Tools;

public class ModelReader : Generator
{
    public ModelReader(Action<string> log) : base(log)
    {
    }

    public Option<bool> Read(DataLinqConfig config, string basePath)
    {
        foreach (var database in config.Databases)
        {
            var result = Read(database, basePath);

            if (result.HasFailed)
                return result.Failure;
        }

        return true;
    }

    public Option<bool> Read(DataLinqDatabaseConfig db, string basePath)
    {
        log($"Reading database: {db.Name}");

        //var fileEncoding = db.ParseFileEncoding();

        //List<string> dirs = new List<string>();

        //if (db.SourceDirectories != null)
        //    foreach (var dir in db.SourceDirectories)
        //        dirs.Add(basePath + Path.DirectorySeparatorChar + dir);

        var pathsExists = ParseExistingFilesAndDirs(basePath, db.SourceDirectories).ToList();
        log($"Reading models from:");
        foreach (var srcPath in pathsExists)
        {
            if (srcPath.HasFailed)
                return $"Error: {srcPath.Failure}";

            log($"{srcPath}");
        }

        var paths = pathsExists.Select(x => x.Value).ToList();

        if (db.DestinationDirectory != null)
            paths.Add(basePath + Path.DirectorySeparatorChar + db.DestinationDirectory);

        //var assemblyPathsExists = ParseExistingFilesAndDirs(basePath, db.AssemblyDirectories).ToList();
        //if (assemblyPathsExists.Any())
        //{
        //    log($"Reading assemblies from:");
        //    foreach (var path in assemblyPathsExists)
        //        log($"{path}");
        //}

        //var srcDir = dirs[0];

        //if (Directory.Exists(srcDir))
        //{
        //log($"Reading models from: {srcDir}");

        var metadataOptions = new MetadataFromFileFactoryOptions { FileEncoding = db.FileEncoding, RemoveInterfacePrefix = db.RemoveInterfacePrefix };
        DatabaseDefinition srcMetadata = new MetadataFromFileFactory(metadataOptions, log).ReadFiles(db.CsType, paths);

        log($"Tables in model files: {srcMetadata.TableModels.Length}");
        //}
        //else
        //{
        //    log($"Couldn't read from SourceDirectory: {srcDir}");
        //}

        var sqlOptions = new MetadataFromDatabaseFactoryOptions
        {
            CapitaliseNames = true,
            DeclareEnumsInClass = true,
            Tables = db.Tables,
            Views = db.Views,
        };

        foreach (var connection in db.Connections)
        {
            log($"Type: {connection.Type}");

            //var databaseName = connection.DatabaseName;
            //string path = null;
            //if (connection.Type == DatabaseType.SQLite)
            //{
            //    if (Path.IsPathRooted(databaseName))

            //    if (Path.IsPathRooted(connection.ConnectionString.Path)

            //    databaseName = Path.Combine(basePath, databaseName);
            //}

            var connectionString = connection.ConnectionString;
            if (connection.Type == DatabaseType.SQLite)
                connectionString = connectionString.ChangeValue("Data Source", connection.GetRootedPath(basePath)); // $"Data Source={databaseName};Cache=Shared;";

            DatabaseDefinition dbMetadata = PluginHook.MetadataFromSqlFactories[connection.Type]
                .GetMetadataFromSqlFactory(sqlOptions)
                .ParseDatabase(db.Name, db.CsType, db.Namespace, connection.DataSourceName, connectionString.Original);

            //var dbMetadata = connection.ParsedType switch
            //{
            //    DatabaseType.MySQL =>
            //        new MySql.MetadataFromSqlFactory(sqlOptions).ParseDatabase(db.Name, db.CsType, connection.DatabaseName, new MySqlDatabase<information_schema>(connection.ConnectionString, "information_schema").Query()),
            //    DatabaseType.SQLite =>
            //        new SQLite.MetadataFromSqlFactory(sqlOptions).ParseDatabase(db.Name, db.CsType, connection.DatabaseName, connection.ConnectionString)
            //};

            log($"Name in database: {dbMetadata.DbName}");
            log($"Tables read from database: {dbMetadata.TableModels.Length}");
        }

        return true;
    }
}

================
File: src/DataLinq.Tools/SqlGenerator.cs
================
using System;
using System.IO;
using System.Linq;
using System.Text;
using DataLinq.Config;
using DataLinq.Core.Factories.Models;
using DataLinq.Extensions;
using DataLinq.Extensions.Helpers;
using DataLinq.Metadata;
using DataLinq.MySql;
using DataLinq.Query;
using DataLinq.SQLite;
using ThrowAway;
using ThrowAway.Extensions;

namespace DataLinq.Tools;

public enum SqlGeneratorError
{
    DestDirectoryNotFound,
    UnableToParseModelFiles,
    CouldNotGenerateSql
}

public struct SqlGeneratorOptions
{
}

public class SqlGenerator : Generator
{
    private readonly SqlGeneratorOptions options;

    static SqlGenerator()
    {
        MySQLProvider.RegisterProvider();
        SQLiteProvider.RegisterProvider();
    }

    public SqlGenerator(Action<string> log, SqlGeneratorOptions options) : base(log)
    {
        this.options = options;
    }

    public Option<Sql, SqlGeneratorError> Create(DataLinqDatabaseConnection connection, string basePath, string writePath)
    {
        log($"Type: {connection.Type}");

        var db = connection.DatabaseConfig;
        var fileEncoding = db.FileEncoding;

        var destDir = basePath + Path.DirectorySeparatorChar + db.DestinationDirectory;
        if (!Directory.Exists(destDir))
        {
            log($"Couldn't find dir: {destDir}");
            return SqlGeneratorError.DestDirectoryNotFound;
        }

        //var assemblyPathsExists = ParseExistingFilesAndDirs(basePath, db.AssemblyDirectories).ToList();
        //if (assemblyPathsExists.Any())
        //{
        //    log($"Reading assemblies from:");
        //    foreach (var assemblyPath in assemblyPathsExists)
        //        log($"{assemblyPath}");
        //}

        var options = new MetadataFromFileFactoryOptions { FileEncoding = fileEncoding, RemoveInterfacePrefix = db.RemoveInterfacePrefix };
        if (!new MetadataFromFileFactory(options, log).ReadFiles(db.CsType, destDir.Yield().ToList()).TryUnwrap(out var dbMetadata, out var metaDataFailure))
        {
            log(metaDataFailure);
            return SqlGeneratorError.UnableToParseModelFiles;
        }
        //if (dbMetadata.HasFailed)
        //{
        //    log("Error: Unable to parse model files.");
        //    return SqlGeneratorError.UnableToParseModelFiles;
        //}

        log($"Tables in model files: {dbMetadata.TableModels.Length}");
        log($"Writing sql to: {writePath}");

        var sql = PluginHook.GenerateSql(connection.Type, dbMetadata, true);

        if (sql.HasFailed)
        {
            log(sql.Failure.ToString());
            return SqlGeneratorError.CouldNotGenerateSql;
        }

        File.WriteAllText(writePath, sql.Value.Text, Encoding.UTF8);

        return sql.Value;
    }
}

================
File: src/DataLinq/Cache/CacheHistory.cs
================
using System;
using System.Collections.Generic;
using System.Linq;

namespace DataLinq.Cache;

public class CacheHistory(uint maxCapacity = 10000)
{
    public uint Count { get; private set; }
    public uint MaxCapacity { get; set; } = maxCapacity;

    public event Action<DatabaseCacheSnapshot>? OnAdd;

    private LinkedList<DatabaseCacheSnapshot> history = new();
    private readonly object lockObject = new();

    public void Add(DatabaseCacheSnapshot snapshot)
    {
        ArgumentNullException.ThrowIfNull(snapshot);

        lock (lockObject)
        {
            history.AddLast(snapshot);
            Count++;

            while (Count > MaxCapacity)
            {
                Count--;
                history.RemoveFirst();
            }
        }

        OnAdd?.Invoke(snapshot);
    }

    public DatabaseCacheSnapshot[] GetHistory()
    {
        return history.ToArray();
    }

    public DatabaseCacheSnapshot? GetLatest()
    {
        return history.Last?.Value;
    }

    public void Clear()
    {
        history.Clear();
        Count = 0;
    }
}

================
File: src/DataLinq/Cache/DatabaseCache.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Attributes;
using DataLinq.Extensions.Helpers;
using DataLinq.Interfaces;
using DataLinq.Logging;
using DataLinq.Metadata;
using DataLinq.Mutation;
using DataLinq.Workers;

namespace DataLinq.Cache;

public class DatabaseCache : IDisposable
{
    public IDatabaseProvider Database { get; set; }
    private readonly DataLinqLoggingConfiguration loggingConfiguration;
    public Dictionary<TableDefinition, TableCache> TableCaches { get; }

    public CleanCacheWorker? CleanCacheWorker { get; }

    public CacheHistory History { get; } = new();

    public DatabaseCache(IDatabaseProvider database, DataLinqLoggingConfiguration loggingConfiguration)
    {
        this.Database = database;
        this.loggingConfiguration = loggingConfiguration;
        this.TableCaches = this.Database.Metadata.TableModels
            .ToDictionary(x => x.Table, x => new TableCache(x.Table, this, loggingConfiguration));

        this.MakeSnapshot();

        var cacheCleanupInterval = database.Metadata.CacheCleanup;

        if (!cacheCleanupInterval.Any())
            cacheCleanupInterval = (CacheCleanupType.Minutes, 5L).Yield().ToList();

        foreach (var timespan in cacheCleanupInterval.Select(x => GetFromCacheCleanupType(x.cleanupType, x.amount)))
        {
            this.CleanCacheWorker = new CleanCacheWorker(database, new LongRunningTaskCreator(), timespan);
            this.CleanCacheWorker.Start();
        }
    }

    //public TableCache GetTableCache(string tableName)
    //{
    //    return TableCaches.Single(x => x.Table.DbName == tableName);
    //}

    public TableCache GetTableCache(TableDefinition table)
    {
        return TableCaches[table];
    }

    public DatabaseCacheSnapshot GetLatestSnapshot()
    {
        return History.GetLatest() ?? MakeSnapshot();
    }

    public DatabaseCacheSnapshot MakeSnapshot()
    {
        var snapshot = new DatabaseCacheSnapshot(DateTime.UtcNow, TableCaches.Values.Select(x => x.MakeSnapshot()).ToArray());
        History.Add(snapshot);

        return snapshot;
    }

    private TimeSpan GetFromCacheCleanupType(CacheCleanupType type, long amount)
    {
        return type switch
        {
            CacheCleanupType.Seconds => TimeSpan.FromSeconds(amount),
            CacheCleanupType.Minutes => TimeSpan.FromMinutes(amount),
            CacheCleanupType.Hours => TimeSpan.FromHours(amount),
            CacheCleanupType.Days => TimeSpan.FromDays(amount),
            _ => throw new NotImplementedException(),
        };
    }

    public (IndexCacheType, int? amount) GetIndexCachePolicy()
    {
        if (!Database.Metadata.IndexCache.Any() || Database.Metadata.IndexCache.Any(x => x.indexCacheType == IndexCacheType.None))
            return (IndexCacheType.None, 0);

        if (Database.Metadata.IndexCache.Any(x => x.indexCacheType == IndexCacheType.MaxAmountRows))
            return (IndexCacheType.MaxAmountRows, Database.Metadata.IndexCache.First(x => x.indexCacheType == IndexCacheType.MaxAmountRows).amount);

        if (Database.Metadata.IndexCache.Any(x => x.indexCacheType == IndexCacheType.All))
            return (IndexCacheType.All, null);

        throw new NotImplementedException();
    }


    public void ApplyChanges(IEnumerable<StateChange> changes, Transaction? transaction = null)
    {
        foreach (var change in changes.GroupBy(x => x.Table))
        {
            TableCaches[change.Key].ApplyChanges(change, transaction);
        }
    }

    public void RemoveTransaction(Transaction transaction)
    {
        foreach (var table in TableCaches.Values)
        {
            table.TryRemoveTransaction(transaction);
        }
    }

    public IEnumerable<(TableCache table, int numRows)> RemoveRowsBySettings()
    {
        foreach (var table in TableCaches.Values)
        {
            foreach (var (limitType, amount) in table.Table.CacheLimits)
            {
                foreach (var rows in RemoveRowsByLimit(limitType, amount))
                    yield return rows;
            }
        }

        foreach (var (limitType, amount) in Database.Metadata.CacheLimits)
        {
            foreach (var rows in RemoveRowsByLimit(limitType, amount))
                yield return rows;
        }
    }

    public IEnumerable<(TableCache table, int numRows)> RemoveRowsByLimit(CacheLimitType limitType, long amount)
    {
        foreach (var table in TableCaches.Values)
        {
            var numRows = table.RemoveRowsByLimit(limitType, amount);

            if (numRows > 0)
                yield return (table, numRows);
        }
    }

    public IEnumerable<(TableCache table, int numRows)> RemoveRowsInsertedBeforeTick(long tick)
    {
        foreach (var table in TableCaches.Values)
        {
            var numRows = table.RemoveRowsInsertedBeforeTick(tick);

            if (numRows > 0)
                yield return (table, numRows);
        }
    }

    public void ClearCache()
    {
        foreach (var table in TableCaches.Values)
        {
            table.ClearCache();
        }
    }

    public void Dispose()
    {
        this.CleanCacheWorker?.Stop();
        this.ClearCache();
    }
}

================
File: src/DataLinq/Cache/DatabaseCacheSnapshot.cs
================
using System;
using System.Linq;
using DataLinq.Utils;

namespace DataLinq.Cache;

public class DatabaseCacheSnapshot(DateTime timestamp, TableCacheSnapshot[] tableCaches)
{
    public DateTime Timestamp { get; } = timestamp;
    public TableCacheSnapshot[] TableCaches { get; } = tableCaches;

    public long? NewestTick => TableCaches.Max(x => x.NewestTick);
    public long? OldestTick => TableCaches.Min(x => x.OldestTick);
    public int RowCount => TableCaches.Sum(x => x.RowCount);
    public long TotalBytes => TableCaches.Sum(x => x.TotalBytes);
    public string TotalBytesFormatted => TotalBytes.ToFileSize();
    public DateTime? NewestDateTime => NewestTick.HasValue ? new(NewestTick.Value) : null;
    public DateTime? OldestDateTime => OldestTick.HasValue ? new(OldestTick.Value) : null;
}

================
File: src/DataLinq/Cache/IndexCache.cs
================
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Instances;

namespace DataLinq.Cache;

public class IndexCache
{
    private readonly object ticksQueueLock = new();
    private (IKey keys, long ticks)? oldestTick;
    private readonly Queue<(IKey keys, long ticks)> ticks = new();

    private ConcurrentDictionary<IKey, List<IKey>> primaryKeysToForeignKeys = new();

    protected ConcurrentDictionary<IKey, IKey[]> foreignKeys = new();

    public int Count => foreignKeys.Count;

    public bool TryAdd(IKey foreignKey, IKey[] primaryKeys)
    {
        var ticksNow = DateTime.Now.Ticks;

        if (!foreignKeys.TryAdd(foreignKey, primaryKeys))
            return false;

        lock (ticksQueueLock)
        {
            ticks.Enqueue((foreignKey, ticksNow));

            if (!oldestTick.HasValue)
                oldestTick = (foreignKey, ticksNow);
        }

        foreach (var primaryKey in primaryKeys)
        {
            primaryKeysToForeignKeys.AddOrUpdate(primaryKey,
                new List<IKey> { foreignKey },
                (key, existingList) =>
                {
                    existingList.Add(foreignKey);
                    return existingList;
                });
        }

        return true;
    }

    public bool TryRemoveForeignKey(IKey foreignKey, out int numRowsRemoved)
    {
        numRowsRemoved = 0;

        if (foreignKeys.ContainsKey(foreignKey))
        {
            if (foreignKeys.TryRemove(foreignKey, out var pks))
            {
                numRowsRemoved = 1;
                foreach (var pk in pks)
                {
                    if (primaryKeysToForeignKeys.TryGetValue(pk, out var foreignKeysList))
                    {
                        foreignKeysList.Remove(foreignKey);
                        if (foreignKeysList.Count == 0)
                        {
                            primaryKeysToForeignKeys.TryRemove(pk, out _);
                        }
                    }
                }
                return true;
            }
            else
                return false;
        }

        return true;
    }

    public IEnumerable<IKey> GetForeignKeysByPrimaryKey(IKey primaryKey)
    {
        if (primaryKeysToForeignKeys.TryGetValue(primaryKey, out var foreignKeys))
            return foreignKeys;

        return Enumerable.Empty<IKey>();
    }

    public bool TryRemovePrimaryKey(IKey primaryKey, out int numRowsRemoved)
    {
        numRowsRemoved = 0;

        foreach (var fk in GetForeignKeysByPrimaryKey(primaryKey).ToList())
        {
            TryRemoveForeignKey(fk, out var num);
            numRowsRemoved += num;
        }

        return true;
    }

    public int RemoveInsertedBeforeTick(long tick)
    {
        if (!oldestTick.HasValue)
            return 0;

        var count = 0;
        lock (ticksQueueLock)
        {
            while (oldestTick?.ticks < tick)
            {
                if (TryRemoveForeignKey(oldestTick.Value.keys, out var numRowsRemoved))
                {
                    count += numRowsRemoved;

                    ticks.TryDequeue(out var _);
                }
                else
                    break;

                if (ticks.TryPeek(out var nextTick))
                    oldestTick = nextTick;
                else
                {
                    oldestTick = null;
                    break;
                }
            }
        }

        return count;
    }

    public bool ContainsKey(IKey foreignKey) => foreignKeys.ContainsKey(foreignKey);

    public bool TryGetValue(IKey foreignKey, out IKey[]? keys) => foreignKeys.TryGetValue(foreignKey, out keys);

    public IEnumerable<IKey[]> Values => foreignKeys.Values;

    public void Clear()
    {
        foreignKeys.Clear();
        ticks.Clear();
        oldestTick = null;
    }
}

================
File: src/DataLinq/Cache/KeyCache.cs
================
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using DataLinq.Instances;

namespace DataLinq.Cache;
public class KeyCache<T> where T : IKey
{
    private ConcurrentDictionary<int, T> cachedKeys = new();

    public int Count => cachedKeys.Count;
    public IEnumerable<T> Values => cachedKeys.Values;

    public bool TryAdd(T keys) => cachedKeys.TryAdd(keys.GetHashCode(), keys);

    public bool ContainsKey(int hashCode) => cachedKeys.ContainsKey(hashCode);
    public bool ContainsKey(T keys) => cachedKeys.ContainsKey(keys.GetHashCode());

    public bool TryGetValue(int hashCode, out T? keys) => cachedKeys.TryGetValue(hashCode, out keys);

    public void Clear()
    {
        cachedKeys.Clear();
    }
}

================
File: src/DataLinq/Cache/RowCache.cs
================
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Instances;
using DataLinq.Utils;

namespace DataLinq.Cache;

public class RowCache
{
    private readonly object keyTicksQueueLock = new();
    private (IKey keys, long ticks, int size)? oldestKeyTick;
    private readonly Queue<(IKey keys, long ticks, int size)> keysTicks = new();

    protected ConcurrentDictionary<IKey, IImmutableInstance> rows = new();

    public IEnumerable<IImmutableInstance> Rows => rows.Values.AsEnumerable();
    public int Count => rows.Count;

    public long? OldestTick => oldestKeyTick?.ticks;
    public long? NewestTick
    {
        get
        {
            if (!oldestKeyTick.HasValue)
                return null;

            lock (keyTicksQueueLock)
            {
                // Get the last element or use default (an empty tuple)
                var lastItem = keysTicks.LastOrDefault();

                // If the queue is empty, the default is returned and all elements of the tuple will be default values
                return lastItem.Equals(default) ? null : lastItem.ticks;
            }
        }
    }

    public long TotalBytes
    {
        get
        {
            lock (keyTicksQueueLock)
            {
                return keysTicks.Sum(x => x.size);
            }
        }
    }

    public string TotalBytesFormatted => TotalBytes.ToFileSize();

    public void ClearRows()
    {
        rows.Clear();
        lock (keyTicksQueueLock)
        {
            keysTicks.Clear();
        }
        oldestKeyTick = null;
    }

    public int RemoveRowsOverRowLimit(int maxRows)
    {
        var count = 0;
        var rowCount = rows.Count;

        if (rowCount <= maxRows)
            return 0;

        lock (keyTicksQueueLock)
        {
            if (!oldestKeyTick.HasValue)
                return 0;

            while (rowCount > maxRows)
            {
                if (TryRemoveRow(oldestKeyTick.Value.keys, out var numRowsRemoved))
                {
                    rowCount -= numRowsRemoved;
                    count += numRowsRemoved;

                    keysTicks.TryDequeue(out _);

                    if (keysTicks.TryPeek(out var nextTick))
                        oldestKeyTick = nextTick;
                    else
                    {
                        oldestKeyTick = null;
                        break;
                    }
                }
                else
                    break;
            }
        }

        return count;
    }

    public int RemoveRowsOverSizeLimit(long maxSize)
    {
        var count = 0;
        var totalSize = TotalBytes;

        if (totalSize <= maxSize)
            return 0;

        lock (keyTicksQueueLock)
        {
            if (!oldestKeyTick.HasValue)
                return 0;

            while (totalSize > maxSize)
            {
                if (TryRemoveRow(oldestKeyTick.Value.keys, out var numRowsRemoved))
                {
                    totalSize -= oldestKeyTick.Value.size;
                    count += numRowsRemoved;

                    keysTicks.TryDequeue(out _);

                    if (keysTicks.TryPeek(out var nextTick))
                        oldestKeyTick = nextTick;
                    else
                    {
                        oldestKeyTick = null;
                        break;
                    }
                }
                else
                    break;
            }
        }

        return count;
    }

    public int RemoveRowsInsertedBeforeTick(long tick)
    {
        if (!oldestKeyTick.HasValue)
            return 0;

        var count = 0;
        lock (keyTicksQueueLock)
        {
            while (oldestKeyTick?.ticks < tick)
            {
                if (TryRemoveRow(oldestKeyTick.Value.keys, out var numRowsRemoved))
                {
                    count += numRowsRemoved;

                    keysTicks.TryDequeue(out var _);
                }
                else
                    break;

                if (keysTicks.TryPeek(out var nextTick))
                    oldestKeyTick = nextTick;
                else
                {
                    oldestKeyTick = null;
                    break;
                }
            }
        }

        return count;
    }

    public bool TryGetValue(IKey primaryKeys, out IImmutableInstance? row) => rows.TryGetValue(primaryKeys, out row);

    public bool TryRemoveRow(IKey primaryKeys, out int numRowsRemoved)
    {
        numRowsRemoved = 0;

        if (rows.ContainsKey(primaryKeys))
        {
            if (rows.TryRemove(primaryKeys, out var _))
            {
                numRowsRemoved = 1;
                return true;
            }
            else
                return false;
        }

        return true;
    }

    public bool TryAddRow(IKey keys, RowData data, IImmutableInstance instance)
    {
        var ticks = DateTime.Now.Ticks;

        if (!rows.TryAdd(keys, instance))
            return false;

        lock (keyTicksQueueLock)
        {
            keysTicks.Enqueue((keys, ticks, data.Size));

            if (!oldestKeyTick.HasValue)
                oldestKeyTick = (keys, ticks, data.Size);
        }


        return true;
    }
}

================
File: src/DataLinq/Cache/TableCache.cs
================
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Attributes;
using DataLinq.Extensions.Helpers;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Logging;
using DataLinq.Metadata;
using DataLinq.Mutation;
using DataLinq.Query;

namespace DataLinq.Cache;

public class RowChangeEventArgs : EventArgs
{
    // For now, we can keep this empty since a full clear is acceptable.
}

public class TableCache
{
    protected Dictionary<ColumnIndex, IndexCache> IndexCaches;
    protected KeyCache<IKey> PrimaryKeysCache = new();
    protected RowCache RowCache = new();
    protected ConcurrentDictionary<Transaction, RowCache> TransactionRows = new();

    protected int primaryKeyColumnsCount;
    protected List<ColumnIndex> indices;
    protected (IndexCacheType type, int? amount) indexCachePolicy;
    private readonly DataLinqLoggingConfiguration loggingConfiguration;

    public event EventHandler<RowChangeEventArgs>? RowChanged;

    public TableCache(TableDefinition table, DatabaseCache databaseCache, DataLinqLoggingConfiguration loggingConfiguration)
    {
        this.Table = table;
        this.DatabaseCache = databaseCache;
        this.loggingConfiguration = loggingConfiguration;
        this.primaryKeyColumnsCount = Table.PrimaryKeyColumns.Length;
        this.indices = Table.ColumnIndices;
        this.indexCachePolicy = GetIndexCachePolicy();

        IndexCaches = indices.ToDictionary(x => x, _ => new IndexCache());
    }

    public long? OldestTick => RowCache.OldestTick;
    public long? NewestTick => RowCache.NewestTick;
    public int RowCount => RowCache.Count;
    public long TotalBytes => RowCache.TotalBytes;
    public string TotalBytesFormatted => RowCache.TotalBytesFormatted;
    public int TransactionRowsCount => TransactionRows.Count;
    public IEnumerable<(string index, int count)> IndicesCount => indices.Select(x => (x.Name, IndexCaches[x].Count));

    public TableDefinition Table { get; }
    public DatabaseCache DatabaseCache { get; }

    public bool IsTransactionInCache(Transaction transaction) => TransactionRows.ContainsKey(transaction);
    public IEnumerable<IImmutableInstance> GetTransactionRows(Transaction transaction)
    {
        if (TransactionRows.TryGetValue(transaction, out var result))
            return result.Rows;

        return new List<IImmutableInstance>();
    }

    public int ApplyChanges(IEnumerable<StateChange> changes, Transaction? transaction = null)
    {
        var numRows = 0;

        foreach (var change in changes)
        {
            if (change.Table != Table)
                continue;

            if (change.Type == TransactionChangeType.Delete || change.Type == TransactionChangeType.Update)
            {
                if (transaction != null)
                {
                    if (TryRemoveTransactionRow(change.PrimaryKeys, transaction, out var transRows))
                        numRows += transRows;
                }

                RowCache.TryRemoveRow(change.PrimaryKeys, out var rows);
                numRows += rows;
            }


            TryRemoveRowFromAllIndices(change.PrimaryKeys, out var indexRows);
            numRows += indexRows;

            if (change.Type == TransactionChangeType.Update)
            {
                var changedValues = change.GetChanges().ToList();
                foreach (var columnIndex in change.Table.ColumnIndices.Where(x => changedValues.Any(y => x.Columns.Contains(y.Key))))
                    RemoveIndexOnBothSides(columnIndex, change.Model);
            }
            else
            {
                foreach (var columnIndex in change.Table.ColumnIndices)
                {
                    RemoveIndexOnBothSides(columnIndex, change.Model);
                }
            }
        }

        // At this point, all cache changes have been applied.
        // Raise the event to notify any observers that a change has occurred.
        OnRowChanged(new RowChangeEventArgs());

        return numRows;

        int RemoveIndexOnBothSides(ColumnIndex columnIndex, IModelInstance model)
        {
            var fk = KeyFactory.CreateKeyFromValues(model.GetValues(columnIndex.Columns).Select(x => x.Value));

            if (TryRemoveForeignKeyIndex(columnIndex, fk, out var indexRowsThisSide))
                numRows += indexRowsThisSide;

            foreach (var index in columnIndex.RelationParts.Select(x => x.GetOtherSide().ColumnIndex))
                if (DatabaseCache.GetTableCache(index.Table).TryRemoveForeignKeyIndex(index, fk, out var indexRowsOtherSide))
                    numRows += indexRowsOtherSide;

            return numRows;
        }
    }

    protected virtual void OnRowChanged(RowChangeEventArgs e)
    {
        RowChanged?.Invoke(this, e);
    }

    public (IndexCacheType, int? amount) GetIndexCachePolicy()
    {
        if (!Table.IndexCache.Any())
            return DatabaseCache.GetIndexCachePolicy();

        if (Table.IndexCache.Any(x => x.indexCacheType == IndexCacheType.None))
            return (IndexCacheType.None, 0);

        if (Table.IndexCache.Any(x => x.indexCacheType == IndexCacheType.MaxAmountRows))
            return (IndexCacheType.MaxAmountRows, Table.IndexCache.First(x => x.indexCacheType == IndexCacheType.MaxAmountRows).amount);

        if (Table.IndexCache.Any(x => x.indexCacheType == IndexCacheType.All))
            return (IndexCacheType.All, null);

        throw new NotImplementedException();
    }

    public void ClearCache()
    {
        ClearRows();
        ClearIndex();
    }

    public void ClearRows()
    {
        RowCache.ClearRows();
    }

    public void ClearIndex()
    {
        for (var i = 0; i < indices.Count; i++)
            IndexCaches[indices[i]].Clear();
    }

    public int RemoveRowsByLimit(CacheLimitType limitType, long amount)
    {
        if (limitType == CacheLimitType.Seconds)
            return RemoveRowsInsertedBeforeTick(DateTime.Now.Subtract(TimeSpan.FromSeconds(amount)).Ticks);

        if (limitType == CacheLimitType.Minutes)
            return RemoveRowsInsertedBeforeTick(DateTime.Now.Subtract(TimeSpan.FromMinutes(amount)).Ticks);

        if (limitType == CacheLimitType.Hours)
            return RemoveRowsInsertedBeforeTick(DateTime.Now.Subtract(TimeSpan.FromHours(amount)).Ticks);

        if (limitType == CacheLimitType.Days)
            return RemoveRowsInsertedBeforeTick(DateTime.Now.Subtract(TimeSpan.FromDays(amount)).Ticks);

        if (limitType == CacheLimitType.Ticks)
            return RemoveRowsInsertedBeforeTick(DateTime.Now.Subtract(TimeSpan.FromTicks(amount)).Ticks);

        if (limitType == CacheLimitType.Rows)
            return RowCache.RemoveRowsOverRowLimit((int)amount);

        if (limitType == CacheLimitType.Bytes)
            return RowCache.RemoveRowsOverSizeLimit(amount);

        if (limitType == CacheLimitType.Kilobytes)
            return RowCache.RemoveRowsOverSizeLimit(amount * 1024);

        if (limitType == CacheLimitType.Megabytes)
            return RowCache.RemoveRowsOverSizeLimit(amount * 1024 * 1024);

        if (limitType == CacheLimitType.Gigabytes)
            return RowCache.RemoveRowsOverSizeLimit(amount * 1024 * 1024 * 1024);

        throw new NotImplementedException();
    }

    public int RemoveRowsInsertedBeforeTick(long tick)
    {
        RemoveAllIndicesInsertedBeforeTick(tick);
        return RowCache.RemoveRowsInsertedBeforeTick(tick);
    }


    public void TryRemoveRowFromAllIndices(IKey primaryKeys, out int numRowsRemoved)
    {
        numRowsRemoved = 0;

        for (var i = 0; i < indices.Count; i++)
        {
            if (IndexCaches[indices[i]].TryRemovePrimaryKey(primaryKeys, out var rowsRemoved))
                numRowsRemoved += rowsRemoved;
        }
    }

    public bool TryRemoveForeignKeyIndex(ColumnIndex columnIndex, IKey foreignKey, out int numRowsRemoved) =>
        IndexCaches[columnIndex].TryRemoveForeignKey(foreignKey, out numRowsRemoved);

    public bool TryRemovePrimaryKeyIndex(ColumnIndex columnIndex, IKey primaryKeys, out int numRowsRemoved) =>
        IndexCaches[columnIndex].TryRemovePrimaryKey(primaryKeys, out numRowsRemoved);

    public int RemoveAllIndicesInsertedBeforeTick(long tick) =>
        IndexCaches.Select(x => x.Value.RemoveInsertedBeforeTick(tick)).Sum();

    public bool TryRemoveTransactionRow(IKey primaryKeys, Transaction transaction, out int numRowsRemoved)
    {
        numRowsRemoved = 0;

        return TransactionRows.TryGetValue(transaction, out RowCache? rowCache) && rowCache.TryRemoveRow(primaryKeys, out numRowsRemoved);
    }

    public bool TryRemoveTransaction(Transaction transaction)
    {
        if (TransactionRows.ContainsKey(transaction))
            return TransactionRows.TryRemove(transaction, out var _);

        return true;
    }

    public void PreloadIndex(IKey foreignKey, RelationProperty otherSide, int? limitRows = null)
    {
        var index = otherSide.RelationPart.GetOtherSide().ColumnIndex;

        var select = new SqlQuery(Table, DatabaseCache.Database.ReadOnlyAccess)
            .What(Table.PrimaryKeyColumns.Concat(index.Columns).Distinct())
            .WhereNot(index.Columns.Select(y => (y.DbName, null as object)));

        var query = select
            .OrderByDesc(index.Columns[0].DbName);

        if (limitRows.HasValue)
            query.Limit(limitRows.Value);

        foreach (var (fk, pk) in query.SelectQuery().ReadPrimaryAndForeignKeys(index))
            IndexCaches[index].TryAdd(fk, pk);


        var otherColumns = otherSide.RelationPart.ColumnIndex.Columns;
        select = new SqlQuery(otherSide.Model.Table, DatabaseCache.Database.ReadOnlyAccess, "other")
            .What(otherSide.Model.Table.PrimaryKeyColumns)
            .LeftJoin(Table.DbName, "this")
                .On(index.Columns[0].DbName, "this")
                .EqualToColumn(otherColumns[0].DbName, "other");

        if (index.Columns.Count > 1)
        {
            for (var i = 1; i < index.Columns.Count; i++)
                select.And(index.Columns[i].DbName, "this").EqualToColumn(otherColumns[i].DbName, "other");
        }

        query = select
            .Where(index.Columns.Select(y => (y.DbName, null as object)), BooleanType.And, "this")
            .OrderByDesc(otherColumns[0].DbName, "other");

        if (limitRows.HasValue)
            query.Limit(limitRows.Value);

        foreach (var pk in query.SelectQuery().ReadKeys())
            IndexCaches[index].TryAdd(pk, []);
    }

    public IKey[] GetKeys(IKey foreignKey, RelationProperty otherSide, DataSourceAccess dataSource)
    {
        var index = otherSide.RelationPart.GetOtherSide().ColumnIndex;
        if (Table.PrimaryKeyColumns.SequenceEqual(index.Columns))
            return [foreignKey];

        if (dataSource is ReadOnlyAccess && indexCachePolicy.type != IndexCacheType.None)
        {
            if (IndexCaches[index].TryGetValue(foreignKey, out var keys))
                return keys!;

            //if (IndexCaches[index].Count == 0)
            //{
            //    PreloadIndex(foreignKey, otherSide, indexCachePolicy.type == IndexCacheType.MaxAmountRows ? indexCachePolicy.amount : null);
            //    Log.IndexCachePreload(loggingConfiguration.CacheLogger, index, IndexCaches[index].Count);

            //    var rowCount = GetRows(IndexCaches[index].Values.SelectMany(x => x).Take(1000).ToArray(), dataSource).Count();
            //    Log.RowCachePreload(loggingConfiguration.CacheLogger, Table, rowCount);

            //    if (IndexCaches[index].TryGetValue(foreignKey, out var retryKeys))
            //        return retryKeys!;
            //}
        }

        var select = new SqlQuery(Table, dataSource ?? DatabaseCache.Database.ReadOnlyAccess)
            .What(Table.PrimaryKeyColumns)
            .Where(index.Columns.Select((x, i) => (x.DbName, foreignKey.Values[i])))
            .SelectQuery();

        var newKeys = KeyFactory.GetKeys(select, Table.PrimaryKeyColumns).ToArray();

        if (indexCachePolicy.type != IndexCacheType.None)
            IndexCaches[index].TryAdd(foreignKey, newKeys);

        return newKeys;
    }

    public IEnumerable<IImmutableInstance> GetRows(IKey foreignKey, RelationProperty otherSide, DataSourceAccess dataSource)
    {
        if (foreignKey is NullKey)
            return [];

        return GetRows(GetKeys(foreignKey, otherSide, dataSource), dataSource);
    }

    public IImmutableInstance? GetRow(IKey primaryKeys, DataSourceAccess dataSource) =>
        GetRows([primaryKeys], dataSource).SingleOrDefault();

    public IEnumerable<IImmutableInstance> GetRows(IKey[] primaryKeys, DataSourceAccess dataSource, List<OrderBy>? orderings = null)
    {
        if (dataSource is Transaction transaction && transaction.Type != TransactionType.ReadOnly && !TransactionRows.ContainsKey(transaction))
            TransactionRows.TryAdd(transaction, new RowCache());

        if (orderings == null || orderings.Count == 0)
            return LoadRowsFromDatabaseAndCache(primaryKeys, dataSource);
        else
            return LoadOrderedRowsFromDatabaseAndCache(primaryKeys, dataSource, orderings);
    }

    private IEnumerable<IImmutableInstance> LoadRowsFromDatabaseAndCache(IKey[] primaryKeys, DataSourceAccess dataSource)
    {
        dataSource ??= DatabaseCache.Database.ReadOnlyAccess;

        var keysToLoad = new List<IKey>(primaryKeys.Length);
        foreach (var key in primaryKeys)
        {
            if (GetRowFromCache(key, dataSource, out var row))
                yield return row!;
            else
                keysToLoad.Add(key);
        }

        Log.LoadRowsFromCache(loggingConfiguration.CacheLogger, Table, primaryKeys.Length - keysToLoad.Count);

        if (keysToLoad.Count != 0)
        {
            foreach (var split in keysToLoad.SplitList(500))
            {
                foreach (var rowData in GetRowDataFromPrimaryKeys(split, dataSource))
                {
                    yield return AddRow(rowData, dataSource);
                }
            }

            Log.LoadRowsFromDatabase(loggingConfiguration.CacheLogger, Table, keysToLoad.Count);
        }
    }

    private IEnumerable<IImmutableInstance> LoadOrderedRowsFromDatabaseAndCache(IKey[] primaryKeys, DataSourceAccess dataSource, List<OrderBy> orderings)
    {
        dataSource ??= DatabaseCache.Database.ReadOnlyAccess;

        var keysToLoad = new List<IKey>(primaryKeys.Length);
        var loadedRows = new List<IImmutableInstance>(primaryKeys.Length);

        foreach (var key in primaryKeys)
        {
            if (GetRowFromCache(key, dataSource, out var row))
                loadedRows.Add(row!);
            else
                keysToLoad.Add(key);
        }

        Log.LoadRowsFromCache(loggingConfiguration.CacheLogger, Table, loadedRows.Count);

        if (keysToLoad.Count != 0)
        {
            foreach (var split in keysToLoad.SplitList(500))
            {
                foreach (var rowData in GetRowDataFromPrimaryKeys(split, dataSource, orderings))
                {
                    loadedRows.Add(AddRow(rowData, dataSource));
                }
            }

            Log.LoadRowsFromDatabase(loggingConfiguration.CacheLogger, Table, keysToLoad.Count);
        }

        IOrderedEnumerable<IImmutableInstance>? orderedRows = null;

        foreach (var ordering in orderings)
        {
            Func<IImmutableInstance, IComparable?> keySelector = x => (IComparable?)x.GetValues([ordering.Column]).First().Value;

            if (orderedRows == null)
            {
                orderedRows = ordering.Ascending
                    ? loadedRows.OrderBy(keySelector)
                    : loadedRows.OrderByDescending(keySelector);
            }
            else
            {
                orderedRows = ordering.Ascending
                    ? orderedRows.ThenBy(keySelector)
                    : orderedRows.ThenByDescending(keySelector);
            }
        }

        return orderedRows == null
            ? loadedRows
            : orderedRows;
    }

    private IEnumerable<RowData> GetRowDataFromPrimaryKeys(IEnumerable<IKey> keys, DataSourceAccess dataSource, List<OrderBy>? orderings = null)
    {
        var q = new SqlQuery(Table.DbName, dataSource);

        if (Table.PrimaryKeyColumns.Length == 1)
        {
            q.Where(Table.PrimaryKeyColumns[0].DbName).In(keys.Select(x => dataSource.Provider.GetWriter().ConvertColumnValue(Table.PrimaryKeyColumns[0], x.Values[0])));
        }
        else
        {
            foreach (var key in keys)
            {
                var where = q.AddWhereGroup(BooleanType.Or);
                for (var i = 0; i < primaryKeyColumnsCount; i++)
                    where.And(Table.PrimaryKeyColumns[i].DbName).EqualTo(dataSource.Provider.GetWriter().ConvertColumnValue(Table.PrimaryKeyColumns[i], key.Values[i]));
            }
        }

        if (orderings != null)
        {
            foreach (var order in orderings)
                q.OrderBy(order.Column, order.Alias, order.Ascending);
        }

        return q
            .SelectQuery()
            .ReadRows();
    }

    private bool GetRowFromCache(IKey key, DataSourceAccess dataSource, out IImmutableInstance? row)
    {
        if (dataSource is ReadOnlyAccess && RowCache.TryGetValue(key, out row))
            return true;
        else if (dataSource is Transaction transaction && TransactionRows.TryGetValue(transaction, out var transactionRows) && transactionRows.TryGetValue(key, out row))
            return true;

        row = null;
        return false;
    }

    private IImmutableInstance AddRow(RowData rowData, DataSourceAccess transaction)
    {
        TryAddRow(rowData, transaction, out var row);
        return row;
    }

    private bool TryAddRow(RowData rowData, DataSourceAccess dataSource, out IImmutableInstance row)
    {
        row = InstanceFactory.NewImmutableRow(rowData, dataSource.Provider, dataSource);
        var keys = KeyFactory.GetKey(rowData, Table.PrimaryKeyColumns);

        return (dataSource is ReadOnlyAccess && (!Table.UseCache || RowCache.TryAddRow(keys, rowData, row)))
            || (dataSource is Transaction transaction && TransactionRows.TryGetValue(transaction, out var rowCache) && rowCache.TryAddRow(keys, rowData, row));
    }

    public TableCacheSnapshot MakeSnapshot()
    {
        return new(Table.DbName, RowCount, TotalBytes, NewestTick, OldestTick, IndicesCount.ToArray());
    }
}

================
File: src/DataLinq/Cache/TableCacheSnapshot.cs
================
using System;
using System.Linq;
using DataLinq.Extensions.Helpers;
using DataLinq.Utils;

namespace DataLinq.Cache;

public class TableCacheSnapshot(string tableName, int rowCount, long totalBytes, long? newestTick, long? oldestTick, (string index, int count)[] indices)
{
    public string TableName { get; } = tableName;
    public long? NewestTick { get; } = newestTick > 0 ? newestTick : null;
    public long? OldestTick { get; } = oldestTick > 0 ? oldestTick : null;
    public (string index, int count)[] Indices { get; }  = indices;
    public string IndicesFormatted => Indices.Select(x => $"{x.index} ({x.count})").ToJoinedString(", ");
    public int RowCount { get; } = rowCount;
    public long TotalBytes { get; } = totalBytes;
    public string TotalBytesFormatted => TotalBytes.ToFileSize();
    public DateTime? NewestDateTime => NewestTick.HasValue ? new(NewestTick.Value) : null;
    public DateTime? OldestDateTime => OldestTick.HasValue ? new(OldestTick.Value) : null;
}

================
File: src/DataLinq/Config/ConfigFile.cs
================
using System.Collections.Generic;
using System.Text;

namespace DataLinq.Config;

public record ConfigFile
{
    public List<ConfigFileDatabase> Databases { get; set; } = new();
}

public record ConfigFileDatabase
{
    public string? Name { get; set; }
    public string? CsType { get; set; }
    public string? Namespace { get; set; }
    public List<string>? SourceDirectories { get; set; }
    public string? DestinationDirectory { get; set; }
    public List<string>? Tables { get; set; }
    public List<string>? Views { get; set; }
    public bool? UseRecord { get; set; }
    public bool? UseFileScopedNamespaces { get; set; }
    public bool? UseNullableReferenceTypes { get; set; }
    public bool? CapitalizeNames { get; set; }
    public bool? RemoveInterfacePrefix { get; set; }
    public bool? SeparateTablesAndViews { get; set; }
    public List<ConfigFileDatabaseConnection> Connections { get; set; } = new();
    public string FileEncoding { get; set; }
    public Encoding ParseFileEncoding() => ConfigReader.ParseFileEncoding(FileEncoding);
}

public record ConfigFileDatabaseConnection
{
    public DatabaseType? ParsedType
    {
        get
        {
            var type = ConfigReader.ParseDatabaseType(Type);

            return type.HasValue
                ? type
                : null;
        }
    }
    public string? Type { get; set; }
    public string? DatabaseName { get; set; }
    public string? DataSourceName { get; set; }
    public string? ConnectionString { get; set; }
    public DataLinqConnectionString? ParsedConnectionString => new DataLinqConnectionString(ConnectionString);
}

================
File: src/DataLinq/Config/ConfigReader.cs
================
using System;
using System.IO;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using DataLinq.Metadata;

namespace DataLinq.Config;

public static class ConfigReader
{
    public static DatabaseType? ParseDatabaseType(string? typeName)
    {
        if (typeName == null)
            return null;

        foreach (var (type, provider) in PluginHook.DatabaseProviders)
        {
            if (provider.IsDatabaseType(typeName))
                return type;
        }

        return null;

        // return $"No provider matched with database type '{typeName}'";
    }

    public static Encoding ParseFileEncoding(string encoding)
    {
        if (encoding == null || encoding.Equals("UTF8", StringComparison.OrdinalIgnoreCase) || encoding.Equals("UTF-8", StringComparison.OrdinalIgnoreCase))
            return new UTF8Encoding(false);

        if (encoding.Equals("UTF8BOM", StringComparison.OrdinalIgnoreCase) || encoding.Equals("UTF8-BOM", StringComparison.OrdinalIgnoreCase) || encoding.Equals("UTF-8-BOM", StringComparison.OrdinalIgnoreCase))
            return new UTF8Encoding(true);

        return Encoding.GetEncoding(encoding);
    }

    public static ConfigFile Read(string path)
    {
        var file = File.ReadAllText(path);
        var withoutComments = RemoveComments(file);
        var config = JsonSerializer.Deserialize<ConfigFile>(withoutComments);

        return config;
    }

    private static string RemoveComments(string json)
    {
        // Remove single-line comments (//...)
        json = Regex.Replace(json, @"//.*$", string.Empty, RegexOptions.Multiline);

        // Remove multi-line comments (/*...*/)
        json = Regex.Replace(json, @"/\*.*?\*/", string.Empty, RegexOptions.Singleline);

        return json;
    }

}

================
File: src/DataLinq/Config/ConfigWriter.cs
================
namespace DataLinq.Config;

internal class ConfigWriter
{
}

================
File: src/DataLinq/Config/DataLinqConfig.cs
================
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using DataLinq.Extensions.Helpers;
using ThrowAway;

namespace DataLinq.Config;

public record DataLinqConfig
{
    static public Option<DataLinqConfig> FindAndReadConfigs(string configPath, Action<string> log)
    {
        if (string.IsNullOrEmpty(configPath))
            throw new ArgumentNullException(nameof(configPath));

        if (!File.Exists(configPath))
        {
            if (Directory.Exists(configPath))
                configPath = Path.Combine(configPath, "datalinq.json");

            if (!File.Exists(configPath))
                return $"Couldn't find config file, usually called 'datalinq.json'. Tried searching path:\n{configPath}";
        }

        log($"Reading config from:      {configPath}");
        var configs = new List<ConfigFile> { ConfigReader.Read(configPath) };

        var userFilePath = configPath.Replace(".json", ".user.json");
        if (File.Exists(userFilePath))
        {
            log($"Reading user config from: {userFilePath}");
            configs.Add(ConfigReader.Read(userFilePath));
        }

        var basePath = Path.GetDirectoryName(configPath);

        return new DataLinqConfig(basePath, configs.ToArray());
    }

    public List<DataLinqDatabaseConfig> Databases { get; }
    public string BasePath { get; }

    public DataLinqConfig(string basePath, params ConfigFile[] configFiles)
    {
        if (configFiles.Length == 0)
            throw new ArgumentException("At least one config file must be specified");

        if (basePath == null || !Directory.Exists(basePath))
            throw new ArgumentNullException(nameof(basePath), "Must be a valid directory path");

        BasePath = basePath;
        Databases = configFiles
            .First()
            .Databases
            .Select(x => new DataLinqDatabaseConfig(this, x))
            .ToList();

        foreach (var configFile in configFiles.Skip(1))
        {
            foreach (var database in configFile.Databases)
            {
                var existingDatabase = Databases.SingleOrDefault(x => x.Name == database.Name);
                if (existingDatabase == null)
                {
                    Databases.Add(new DataLinqDatabaseConfig(this, database));
                }
                else
                {
                    existingDatabase.MergeConfig(database);
                }
            }
        }
    }

    public Option<(DataLinqDatabaseConfig db, DataLinqDatabaseConnection connection)> GetConnection(string? dbName, DatabaseType? databaseType)
    {
        if (string.IsNullOrEmpty(dbName) && Databases.Count != 1)
            return $"The config file has more than one database specified. Use (-a or --all) to use all configured databases, or name (-n or --name) one:\n{Databases.Select(x => x.Name).ToJoinedString()}";

        var db = string.IsNullOrEmpty(dbName)
            ? Databases.Single()
            : Databases.SingleOrDefault(x => x.Name.ToLower() == dbName.ToLower());

        if (db == null)
        {
            return $"Couldn't find database with name '{dbName}'";
        }

        if (db.Connections.Count == 0)
        {
            return $"Database '{db.Name}' has no connections to read from";
        }

        if (db.Connections.Count > 1 && databaseType == null)
        {
            return $"Database '{db.Name}' has more than one type of connection to read from, you need to select which one (-t or --type):\n{db.Connections.Select(x => x.Type).ToJoinedString()}";
        }

        DataLinqDatabaseConnection? connection = null;
        if (databaseType != null)
        {
            connection = db.Connections.SingleOrDefault(x => x.Type == databaseType);

            if (connection == null)
            {
                return $"Couldn't find connection with type '{databaseType}' in configuration file.";
            }
        }

        if (connection == null)
            connection = db.Connections[0];

        return (db, connection);
    }
}

public record DataLinqDatabaseConfig
{
    public DataLinqConfig Config { get; }

    public string Name { get; private set; }
    public string CsType { get; private set; }
    public string Namespace { get; private set; }
    public List<string> SourceDirectories { get; private set; }
    public string? DestinationDirectory { get; private set; }
    public List<string> Tables { get; private set; }
    public List<string> Views { get; private set; }
    //public bool UseCache { get; }
    public bool UseRecord { get; private set; }
    public bool UseFileScopedNamespaces { get; private set; }
    public bool UseNullableReferenceTypes { get; private set; }
    public bool CapitalizeNames { get; private set; }
    public bool RemoveInterfacePrefix { get; private set; }
    public bool SeparateTablesAndViews { get; private set; }
    public List<DataLinqDatabaseConnection> Connections { get; private set; } = new();
    public Encoding FileEncoding { get; private set; }

    public DataLinqDatabaseConfig(DataLinqConfig config, ConfigFileDatabase database)
    {
        Config = config;
        Name = database.Name ?? throw new ArgumentNullException(nameof(database.Name));
        CsType = database.CsType ?? database.Name;
        Namespace = database.Namespace ?? "Models";
        SourceDirectories = database.SourceDirectories ?? new List<string>();
        DestinationDirectory = database.DestinationDirectory;
        Tables = database.Tables ?? new List<string>();
        Views = database.Views ?? new List<string>();
        UseRecord = database.UseRecord ?? false;
        UseFileScopedNamespaces = database.UseFileScopedNamespaces ?? false;
        UseNullableReferenceTypes = database.UseNullableReferenceTypes ?? false;
        CapitalizeNames = database.CapitalizeNames ?? false;
        RemoveInterfacePrefix = database.RemoveInterfacePrefix ?? true;
        SeparateTablesAndViews = database.SeparateTablesAndViews ?? false;
        Connections = database.Connections.Select(x => new DataLinqDatabaseConnection(this, x)).ToList();
        FileEncoding = ConfigReader.ParseFileEncoding(database.FileEncoding);
    }

    public void MergeConfig(ConfigFileDatabase database)
    {
        if (database.Name != null)
            Name = database.Name;

        if (database.CsType != null)
            CsType = database.CsType;

        if (database.Namespace != null)
            Namespace = database.Namespace;

        if (database.SourceDirectories != null)
            SourceDirectories = database.SourceDirectories;

        if (database.DestinationDirectory != null)
            DestinationDirectory = database.DestinationDirectory;

        if (database.Tables != null)
            Tables = database.Tables;

        if (database.Views != null)
            Views = database.Views;

        if (database.UseRecord != null)
            UseRecord = database.UseRecord.Value;

        if (database.UseFileScopedNamespaces != null)
            UseFileScopedNamespaces = database.UseFileScopedNamespaces.Value;

        if (database.UseNullableReferenceTypes != null)
            UseNullableReferenceTypes = database.UseNullableReferenceTypes.Value;

        if (database.CapitalizeNames != null)
            CapitalizeNames = database.CapitalizeNames.Value;

        if (database.RemoveInterfacePrefix != null)
            RemoveInterfacePrefix = database.RemoveInterfacePrefix.Value;

        if (database.SeparateTablesAndViews != null)
            SeparateTablesAndViews = database.SeparateTablesAndViews.Value;

        if (database.Connections != null)
            Connections = database.Connections.Select(x => new DataLinqDatabaseConnection(this, x)).ToList();

        if (database.FileEncoding != null)
            FileEncoding = ConfigReader.ParseFileEncoding(database.FileEncoding);
    }
}

public record DataLinqDatabaseConnection
{
    public DataLinqDatabaseConfig DatabaseConfig { get; }

    public DatabaseType Type { get; }
    public string DataSourceName { get; }
    public DataLinqConnectionString ConnectionString { get; }

    public string GetRootedPath(string basePath)
    {
        if (Path.IsPathRooted(DataSourceName))
            return DataSourceName;
        else if (Path.IsPathRooted(ConnectionString.Path))
            return ConnectionString.Path;

        return Path.Combine(basePath, DataSourceName);
    }

    public DataLinqDatabaseConnection(DataLinqDatabaseConfig databaseConfig, ConfigFileDatabaseConnection connection)
    {
        DatabaseConfig = databaseConfig;
        DataSourceName = connection.DataSourceName ?? connection.DatabaseName ?? throw new ArgumentNullException(nameof(connection.DataSourceName));
        Type = ConfigReader.ParseDatabaseType(connection.Type) ?? throw new ArgumentException($"Couldn't find database type for '{connection.Type}'");
        ConnectionString = new DataLinqConnectionString(connection.ConnectionString);
    }
}

================
File: src/DataLinq/Config/DataLinqConnectionString.cs
================
using System;
using System.Collections.Generic;
using System.Data.Common;
using System.Linq;

namespace DataLinq.Config;

/// <summary>
/// Represents a connection string and provides methods to access its components.
/// </summary>
public record DataLinqConnectionString
{
    /// <summary>
    /// Gets the dictionary containing the key-value pairs of the connection string.
    /// </summary>
    public Dictionary<string, string> Entries { get; }

    /// <summary>
    /// Gets the original connection string.
    /// </summary>
    public string Original { get; }

    /// <summary>
    /// Gets a collection of key-value pairs from the connection string.
    /// </summary>
    public IEnumerable<(string key, string value)> Values => Entries.Select(x => (x.Key, x.Value));

    /// <summary>
    /// Determines whether the connection string contains the specified key.
    /// </summary>
    /// <param name="key">The key to locate in the connection string.</param>
    /// <returns>true if the connection string contains an element with the specified key; otherwise, false.</returns>
    public bool ContainsKey(string key) => Entries.ContainsKey(key.ToLower());

    /// <summary>
    /// Gets the value associated with the specified key.
    /// </summary>
    /// <param name="key">The key of the value to get.</param>
    /// <returns>The value associated with the specified key.</returns>
    public string? GetValue(string key)
    {
        if (key == null)
            throw new ArgumentNullException(nameof(key));

        Entries.TryGetValue(key.ToLower(), out var value);
        return value;
    }

    /// <summary>
    /// Determines whether the connection string contains a password entry.
    /// </summary>
    public bool HasPassword =>
        ContainsKey("password") ||
        ContainsKey("pwd");

    /// <summary>
    /// Gets the path (either 'host' or 'data source') from the connection string.
    /// </summary>
    public string? Path
    {
        get
        {
            if (ContainsKey("host"))
                return GetValue("host");

            if (ContainsKey("data source"))
                return GetValue("data source");

            return null;
        }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="DataLinqConnectionString"/> class with the specified connection string.
    /// </summary>
    /// <param name="original">The original connection string.</param>
    public DataLinqConnectionString(string? original)
    {
        Original = original ?? throw new ArgumentNullException(nameof(original));

        var builder = new DbConnectionStringBuilder();
        builder.ConnectionString = Original;

        Entries = builder.Keys
            .Cast<string>()
            .Select(x => (x.ToLowerInvariant(), builder[x].ToString()))
            .Where(x => x.Item2 != null)
            .ToDictionary(x => x.Item1, x => x.Item2 ?? "");
    }

    public DataLinqConnectionString ChangeValue(string key, string value)
    {
        var builder = new DbConnectionStringBuilder
        {
            { key, value }
        };

        foreach (var entry in Entries)
            if (entry.Key != key)
                builder.Add(entry.Key, entry.Value);

        return new DataLinqConnectionString(builder.ToString());
    }
}

================
File: src/DataLinq/Database.cs
================
using System;
using System.Data;
using System.Linq;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Metadata;
using DataLinq.Mutation;
using DataLinq.Query;

namespace DataLinq;


/// <summary>
/// The main interface for working with the database.
/// </summary>
/// <typeparam name="T">The type of the database model.</typeparam>
public abstract class Database<T> : IDisposable
    where T : class, IDatabaseModel
{
    /// <summary>
    /// Gets the type of the database.
    /// </summary>
    public DatabaseType DatabaseType => Provider.DatabaseType;

    /// <summary>
    /// Gets the database provider.
    /// </summary>
    public DatabaseProvider<T> Provider { get; }
    

    /// <summary>
    /// Initializes a new instance of the <see cref="Database{T}"/> class.
    /// </summary>
    /// <param name="provider">The database provider.</param>
    public Database(DatabaseProvider<T> provider)
    {
        this.Provider = provider;
    }

    /// <summary>
    /// Checks if the file or server exists.
    /// </summary>
    /// <returns><c>true</c> if the file or server exists; otherwise, <c>false</c>.</returns>
    public bool FileOrServerExists()
    {
        return Provider.FileOrServerExists();
    }

    /// <summary>
    /// Checks if the database exists.
    /// </summary>
    /// <param name="databaseName">The name of the database.</param>
    /// <returns><c>true</c> if the database exists; otherwise, <c>false</c>.</returns>
    public bool Exists(string? databaseName = null)
    {
        return Provider.DatabaseExists(databaseName);
    }

    /// <summary>
    /// Starts a new transaction.
    /// </summary>
    /// <param name="transactionType">The type of the transaction.</param>
    /// <returns>The new transaction.</returns>
    public Transaction<T> Transaction(TransactionType transactionType = TransactionType.ReadAndWrite)
    {
        return new Transaction<T>(this.Provider, transactionType);
    }

    /// <summary>
    /// Attaches a transaction to the database.
    /// </summary>
    /// <param name="dbTransaction">The database transaction.</param>
    /// <param name="transactionType">The type of the transaction.</param>
    /// <returns>The attached transaction.</returns>
    public Transaction<T> AttachTransaction(IDbTransaction dbTransaction, TransactionType transactionType = TransactionType.ReadAndWrite)
    {
        return new Transaction<T>(this.Provider, dbTransaction, transactionType);
    }

    /// <summary>
    /// Queries the database.
    /// </summary>
    /// <returns>The query result.</returns>
    public T Query()
    {
        return Provider.TypedReadOnlyAccess.Query();
    }

    /// <summary>
    /// Creates a new SQL query from the specified table name and alias.
    /// </summary>
    /// <param name="tableName">The name of the table.</param>
    /// <param name="alias">The alias of the table.</param>
    /// <returns>The new SQL query.</returns>
    public SqlQuery From(string tableName, string? alias = null)
    {
        if (alias == null)
            (tableName, alias) = QueryUtils.ParseTableNameAndAlias(tableName);

        var table = Provider.TypedReadOnlyAccess.Provider.Metadata.TableModels.Single(x => x.Table.DbName == tableName).Table;

        return new SqlQuery(table, Provider.TypedReadOnlyAccess, alias);
    }

    /// <summary>
    /// Creates a new SQL query from the specified table and alias.
    /// </summary>
    /// <param name="table">The table.</param>
    /// <param name="alias">The alias of the table.</param>
    /// <returns>The new SQL query.</returns>
    public SqlQuery From(TableDefinition table, string? alias = null)
    {
        return new SqlQuery(table, Provider.TypedReadOnlyAccess, alias);
    }

    /// <summary>
    /// Creates a new SQL query from the specified model type.
    /// </summary>
    /// <typeparam name="V">The type of the model.</typeparam>
    /// <returns>The new SQL query.</returns>
    public SqlQuery<V> From<V>() where V : IModel
    {
        return Provider.TypedReadOnlyAccess.From<V>();
    }

    /// <summary>
    /// Retrieves a model from the database using the specified key.
    /// </summary>
    /// <typeparam name="M">The type of the model.</typeparam>
    /// <param name="key">The key to identify the model.</param>
    /// <returns>The model if found; otherwise, <c>null</c>.</returns>
    public M? Get<M>(IKey key) where M : IImmutableInstance
    {
        return IImmutable<M>.Get(key, Provider.TypedReadOnlyAccess);
    }

    
    public M Insert<M>(Mutable<M> model, TransactionType transactionType = TransactionType.ReadAndWrite) where M : IImmutableInstance
    {
        return Commit(transaction => transaction.Insert(model), transactionType);
    }

    /// <summary>
    /// Updates an existing model in the database.
    /// </summary>
    /// <typeparam name="M">The type of the model.</typeparam>
    /// <param name="model">The model to update.</param>
    /// <param name="transactionType">The type of the transaction.</param>
    /// <returns>The updated model.</returns>
    public M Update<M>(Mutable<M> model, TransactionType transactionType = TransactionType.ReadAndWrite) where M : IImmutableInstance
    {
        return Commit(transaction => transaction.Update(model), transactionType);
    }

    /// <summary>
    /// Inserts or updates a model in the database.
    /// </summary>
    /// <typeparam name="M">The type of the model.</typeparam>
    /// <param name="model">The model to insert or update.</param>
    /// <param name="transactionType">The type of the transaction.</param>
    /// <returns>The inserted or updated model.</returns>
    public M Save<M>(Mutable<M> model, TransactionType transactionType = TransactionType.ReadAndWrite) where M : IImmutableInstance
    {
        return Commit(transaction => transaction.Save(model), transactionType);
    }

    /// <summary>
    /// Deletes a model from the database.
    /// </summary>
    /// <typeparam name="M">The type of the model.</typeparam>
    /// <param name="model">The model to delete.</param>
    /// <param name="transactionType">The type of the transaction.</param>
    public void Delete<M>(M model, TransactionType transactionType = TransactionType.ReadAndWrite) where M : IModelInstance
    {
        Commit(transaction => transaction.Delete(model), transactionType);
    }

    /// <summary>
    /// Commits a transaction with the specified action.
    /// </summary>
    /// <param name="func">The action to perform in the transaction.</param>
    /// <param name="transactionType">The type of the transaction.</param>
    public void Commit(Action<Transaction> func, TransactionType transactionType = TransactionType.ReadAndWrite)
    {
        using var transaction = Transaction(transactionType);
        func(transaction);
        transaction.Commit();
    }

    /// <summary>
    /// Commits a transaction with the specified function.
    /// </summary>
    /// <typeparam name="M">The type of the model.</typeparam>
    /// <param name="func">The function to perform in the transaction.</param>
    /// <param name="transactionType">The type of the transaction.</param>
    /// <returns>The result of the function.</returns>
    public M Commit<M>(Func<Transaction, M> func, TransactionType transactionType = TransactionType.ReadAndWrite) where M : IImmutableInstance
    {
        using var transaction = Transaction(transactionType);
        var result = func(transaction);
        transaction.Commit();

        return result;
    }

    /// <summary>
    /// Disposes the database provider.
    /// </summary>
    public void Dispose()
    {
        Provider.Dispose();
    }
}

================
File: src/DataLinq/Database/DatabaseAccess.cs
================
using System.Collections.Generic;
using System.Data;

namespace DataLinq;

public abstract class DatabaseAccess 
{
    public abstract IDataLinqDataReader ExecuteReader(IDbCommand command);
    public abstract IDataLinqDataReader ExecuteReader(string query);
    public abstract object? ExecuteScalar(IDbCommand command);
    public abstract T ExecuteScalar<T>(IDbCommand command);
    public abstract object? ExecuteScalar(string query);
    public abstract T ExecuteScalar<T>(string query);
    public abstract int ExecuteNonQuery(IDbCommand command);
    public abstract int ExecuteNonQuery(string query);

    public IEnumerable<IDataLinqDataReader> ReadReader(IDbCommand command)
    {
        using var reader = ExecuteReader(command);

        while (reader.ReadNextRow())
            yield return reader;
    }

    public IEnumerable<IDataLinqDataReader> ReadReader(string query)
    {
        using var reader = ExecuteReader(query);

        while (reader.ReadNextRow())
            yield return reader;
    }
}

================
File: src/DataLinq/Database/DatabaseProvider.cs
================
using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using DataLinq.Attributes;
using DataLinq.Cache;
using DataLinq.Interfaces;
using DataLinq.Logging;
using DataLinq.Metadata;
using DataLinq.Mutation;
using DataLinq.Query;

namespace DataLinq;

/// <summary>
/// Provides a generic abstract database provider for a specific type of database model.
/// </summary>
/// <typeparam name="T">The type of the database model.</typeparam>
public abstract class DatabaseProvider<T> : DatabaseProvider
    where T : class, IDatabaseModel
{
    //public static DatabaseProvider<T> GetPrimaryProvider()
    //{
    //    return (DatabaseProvider<T>)GetPrimaryProvider(typeof(T));
    //}

    public ReadOnlyAccess<T> TypedReadOnlyAccess { get; set; }

    /// <summary>
    /// Initializes a new instance of the DatabaseProvider with the specified connection string and database type.
    /// </summary>
    /// <param name="connectionString">The connection string to the database.</param>
    /// <param name="databaseType">The type of the database.</param>
    protected DatabaseProvider(string connectionString, DatabaseType databaseType, DataLinqLoggingConfiguration loggingConfiguration) : base(connectionString, typeof(T), databaseType, loggingConfiguration)
    {
        TypedReadOnlyAccess = new ReadOnlyAccess<T>(this);
    }

    /// <summary>
    /// Initializes a new instance of the DatabaseProvider with the specified connection string, database type, and database name.
    /// </summary>
    /// <param name="connectionString">The connection string to the database.</param>
    /// <param name="databaseType">The type of the database.</param>
    /// <param name="databaseName">The name of the database.</param>
    protected DatabaseProvider(string connectionString, DatabaseType databaseType, DataLinqLoggingConfiguration loggingConfiguration, string databaseName) : base(connectionString, typeof(T), databaseType, loggingConfiguration, databaseName)
    {
        TypedReadOnlyAccess = new ReadOnlyAccess<T>(this);
    }
}

/// <summary>
/// Abstract base class for database providers, encapsulating common database operations and properties.
/// </summary>
public abstract class DatabaseProvider : IDatabaseProvider, IDisposable
{
    public string DatabaseName { get; protected set; }
    public Type CsModelType { get; protected set; }
    public DatabaseType DatabaseType { get; }
    public DataLinqLoggingConfiguration LoggingConfiguration { get; }
    public abstract IDatabaseProviderConstants Constants { get; }

    public string ConnectionString { get; }
    public abstract DatabaseAccess DatabaseAccess { get; }
    public virtual ReadOnlyAccess ReadOnlyAccess { get; }
    public DatabaseDefinition Metadata { get; }
    public State State { get; }

    private static readonly object lockObject = new();

    /// <summary>
    /// Retrieves the table cache for a given table metadata.
    /// </summary>
    /// <param name="table">The metadata of the table to retrieve the cache for.</param>
    /// <returns>The table cache for the specified table.</returns>
    public TableCache GetTableCache(TableDefinition table) => State.Cache.TableCaches[table];

    /// <summary>
    /// Initializes a new instance of the DatabaseProvider class with the specified connection string, type of the model, database type, and optional database name.
    /// </summary>
    /// <param name="connectionString">The connection string to the database.</param>
    /// <param name="type">The type of the model that the database contains.</param>
    /// <param name="databaseType">The type of the database.</param>
    /// <param name="databaseName">The name of the database (optional).</param>
    protected DatabaseProvider(string connectionString, Type type, DatabaseType databaseType, DataLinqLoggingConfiguration loggingConfiguration, string? databaseName = null)
    {
        lock (lockObject)
        {
            if (DatabaseDefinition.LoadedDatabases.TryGetValue(type, out var metadata))
            {
                Metadata = metadata;
            }
            else
            {
                Metadata = MetadataFromTypeFactory.ParseDatabaseFromDatabaseModel(type);
                DatabaseDefinition.LoadedDatabases.TryAdd(type, Metadata);

                if (Metadata.UseCache)
                {
                    if (!Metadata.CacheLimits.Any())
                    {
                        Metadata.CacheLimits.Add((CacheLimitType.Megabytes, 256));
                        Metadata.CacheLimits.Add((CacheLimitType.Minutes, 30));
                    }

                    if (!Metadata.CacheCleanup.Any())
                    {
                        Metadata.CacheCleanup.Add((CacheCleanupType.Minutes, 10));
                    }

                    if (!Metadata.IndexCache.Any())
                    {
                        Metadata.IndexCache.Add((IndexCacheType.MaxAmountRows, 1000000));
                    }
                }
            }
        }

        CsModelType = type;
        DatabaseType = databaseType;
        LoggingConfiguration = loggingConfiguration;
        DatabaseName = databaseName ?? Metadata.DbName;
        ConnectionString = connectionString;
        State = new State(this, loggingConfiguration);

        this.ReadOnlyAccess = new ReadOnlyAccess(this);
    }

    

    /// <summary>
    /// Starts a new database transaction with the specified transaction type.
    /// </summary>
    /// <param name="transactionType">The type of the transaction.</param>
    /// <returns>A new Transaction object.</returns>
    public Transaction StartTransaction(TransactionType transactionType = TransactionType.ReadAndWrite)
    {
        return new Transaction(this, transactionType);
    }

    public M Commit<M>(Func<Transaction, M> func)
    {
        using var transaction = StartTransaction();
        var result = func(transaction);
        transaction.Commit();

        return result;
    }

    public void Commit(Action<Transaction> action)
    {
        using var transaction = StartTransaction();
        action(transaction);
        transaction.Commit();
    }

    /// <summary>
    /// Attaches an existing database transaction to this provider with the specified transaction type.
    /// </summary>
    /// <param name="dbTransaction">The existing database transaction.</param>
    /// <param name="transactionType">The type of the transaction.</param>
    /// <returns>A new Transaction object that wraps the provided IDbTransaction.</returns>
    public Transaction AttachTransaction(IDbTransaction dbTransaction, TransactionType transactionType = TransactionType.ReadAndWrite)
    {
        return new Transaction(this, dbTransaction, transactionType);
    }

    // Abstract methods definitions:
    public abstract IDbCommand ToDbCommand(IQuery query);
    public abstract string GetLastIdQuery();
    public abstract Sql GetParameter(Sql sql, string key, object? value);
    public abstract Sql GetParameterValue(Sql sql, string key);
    public abstract Sql GetParameterComparison(Sql sql, string field, Query.Relation relation, string[] key);
    public abstract Sql GetLimitOffset(Sql sql, int? limit, int? offset);
    public abstract Sql GetTableName(Sql sql, string tableName, string? alias = null);
    public abstract Sql GetCreateSql();
    public abstract DatabaseTransaction GetNewDatabaseTransaction(TransactionType type);
    public abstract DatabaseTransaction AttachDatabaseTransaction(IDbTransaction dbTransaction, TransactionType type);
    public abstract bool DatabaseExists(string? databaseName = null);
    public abstract bool FileOrServerExists();
    //public abstract void CreateDatabase(string? databaseName = null);
    public abstract IDataLinqDataWriter GetWriter();

    /// <summary>
    /// Releases all resources used by the DatabaseProvider.
    /// </summary>
    public void Dispose()
    {
        State.Dispose();
    }
}

================
File: src/DataLinq/Database/DatabaseTransaction.cs
================
using System;
using System.Data;
using DataLinq.Mutation;

namespace DataLinq;

public enum DatabaseTransactionStatus
{
    Closed,
    Open,
    Committed,
    RolledBack
}

public class DatabaseTransactionStatusChangeEventArgs : EventArgs
{
    public DatabaseTransactionStatus Status { get; set; }
}

public abstract class DatabaseTransaction : DatabaseAccess, IDisposable
{
    public DatabaseTransactionStatus Status { get; private set; } = DatabaseTransactionStatus.Closed;

    public event EventHandler<DatabaseTransactionStatusChangeEventArgs>? OnStatusChanged;
    public IDbTransaction? DbTransaction { get; protected set; }
    public TransactionType Type { get; protected set; }

    protected DatabaseTransaction(TransactionType type)
    {
        Type = type;
    }

    protected DatabaseTransaction(IDbTransaction dbTransaction, TransactionType type)
    {
        DbTransaction = dbTransaction ?? throw new ArgumentNullException(nameof(dbTransaction));
        Type = type;
    }

    protected void SetStatus(DatabaseTransactionStatus status)
    {
        this.Status = status;
        OnStatusChanged?.Invoke(this, new DatabaseTransactionStatusChangeEventArgs { Status = status });
    }

    public abstract void Rollback();
    public abstract void Commit();
    public abstract void Dispose();
}

================
File: src/DataLinq/Database/DataReader.cs
================
using System;
using System.Text;
using DataLinq.Metadata;

namespace DataLinq;

public interface IDataLinqDataReader : IDisposable
{
    object GetValue(int ordinal);
    int GetOrdinal(string name);
    string GetString(int ordinal);
    bool GetBoolean(int ordinal);
    int GetInt32(int ordinal);
    DateOnly GetDateOnly(int ordinal);
    Guid GetGuid(int ordinal);
    byte[]? GetBytes(int ordinal);
    long GetBytes(int ordinal, Span<byte> buffer);
    T? GetValue<T>(ColumnDefinition column);
    T? GetValue<T>(ColumnDefinition column, int ordinal);
    bool ReadNextRow();
    bool IsDbNull(int ordinal);
}

public static class DataReader
{
    //public static T? ReadColumn<T>(this IDataLinqDataReader reader, Column column)
    //{
    //    return reader.GetValue<T>(column);
    //}

    //public static T? ReadColumn<T>(this IDataLinqDataReader reader, Column column, int ordinal)
    //{
    //    return reader.GetValue<T>(column, ordinal);
    //}

    //TODO: Move to IDataLinqDataReader, the byte encoding might differ between databases
    public static object ConvertBytesToType(ReadOnlySpan<byte> bytes, ValueProperty property)
    {
        // Convert the byte array to the specified type
        if (property.CsType.Type == typeof(int))
        {
            return BitConverter.ToInt32(bytes);
        }
        else if (property.CsType.Type == typeof(short))
        {
            return BitConverter.ToInt16(bytes);
        }
        else if (property.CsType.Type == typeof(long))
        {
            return BitConverter.ToInt64(bytes);
        }
        else if (property.CsType.Type == typeof(float))
        {
            return BitConverter.ToSingle(bytes);
        }
        else if (property.CsType.Type == typeof(double))
        {
            return BitConverter.ToDouble(bytes);
        }
        else if (property.CsType.Type == typeof(bool))
        {
            return BitConverter.ToBoolean(bytes);
        }
        else if (property.CsType.Type == typeof(Guid))
        {
            return new Guid(bytes);
        }
        else if (property.CsType.Type == typeof(string))
        {
            return Encoding.UTF8.GetString(bytes);
        }
        else if (property.CsType.Type == typeof(DateTime))
        {
            return new DateTime(BitConverter.ToInt64(bytes));
        }
        else if (property.CsType.Type == typeof(DateOnly))
        {
            return DateOnly.FromDateTime(new DateTime(BitConverter.ToInt64(bytes)));
        }
        else
        {
            throw new NotSupportedException($"Type {property.CsType} is not supported.");
        }
    }

    //TODO: Move to IDataLinqDataReader, the byte encoding might differ between databases
    public static ReadOnlySpan<byte> ConvertTypeToBytes(object? value, ValueProperty property)
    {
        if (value == null)
            return new ReadOnlySpan<byte> { };
        if (property == null)
            throw new ArgumentNullException(nameof(property));

        // Convert the object to byte array based on the type
        if (property.CsType.Type == typeof(int))
        {
            if (value is int intValue)
                return BitConverter.GetBytes(intValue);
            else if (value is long longValue)
                return BitConverter.GetBytes((int)longValue);
            else if (value is short shortValue)
                return BitConverter.GetBytes((int)shortValue);
            else
                throw new ArgumentException($"Value {value} is not an integer.", nameof(value));
        }
        else if (property.CsType.Type == typeof(short))
        {
            return BitConverter.GetBytes((short)value);
        }
        else if (property.CsType.Type == typeof(long))
        {
            return BitConverter.GetBytes((long)value);
        }
        else if (property.CsType.Type == typeof(float))
        {
            return BitConverter.GetBytes((float)value);
        }
        else if (property.CsType.Type == typeof(double))
        {
            return BitConverter.GetBytes((double)value);
        }
        else if (property.CsType.Type == typeof(bool))
        {
            return BitConverter.GetBytes((bool)value);
        }
        else if (property.CsType.Type == typeof(Guid))
        {
            return ((Guid)value).ToByteArray();
        }
        else if (property.CsType.Type == typeof(string))
        {
            return Encoding.UTF8.GetBytes((string)value);
        }
        else if (property.CsType.Type == typeof(DateTime))
        {
            return BitConverter.GetBytes(((DateTime)value).Ticks);
        }
        else if (property.CsType.Type == typeof(DateOnly))
        {
            return BitConverter.GetBytes(((DateOnly)value).ToDateTime(TimeOnly.MinValue).Ticks);
        }
        else
        {
            throw new NotSupportedException($"Type {property.CsType} is not supported.");
        }
    }

}

================
File: src/DataLinq/Database/DataWriter.cs
================
using System;
using DataLinq.Metadata;

namespace DataLinq;

/// <summary>
/// Interface for writing data to a database.
/// </summary>
public interface IDataLinqDataWriter
{
    /// <summary>
    /// Converts the value of a column to the appropriate database type.
    /// </summary>
    /// <param name="column">The column to convert.</param>
    /// <param name="value">The value to convert.</param>
    /// <returns>The converted value.</returns>
    object? ConvertValue(ColumnDefinition column, object? value);
}

/// <summary>
/// Provides extension methods for converting data to be written to the database.
/// </summary>
public static class DataWriter
{
    /// <summary>
    /// Converts the value of a column to the appropriate database type.
    /// </summary>
    /// <param name="writer">The IDataLinqDataWriter instance.</param>
    /// <param name="column">The column to convert.</param>
    /// <param name="value">The value to convert.</param>
    /// <returns>The converted value.</returns>
    /// <exception cref="System.ArgumentNullException">Thrown when the column is null.</exception>
    public static object? ConvertColumnValue(this IDataLinqDataWriter writer, ColumnDefinition column, object? value)
    {
        ArgumentNullException.ThrowIfNull(writer);
        ArgumentNullException.ThrowIfNull(column);

        return writer.ConvertValue(column, value);
    }
}

================
File: src/DataLinq/DbRead.cs
================
using System.Linq;
using System.Linq.Expressions;
using DataLinq.Mutation;

namespace DataLinq;

/// <summary>
/// Represents a class to connect the models to Linq.
/// </summary>
/// <typeparam name="T">The type of the model.</typeparam>
public class DbRead<T> : Queryable<T>
{
    /// <summary>
    /// Initializes a new instance of the <see cref="DbRead{T}"/> class.
    /// </summary>
    /// <param name="transaction">The transaction.</param>
    public DbRead(DataSourceAccess transaction) : base(transaction, transaction.Provider.Metadata.TableModels.Single(x => x.Model.CsType.Type == typeof(T)).Table) { }

    /// <summary>
    /// Initializes a new instance of the <see cref="DbRead{T}"/> class.
    /// </summary>
    /// <param name="provider">The query provider.</param>
    /// <param name="expression">The expression.</param>
    public DbRead(IQueryProvider provider, Expression expression) : base(provider, expression) { }
}

================
File: src/DataLinq/Exceptions/InvalidMutationObjectException.cs
================
using System;

namespace DataLinq.Exceptions;

public class InvalidMutationObjectException : System.Exception
{
    private readonly string message;

    public InvalidMutationObjectException(string message)
    {
        this.message = message + " ";
    }

    public InvalidMutationObjectException() : base()
    {
    }

    public InvalidMutationObjectException(string message, Exception innerException) : base(message, innerException)
    {
    }

    public override string Message
    {
        get
        {
            return "The client query is invalid: " + message;
        }
    }
}

================
File: src/DataLinq/Exceptions/InvalidQueryException.cs
================
using System;

namespace DataLinq.Exceptions;

public class InvalidQueryException : Exception
{
    private readonly string message;

    public InvalidQueryException(string message)
    {
        this.message = message + " ";
    }

    public InvalidQueryException(string message, Exception innerException) : base(message, innerException)
    {
        this.message = message;
    }

    public override string Message => "The client query is invalid: " + message;
}

================
File: src/DataLinq/Exceptions/ModelLoadFailureException.cs
================
using System;
using DataLinq.Instances;

namespace DataLinq.Exceptions
{
    class ModelLoadFailureException : Exception
    {
        public IKey Key { get; }
        private readonly string? message;

        public ModelLoadFailureException(IKey key, string message)
        {
            Key = key;
            this.message = message;
        }

        public ModelLoadFailureException(IKey key) : base()
        {
            Key = key;
        }

        public ModelLoadFailureException(IKey key, string message, Exception innerException) : base(message, innerException)
        {
            Key = key;
        }

        public override string Message => string.IsNullOrWhiteSpace(message)
            ? $"Couldn't load model with id '{Key}'"
            : $"Couldn't load model with id '{Key}': {message}";
    }
}

================
File: src/DataLinq/Extensions/Helpers/LinqExtensions.cs
================
using System;
using System.Collections.Generic;

namespace DataLinq.Extensions.Helpers;

internal static class LinqExtensions
{
    internal static string ToJoinedString<T>(this IEnumerable<T> source, string separator = "\n") =>
        string.Join(separator, source);

    //https://stackoverflow.com/a/11463800
    internal static IEnumerable<List<T>> SplitList<T>(this List<T> locations, int nSize = 30)
    {
        for (int i = 0; i < locations.Count; i += nSize)
        {
            yield return locations.GetRange(i, Math.Min(nSize, locations.Count - i));
        }
    }

    internal static IEnumerable<T> Yield<T>(this T item)
    {
#pragma warning disable RCS1165 // Unconstrained type parameter checked for null.
        if (item != null)
#pragma warning restore RCS1165 // Unconstrained type parameter checked for null.
            yield return item;
    }
}

================
File: src/DataLinq/Extensions/Helpers/QueryExtensions.cs
================
using DataLinq.Query;

namespace DataLinq.Extensions.Helpers;

internal static class QueryExtensions
{
    internal static string ToSql(this Relation relation)
    {
        switch (relation)
        {
            case Relation.Equal:
                return "=";

            case Relation.EqualNull:
                return "IS";

            case Relation.NotEqual:
                return "<>";

            case Relation.NotEqualNull:
                return "IS NOT";

            case Relation.Like:
                return "LIKE";

            case Relation.GreaterThan:
                return ">";

            case Relation.GreaterThanOrEqual:
                return ">=";

            case Relation.LessThan:
                return "<";

            case Relation.LessThanOrEqual:
                return "<=";

            case Relation.In:
                return "IN";

            case Relation.NotIn:
                return "NOT IN";
        }

        return null;
    }
}

================
File: src/DataLinq/Extensions/Helpers/StringExtensions.cs
================
using System;

namespace DataLinq.Extensions.Helpers;

internal static class StringExtensions
{
    //https://stackoverflow.com/a/4405876
    internal static string FirstCharToUpper(this string input) =>
        input switch
        {
            null => throw new ArgumentNullException(nameof(input)),
            "" => throw new ArgumentException($"{nameof(input)} cannot be empty", nameof(input)),
            _ => string.Concat(input[0].ToString().ToUpper(), input.Substring(1))
        };
}

================
File: src/DataLinq/Extensions/IModelExtensions.cs
================
using DataLinq.Instances;
using DataLinq.Mutation;

namespace DataLinq;

public static class IModelExtensions
{
    public static T Insert<T>(this Mutable<T> model, Transaction transaction) where T : IImmutableInstance =>
        transaction.Insert(model);

    public static T Update<T>(this Mutable<T> model, Transaction transaction) where T : IImmutableInstance =>
        transaction.Update(model);

    public static T Save<T>(this Mutable<T> model, Transaction transaction) where T : IImmutableInstance =>
        transaction.Save(model);

    public static void Delete<T>(this T model) where T : IImmutableInstance => 
        model.GetDataSource().Provider.Commit(transaction => model.Delete(transaction));

    public static void Delete<T>(this T model, Transaction transaction) where T : IModelInstance => 
        transaction.Delete(model);
}

================
File: src/DataLinq/Instances/IKey.cs
================
using System;
using System.Linq;

namespace DataLinq.Instances;

public interface IKey
{
    public object?[] Values { get; }
}

public readonly record struct NullKey() : IKey, IEquatable<NullKey>
{
    public object?[] Values => [null];

    public bool Equals(NullKey other) =>
        true;

    public override int GetHashCode() =>
        0571049712;
}

public readonly record struct ObjectKey(object Value) : IKey, IEquatable<ObjectKey>
{
    public object?[] Values => [Value];

    public bool Equals(ObjectKey other) =>
        Value == other.Value;

    public override int GetHashCode() =>
        Value.GetHashCode();
}

public readonly record struct IntKey(int Value) : IKey, IEquatable<IntKey>
{
    public object?[] Values => [Value];

    public bool Equals(IntKey other) =>
        Value == other.Value;

    public override int GetHashCode() =>
        Value.GetHashCode();
}

public readonly record struct UInt64Key(ulong Value) : IKey, IEquatable<UInt64Key>
{
    public object?[] Values => [Value];

    public bool Equals(UInt64Key other) =>
        Value == other.Value;

    public override int GetHashCode() =>
        Value.GetHashCode();
}

public readonly record struct Int64Key(long Value) : IKey, IEquatable<Int64Key>
{
    public object?[] Values => [Value];

    public bool Equals(Int64Key other) =>
        Value == other.Value;

    public override int GetHashCode() =>
        Value.GetHashCode();
}

public readonly record struct GuidKey(Guid Value) : IKey, IEquatable<GuidKey>
{
    public object?[] Values => [Value];

    public bool Equals(GuidKey other) =>
        Value == other.Value;

    public override int GetHashCode() =>
        Value.GetHashCode();
}

public readonly record struct StringKey(string Value) : IKey, IEquatable<StringKey>
{
    public object?[] Values => [Value];

    public bool Equals(StringKey other) =>
        Value == other.Value;

    public override int GetHashCode() =>
        Value.GetHashCode();
}

public readonly record struct CompositeKey : IKey, IEquatable<CompositeKey>
{
    public readonly int cachedHashCode;
    public object?[] Values => values;
    private readonly object?[] values;

    public CompositeKey(object?[] values)
    {
        this.values = values;
        this.cachedHashCode = ComputeHashCode(values);
    }

    public bool Equals(CompositeKey other) =>
        values.SequenceEqual(other.values);

    public override int GetHashCode() =>
        cachedHashCode;

    public static int ComputeHashCode(object?[] values)
    {
        var hash = new HashCode();

        foreach (var val in values.Where(x => x != null))
            hash.Add(val);
        
        return hash.ToHashCode();
    }
}


//public readonly record struct CompositeKey : IKey, IEquatable<CompositeKey>
//{
//    public IEnumerable<object?> Values
//    {
//        get
//        {
//            for (int i=0; i<Lengths.Length; i++)
//            {
//                yield return DataReader.ConvertBytesToType(Data.Slice(i > 0 ? Lengths.Span[i-1] : 0, Lengths.Span[i]));
//            }


//        }
//    }

//    public Memory<byte> Data { get; }
//    public Memory<int> Lengths { get; }

//    public readonly int cachedHashCode;
//    public CompositeKey(Memory<byte> data, Memory<int> lengths)
//    {
//        this.cachedHashCode = ComputeHashCode(data.Span, lengths.Span);
//        Data = data;
//        Lengths = lengths;
//    }

//    public bool Equals(CompositeKey other)
//    {
//        return Data.Span.SequenceEqual(other.Data.Span) && Lengths.Span.SequenceEqual(other.Lengths.Span);
//    }

//    public override int GetHashCode()
//    {
//        return cachedHashCode;
//    }

//    public static int ComputeHashCode(ReadOnlySpan<byte> buffer, ReadOnlySpan<int> lengths)
//    {
//        var hash = new HashCode();
//        hash.AddBytes(buffer);
//        hash.Add(lengths);

//        return hash.ToHashCode();
//    }
//}

//public abstract class Keys
//{

//}

///// <summary>
///// Represents the primary keys of a row.
///// </summary>
//public class PrimaryKeys : Keys, IEquatable<PrimaryKeys>
//{
//    /// <summary>
//    /// Initializes a new instance of the <see cref="PrimaryKeys"/> class.
//    /// </summary>
//    /// <param name="reader">The data reader.</param>
//    /// <param name="table">The table metadata.</param>
//    public PrimaryKeys(IDataLinqDataReader reader, TableMetadata table)
//    {
//        //(Data, cachedHashCode) = ReadAndParseReader(reader, table);

//        var (data, length) = ReadReader(reader, table);
//        Values = GetValues(data.Span, length.Span, table);

//        CheckData(Values);
//        cachedHashCode = ComputeHashCode(data.Span, length.Span);
//    }

//    public PrimaryKeys(ReadOnlySpan<byte> data, ReadOnlySpan<int> length, TableMetadata table)
//    {
//        Values = GetValues(data, length, table);

//        CheckData(Values);
//        cachedHashCode = ComputeHashCode(data, length);
//    }

//    /// <summary>
//    /// Initializes a new instance of the <see cref="PrimaryKeys"/> class.
//    /// </summary>
//    /// <param name="row">The row data.</param>
//    public PrimaryKeys(RowData row)
//    {
//        Values = ReadRow(row).ToArray();
//        CheckData(Values);

//        var (data, length) = ReadObjects(row.Table, Values);
//        cachedHashCode = ComputeHashCode(data.Span, length.Span);
//    }

//    /// <summary>
//    /// Initializes a new instance of the <see cref="PrimaryKeys"/> class.
//    /// </summary>
//    /// <param name="data">The primary key data.</param>
//    public PrimaryKeys(IEnumerable<object?> values, TableMetadata table)
//    {
//        Values = values.ToArray();
//        CheckData(Values);

//        var (data, length) = ReadObjects(table, Values);
//        cachedHashCode = ComputeHashCode(data.Span, length.Span);
//    }

//    ///// <summary>
//    ///// Initializes a new instance of the <see cref="PrimaryKeys"/> class.
//    ///// </summary>
//    ///// <param name="data">The primary key data.</param>
//    //public PrimaryKeys(object?[] data)
//    //{
//    //    CheckData(data);
//    //    cachedHashCode = ComputeHashCode(data);

//    //    Values = data;
//    //}



//    public object? this[int index]
//    {
//        get => Values[index];
//    }

//    private static void CheckData(ReadOnlySpan<object?> data, TableMetadata? table = null)
//    {
//        if (data == null)
//            throw new ArgumentNullException(nameof(data));

//        //for (int i = 0; i < data.Length; i++)
//        //{
//        //    if (data[i] is null)
//        //        throw new ArgumentNullException(nameof(data), "Data contains null values.");
//        //}

//        if (table != null && data.Length != table.PrimaryKeyColumns.Length)
//            throw new ArgumentException($"The number of primary key values ({data.Length}) does not match the number of primary key columns ({table.PrimaryKeyColumns.Length}).");

//        //return data;
//    }

//    public static object?[] GetValues(ReadOnlySpan<byte> buffer, ReadOnlySpan<int> length, TableMetadata table)
//    {
//        var result = new object?[table.PrimaryKeyColumns.Length];
//        for (int i = 0; i < table.PrimaryKeyColumns.Length; i++)
//            result[i] = DataReader.ConvertBytesToType(buffer.Slice(i > 0 ? length[i - 1] : 0, i > 0 ? length[i] - length[i - 1] : length[i]), table.PrimaryKeyColumns[i].ValueProperty); //reader.ReadColumn(table.PrimaryKeyColumns[i]);

//        return result;
//    }

//    /// <summary>
//    /// Gets the primary key data.
//    /// </summary>
//    //private object?[] values;
//    public object?[] Values { get; }


//    //public byte[] Data { get; }
//    //public int[] Length { get; }
//    private readonly int cachedHashCode;

//    /// <summary>
//    /// Determines whether the specified object is equal to the current object.
//    /// </summary>
//    /// <param name="other">The object to compare with the current object.</param>
//    /// <returns>true if the specified object is equal to the current object; otherwise, false.</returns>
//    public bool Equals(PrimaryKeys? other)
//    {
//        if (other is null)
//            return false;
//        if (ReferenceEquals(this, other))
//            return true;

//        return ArraysEqual(Values, other.Values);
//    }

//    /// <summary>
//    /// Determines whether the specified object is equal to the current object.
//    /// </summary>
//    /// <param name="obj">The object to compare with the current object.</param>
//    /// <returns>true if the specified object is equal to the current object; otherwise, false.</returns>
//    public override bool Equals(object? obj)
//    {
//        return Equals(obj as PrimaryKeys);
//    }

//    /// <summary>
//    /// Serves as the default hash function.
//    /// </summary>
//    /// <returns>A hash code for the current object.</returns>
//    public override int GetHashCode()
//    {
//        return cachedHashCode;
//        //unchecked
//        //{
//        //    if (Data == null)
//        //    {
//        //        return 0;
//        //    }
//        //    int hash = 17;
//        //    for (int i = 0; i < Data.Length; i++)
//        //    {
//        //        // Use a fixed hash code for null items, e.g., 0.
//        //        // If item is not null, use item's hash code.
//        //        hash = hash * 31 + (Data[i]?.GetHashCode() ?? 0);
//        //    }
//        //    return hash;
//        //}
//    }

//    public static int ComputeHashCode(ReadOnlySpan<byte> buffer, ReadOnlySpan<int> lengths)
//    {
//        unchecked
//        {
//            int hash = 17;
//            int offset = 0;

//            foreach (int length in lengths)
//            {
//                for (int i = offset; i < length; i++)
//                {
//                    hash = hash * 31 + buffer[i];
//                }

//                // Add delimiter to the hash
//                hash = hash * 31 + 0xFF;
//                offset = length;
//            }

//            return hash;
//        }
//    }

//    //public static int ComputeHashCode(Span<object?> data)
//    //{
//    //    unchecked
//    //    {
//    //        int hash = 17;
//    //        foreach (var obj in data)
//    //        {
//    //            hash = hash * 31 + (obj?.GetHashCode() ?? 0);
//    //        }
//    //        return hash;
//    //    }
//    //}

//    //public static int ComputeHashCodeEnumerable(IEnumerable<object?> data)
//    //{
//    //    unchecked
//    //    {
//    //        int hash = 17;
//    //        foreach (var obj in data)
//    //        {
//    //            hash = hash * 31 + (obj?.GetHashCode() ?? 0);
//    //        }
//    //        return hash;
//    //    }
//    //}

//    static bool ArraysEqual<T>(T[] a1, T[] a2)
//    {
//        // If either array is null or lengths are different, return false.
//        if (a1 == null || a2 == null || a1.Length != a2.Length)
//            return false;

//        for (int i = 0; i < a1.Length; i++)
//        {
//            // Use the static Object.Equals method to compare the elements
//            // which safely handles nulls.
//            if (!Object.Equals(a1[i], a2[i]))
//                return false;
//        }

//        // All checks passed, arrays are equal.
//        return true;
//    }

//    public static (Memory<byte> data, Memory<int> length) ReadObjects(TableMetadata table, IEnumerable<object?> objects)
//    {
//        var bytes = objects
//            .Select((x, i) => DataReader.ConvertTypeToBytes(x, table.PrimaryKeyColumns[i].ValueProperty).ToArray())
//            .ToArray();

//        var data = new Memory<byte>(new byte[bytes.Sum(x => x.Length)]);
//        var length = new Memory<int>(new int[bytes.Length]);

//        for (int i = 0; i < length.Length; i++)
//        {
//            bytes[i].CopyTo(data.Slice(i > 0 ? length.Span[i - 1] : 0));
//            length.Span[i] = bytes[i].Length;
//        }

//        return (data, length);
//    }

//    public static (Memory<byte> data, Memory<int> length) ReadReader(IDataLinqDataReader reader, TableMetadata table)
//    {
//        //Memory<object?> buffer = new object?[table.PrimaryKeyColumns.Length];
//        var buffer = new Memory<byte>(new byte[PrimaryKeys.KeyLength(table)]);
//        var length = new Memory<int>(new int[table.PrimaryKeyColumns.Length]);
//        ReadReader(reader, table, buffer.Span, length.Span);

//        return (buffer, length);
//    }

//    public static void ReadReader(IDataLinqDataReader reader, TableMetadata table, Span<byte> buffer, Span<int> length)
//    {
//        if (table.PrimaryKeyColumns.Length > length.Length)
//            throw new ArgumentException("Destination span is not large enough to hold all the primary key columns.", nameof(length));

//        //var buffer = new Memory<byte>(new byte[PrimaryKeyLength(table)]);
//        //var length = new Memory<int>(new int[table.PrimaryKeyColumns.Length]);
//        reader.ReadPrimaryKeys(table.PrimaryKeyColumns, buffer, length);

//        //for (int i = 0; i < table.PrimaryKeyColumns.Length; i++)
//        //    destination[i] = DataReader.ConvertBytesToType(buffer.Slice(i > 0 ? length.Span[i - 1] : 0, i > 0 ? length.Span[i] - length.Span[i - 1] : length.Span[i]).Span, table.PrimaryKeyColumns[i].ValueProperty); //reader.ReadColumn(table.PrimaryKeyColumns[i]);
//    }

//    public static int KeyLength(Column[] columns)
//    {
//        return columns.Sum(x => x.ValueProperty.CsSize ?? 255);
//    }

//    //public static Memory<byte[]?> GetBuffer(TableMetadata table)
//    //{
//    //    Memory<byte[]?> buffer = table.PrimaryKeyColumns
//    //        .Select(x => new byte[x.ValueProperty.CsSize ?? 255])
//    //        .ToArray();

//    //    return buffer;
//    //}

//    //public static IEnumerable<object?> ReadReader(IDataLinqDataReader reader, TableMetadata table)
//    //{
//    //    var result = new object?[table.PrimaryKeyColumns.Length];
//    //    for (int i = 0; i < table.PrimaryKeyColumns.Length; i++)
//    //    {
//    //        result[i] = reader.ReadColumn(table.PrimaryKeyColumns[i]);
//    //    }
//    //    return result;

//    //    //foreach (var column in table.PrimaryKeyColumns)
//    //    //    yield return reader.ReadColumn(column);
//    //}

//    public static IEnumerable<object?> ReadRow(RowData row)
//    {
//        foreach (var column in row.Table.PrimaryKeyColumns)
//            yield return row.GetValue(column);
//    }

//    //public static (ReadOnlyMemory<object?> data, int hashCode) ReadAndParseReader(IDataLinqDataReader reader, TableMetadata table)
//    //{
//    //    var data = ReadReader(reader, table).ToArray();
//    //    CheckData(data, table);
//    //    //CheckData(ReadRow(row).ToArray(), row.Table).ToArray();
//    //    return (data, ComputeHashCode(data));
//    //}
//}

================
File: src/DataLinq/Instances/Immutable.cs
================
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Interfaces;
using DataLinq.Metadata;
using DataLinq.Mutation;

namespace DataLinq.Instances;

public abstract class Immutable<T, M>(RowData rowData, DataSourceAccess dataSource) : IImmutable<T>, IImmutableInstance<M>, IEquatable<Immutable<T, M>>
    where T : IModel
    where M : class, IDatabaseModel
{
    protected Dictionary<RelationProperty, IKey> relationKeys = rowData.Table.Model.RelationProperties
        .ToDictionary(x => x.Value, x => KeyFactory.CreateKeyFromValues(rowData.GetValues(x.Value.RelationPart.ColumnIndex.Columns)));

    protected ConcurrentDictionary<string, object?>? lazyValues = null;

    public object? this[ColumnDefinition column] => rowData[column];
    public object? this[string propertyName] => rowData.GetValue(rowData.Table.Model.ValueProperties[propertyName].Column);

    public ModelDefinition Metadata() => rowData.Table.Model;
    public IKey PrimaryKeys() => KeyFactory.CreateKeyFromValues(rowData.GetValues(rowData.Table.PrimaryKeyColumns));
    public bool HasPrimaryKeysSet() => PrimaryKeys() is not NullKey;

    public RowData GetRowData() => rowData;
    IRowData IModelInstance.GetRowData() => GetRowData();

    public IEnumerable<KeyValuePair<ColumnDefinition, object?>> GetValues() => rowData.GetColumnAndValues();
    public IEnumerable<KeyValuePair<ColumnDefinition, object?>> GetValues(IEnumerable<ColumnDefinition> columns) => rowData.GetColumnAndValues(columns);


    public void ClearLazy() => lazyValues?.Clear();
    public V? GetLazy<V>(string name, Func<V> fetchCode)
    {
        lazyValues ??= new ConcurrentDictionary<string, object?>();

        if (!lazyValues.TryGetValue(name, out var value) || value == null)
        {
            value = fetchCode();
            lazyValues[name] = value;
        }

        return (V?)value;
    }

    protected ImmutableRelation<V> GetImmutableRelation<V>(string propertyName) where V : IImmutableInstance
    {
        var property = rowData.Table.Model.RelationProperties[propertyName];
        return new ImmutableRelation<V>(relationKeys[property], GetDataSource(), property);
    }

    protected object GetValue(string propertyName) => GetNullableValue(propertyName) ?? throw new ArgumentNullException(propertyName);
    protected object? GetNullableValue(string propertyName) => rowData.GetValue(rowData.Table.Model.ValueProperties[propertyName].Column);
    protected V? GetForeignKey<V>(string propertyName) where V : IImmutableInstance => GetRelation<V>(rowData.Table.Model.RelationProperties[propertyName]).SingleOrDefault();
    protected IEnumerable<V> GetRelation<V>(string propertyName) where V : IImmutableInstance => GetRelation<V>(rowData.Table.Model.RelationProperties[propertyName]);

    protected IEnumerable<V> GetRelation<V>(RelationProperty property) where V : IImmutableInstance
    {
        var source = GetDataSource();

        var otherSide = property.RelationPart.GetOtherSide();
        var result = source.Provider
            .GetTableCache(otherSide.ColumnIndex.Table)
            .GetRows(relationKeys[property], property, source)
            .Cast<V>();

        return result;
    }

    public DataSourceAccess GetDataSource()
    {
        if (dataSource is Transaction transaction && (transaction.Status == DatabaseTransactionStatus.Committed || transaction.Status == DatabaseTransactionStatus.RolledBack))
            dataSource = dataSource.Provider.ReadOnlyAccess;

        return dataSource;
    }

    public bool Equals(Immutable<T, M>? other) => rowData.Equals(other?.GetRowData());
    public override bool Equals(object? obj) => obj is Immutable<T, M> other && Equals(other);
    public override int GetHashCode() => rowData.GetHashCode();
}

================
File: src/DataLinq/Instances/ImmutableRelation.cs
================
using System.Collections;
using System.Collections.Frozen;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using DataLinq.Cache;
using DataLinq.Metadata;
using DataLinq.Mutation;

namespace DataLinq.Instances;

public interface IImmutableRelation<T>: IEnumerable<T> where T : IModelInstance
{
    T? this[IKey key] { get; }

    int Count { get; }
    ImmutableArray<IKey> Keys { get; }
    ImmutableArray<T> Values { get; }

    IEnumerable<KeyValuePair<IKey, T>> AsEnumerable();
    void Clear();
    bool ContainsKey(IKey key);
    T? Get(IKey key);
    FrozenDictionary<IKey, T> ToFrozenDictionary();
}

public class ImmutableRelationMock<T> : IImmutableRelation<T> where T : IModelInstance
{
    private readonly IEnumerable<T> list;

    public ImmutableRelationMock(IEnumerable<T> list)
    {
        this.list = list;
    }

    public T? this[IKey key] => throw new System.NotImplementedException();

    public int Count => throw new System.NotImplementedException();

    public ImmutableArray<IKey> Keys => throw new System.NotImplementedException();

    public ImmutableArray<T> Values => throw new System.NotImplementedException();

    public IEnumerable<KeyValuePair<IKey, T>> AsEnumerable()
    {
        throw new System.NotImplementedException();
    }

    public void Clear()
    {
        throw new System.NotImplementedException();
    }

    public bool ContainsKey(IKey key)
    {
        throw new System.NotImplementedException();
    }

    public T? Get(IKey key)
    {
        throw new System.NotImplementedException();
    }

    public IEnumerator<T> GetEnumerator()
    {
        throw new System.NotImplementedException();
    }

    public FrozenDictionary<IKey, T> ToFrozenDictionary()
    {
        throw new System.NotImplementedException();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}

public class ImmutableRelation<T>(IKey foreignKey, DataSourceAccess dataSource, RelationProperty property) : IImmutableRelation<T> where T : IImmutableInstance
{
    protected FrozenDictionary<IKey, T>? relationInstances;
    // Flag to ensure we only attach our listener once.
    private bool _isListenerAttached = false;
    private readonly object _loadLock = new();

    /// <summary>
    /// Indexer to get an instance by its primary key.
    /// Returns null if the key is not found.
    /// </summary>
    public T? this[IKey key] => Get(key);

    /// <summary>
    /// A method that does the same as the indexer:
    /// returns the instance corresponding to the primary key, or null if not found.
    /// </summary>
    public T? Get(IKey key) => GetInstances().TryGetValue(key, out var instance) ? instance : default;

    public ImmutableArray<T> Values => GetInstances().Values;
    public ImmutableArray<IKey> Keys => GetInstances().Keys;
    public int Count => GetInstances().Count;
    public bool ContainsKey(IKey key) => GetInstances().ContainsKey(key);
    public IEnumerable<KeyValuePair<IKey, T>> AsEnumerable() => GetInstances().AsEnumerable();
    public FrozenDictionary<IKey, T> ToFrozenDictionary() => GetInstances();

    protected IEnumerable<T> GetRelation()
    {
        var source = GetDataSource();

        var otherSide = property.RelationPart.GetOtherSide();
        var tableCache = source.Provider.GetTableCache(otherSide.ColumnIndex.Table);

        if (!_isListenerAttached)
        {
            _isListenerAttached = true;
            tableCache.RowChanged += OnRowChanged;
        }

        return tableCache.GetRows(foreignKey, property, source).Select(x => (T)x);
    }

    // Event handler that clears the cached relation when any change occurs.
    private void OnRowChanged(object? sender, RowChangeEventArgs e)
    {
        // Clear the cached relation immediately.
        Clear();
    }

    protected DataSourceAccess GetDataSource()
    {
        if (dataSource is Transaction transaction && (transaction.Status == DatabaseTransactionStatus.Committed || transaction.Status == DatabaseTransactionStatus.RolledBack))
            dataSource = dataSource.Provider.ReadOnlyAccess;

        return dataSource;
    }

    protected FrozenDictionary<IKey, T> GetInstances()
    {
        // Use double-check locking to load the dictionary only once.
        if (relationInstances == null)
        {
            lock (_loadLock)
            {
                relationInstances ??= GetRelation().ToFrozenDictionary(x => x.PrimaryKeys());
            }
        }

        return relationInstances;
    }

    public void Clear()
    {
        relationInstances = null;
    }

    public IEnumerator<T> GetEnumerator()
    {
        // Cast to IEnumerable<T> so that we get an IEnumerator<T>.
        return ((IEnumerable<T>)GetInstances().Values).GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }
}

================
File: src/DataLinq/Instances/InstanceFactory.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Interfaces;
using DataLinq.Metadata;
using DataLinq.Mutation;

namespace DataLinq.Instances;

public interface IModelInstance : IModel
{
    object? this[string propertyName] { get; }
    object? this[ColumnDefinition column] { get; }
    IEnumerable<KeyValuePair<ColumnDefinition, object?>> GetValues();
    IEnumerable<KeyValuePair<ColumnDefinition, object?>> GetValues(IEnumerable<ColumnDefinition> columns);
    bool HasPrimaryKeysSet();
    ModelDefinition Metadata();
    IKey PrimaryKeys();
    IRowData GetRowData();
    void ClearLazy();
    V? GetLazy<V>(string name, Func<V> fetchCode);
}

public interface IModelInstance<T> : IModelInstance
    where T : IDatabaseModel
{
}

public interface IImmutableInstance : IModelInstance
{
    new RowData GetRowData();
    DataSourceAccess GetDataSource();
}

public interface IImmutableInstance<T> : IImmutableInstance, IModelInstance<T>
    where T : IDatabaseModel
{
}

public interface IImmutable<T>
    where T : IModel
{
    static T? Get(IKey key, DataSourceAccess dataSource)
    {
        var tableModel = dataSource.Provider.Metadata.TableModels.SingleOrDefault(x => x.Model.CsType.Type == typeof(T));
        if (tableModel == null)
            throw new Exception($"Found no TableDefinition for model '{typeof(T)}'");

        return (T?)dataSource.Provider.GetTableCache(tableModel.Table).GetRow(key, dataSource.Provider.ReadOnlyAccess);
    }
}


public interface IMutableInstance : IModelInstance
{
    new object? this[string propertyName] { get; set; }
    new object? this[ColumnDefinition column] { get; set; }

    IEnumerable<KeyValuePair<ColumnDefinition, object?>> GetChanges();
    bool IsNew();
    new MutableRowData GetRowData();
    bool IsDeleted();
    void SetDeleted();
    void Reset();
    void Reset(RowData rowData);
    void SetLazy<V>(string name, V value);
}

public interface IMutableInstance<T> : IMutableInstance, IModelInstance<T>
    where T : IDatabaseModel
{
}


public static class InstanceFactory
{
    public static IImmutableInstance NewImmutableRow(RowData rowData, IDatabaseProvider databaseProvider, DataSourceAccess dataSource)
    {
        if (rowData.Table.Model.ImmutableType?.Type == null)
            throw new Exception($"Immutable model type not defined for '{rowData.Table.Model.CsType}'");

        var model = Activator.CreateInstance(rowData.Table.Model.ImmutableType.Value.Type!, rowData, dataSource);

        if (model == null)
            throw new Exception($"Failed to create instance of immutable model type '{rowData.Table.Model.CsType}'");

        return (IImmutableInstance)model;
    }

    public static T NewImmutableRow<T>(RowData rowData, IDatabaseProvider databaseProvider, DataSourceAccess dataSource)
    {
        var model = NewImmutableRow(rowData, databaseProvider, dataSource);

        if (model == null)
            throw new Exception($"Failed to create instance of immutable model type '{typeof(T)}'");

        return (T)model;
    }

    public static T NewDatabase<T>(DataSourceAccess dataSource)
    {
        var db = Activator.CreateInstance(typeof(T), dataSource);

        if (db == null)
            throw new Exception($"Failed to create instance of database model type '{typeof(T)}'");

        return (T)db;
    }
}

================
File: src/DataLinq/Instances/KeyFactory.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Metadata;
using DataLinq.Query;

namespace DataLinq.Instances;

public static class KeyFactory
{
    public static IKey CreateKeyFromValue<T>(T? value)
    {
        if (value is RowData)
            throw new Exception("Cannot create a primary key from a RowData object. Use CreatePrimaryKey(RowData, Column[]) instead.");

        return value switch
        {
            null => new NullKey(),
            int intValue => new IntKey(intValue),
            long int64Value => new Int64Key(int64Value),
            ulong uInt64Value => new UInt64Key(uInt64Value),
            Guid guidValue => new GuidKey(guidValue),
            string stringValue => new StringKey(stringValue),
            _ => throw new Exception($"Type {value.GetType()} not supported as a key value")
        };
    }

    public static IKey CreateKeyFromValues(IEnumerable<object?> values)
    {
        var array = values.ToArray();

        if (array.Length == 1)
            return CreateKeyFromValue(array[0]);

        if (array.All(x => x == null))
            return new NullKey();

        return new CompositeKey(array);
    }

    public static IKey GetKey(IDataLinqDataReader reader, ColumnDefinition[] columns)
    {
        if (columns.Length == 1)
        {
            var columnType = columns[0].ValueProperty.CsType.Type;
            if (columnType == typeof(int))
                return CreateKeyFromValue(reader.GetInt32(0));
            else if (columnType == typeof(Guid))
                return CreateKeyFromValue(reader.GetGuid(0));
            else if (columnType == typeof(string))
                return CreateKeyFromValue(reader.GetString(0));
            else
                return CreateKeyFromValue(reader.GetValue<object>(columns[0], 0));
        }

        return new CompositeKey(columns.Select(x => reader.GetValue<object>(x)).ToArray());
    }

    public static IKey GetKey(RowData row, ColumnDefinition[] columns) =>
        CreateKeyFromValues(columns.Select(row.GetValue));

    public static IEnumerable<IKey> GetKeys<T>(Select<T> select, ColumnDefinition[] columns) => select
        .ReadReader()
        .Select(x => GetKey(x, columns));
}

================
File: src/DataLinq/Instances/Mutable.cs
================
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using DataLinq.Metadata;

namespace DataLinq.Instances;

public class Mutable<T> : IMutableInstance
    where T: IImmutableInstance
{
    private readonly ModelDefinition metadata;
    public ModelDefinition Metadata() => metadata;

    protected ConcurrentDictionary<string, object?>? lazyValues = null;
    private T? immutableInstance;
    public T? GetImmutableInstance() => immutableInstance;

    private bool isNew;
    public bool IsNew() => isNew;
    private bool isDeleted;
    public bool IsDeleted() => isDeleted;
    public bool HasChanges() => mutableRowData.HasChanges();

    private MutableRowData mutableRowData;
    public MutableRowData GetRowData() => mutableRowData;
    IRowData IModelInstance.GetRowData() => GetRowData();

    public object? this[ColumnDefinition column]
    {
        get => mutableRowData[column];
        set => mutableRowData.SetValue(column, value);
    }

    public object? this[string propertyName]
    {
        get => mutableRowData.GetValue(metadata.ValueProperties[propertyName].Column);
        set => mutableRowData.SetValue(metadata.ValueProperties[propertyName].Column, value);
    }

    public Mutable()
    {
        metadata = ModelDefinition.Find<T>() ?? throw new InvalidOperationException($"Model {typeof(T).Name} not found");
        this.mutableRowData = new MutableRowData(metadata.Table);
        isNew = true;
    }

    public Mutable(T model)
    {
        this.immutableInstance = model;
        this.mutableRowData = new MutableRowData(model.GetRowData());
        this.metadata = model.Metadata();
        this.isNew = false;
    }

    public Mutable(RowData rowData)
    {
        this.mutableRowData = new MutableRowData(rowData);
        this.metadata = rowData.Table.Model;
        this.isNew = false;
    }

    public void Reset() => mutableRowData.Reset();
    public void Reset(T model)
    {
        mutableRowData.Reset(model.GetRowData());
        isNew = false;
    }

    public void Reset(RowData rowData)
    {
        mutableRowData.Reset(rowData);
        isNew = false;
    }

    public void SetDeleted() => isDeleted = true;

    public object? GetValue(string propertyName) => mutableRowData.GetValue(metadata.ValueProperties[propertyName].Column);
    public void SetValue<V>(string propertyName, V value) => mutableRowData.SetValue(metadata.ValueProperties[propertyName].Column, value);

    public IKey PrimaryKeys() => KeyFactory.CreateKeyFromValues(mutableRowData.GetValues(metadata.Table.PrimaryKeyColumns));
    public bool HasPrimaryKeysSet() => PrimaryKeys() is not NullKey;

    public IEnumerable<KeyValuePair<ColumnDefinition, object?>> GetChanges() => mutableRowData.GetChanges();

    public IEnumerable<KeyValuePair<ColumnDefinition, object?>> GetValues() => mutableRowData.GetColumnAndValues();

    public IEnumerable<KeyValuePair<ColumnDefinition, object?>> GetValues(IEnumerable<ColumnDefinition> columns) => mutableRowData.GetColumnAndValues(columns);

    public void ClearLazy() => lazyValues?.Clear();

    public void SetLazy<V>(string name, V value)
    {
        lazyValues ??= new ConcurrentDictionary<string, object?>();
        lazyValues[name] = value;
    }

    public V? GetLazy<V>(string name, Func<V> fetchCode)
    {
        lazyValues ??= new ConcurrentDictionary<string, object?>();

        if (!lazyValues.TryGetValue(name, out var value) || value == null)
        {
            value = fetchCode();
            lazyValues[name] = value;
        }

        return (V?)value;
    }
}

================
File: src/DataLinq/Instances/MutableRowData.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Metadata;

namespace DataLinq.Instances;

public class MutableRowData : IRowData
{
    RowData? ImmutableRowData { get; set; }
    Dictionary<ColumnDefinition, object?> MutatedData { get; } = new Dictionary<ColumnDefinition, object?>();
    public TableDefinition Table { get; }
    public bool HasChanges() => MutatedData.Count > 0;

    public object? this[ColumnDefinition column] => GetValue(column);

    public MutableRowData(TableDefinition table)
    {
        this.Table = table;
    }

    public MutableRowData(RowData immutableRowData)
    {
        this.ImmutableRowData = immutableRowData;
        this.Table = immutableRowData.Table;
    }

    public void Reset()
    {
        MutatedData.Clear();
    }

    public void Reset(RowData immutableRowData)
    {
        if (immutableRowData.Table != Table)
            throw new InvalidOperationException("Cannot reset row data with different table definition.");

        this.ImmutableRowData = immutableRowData;
        MutatedData.Clear();
    }

    public object? GetValue(ColumnDefinition column)
    {
        if (MutatedData.TryGetValue(column, out var value))
            return value;

        return ImmutableRowData?.GetValue(column);
    }

    public IEnumerable<object?> GetValues(IEnumerable<ColumnDefinition> columns)
    {
        foreach (var column in columns)
            yield return GetValue(column);
    }

    public void SetValue(ColumnDefinition column, object? value)
    {
        if (value == null || column.ValueProperty.CsType.Type == null || value.GetType() == column.ValueProperty.CsType.Type)
            MutatedData[column] = value;
        else
            MutatedData[column] = Convert.ChangeType(value, column.ValueProperty.CsType.Type);
    }

    public IEnumerable<KeyValuePair<ColumnDefinition, object?>> GetColumnAndValues()
    {
        if (ImmutableRowData == null)
            return MutatedData.AsEnumerable();

        return GetColumnAndValues(ImmutableRowData.GetColumnAndValues().Select(x => x.Key));
    }

    public IEnumerable<KeyValuePair<ColumnDefinition, object?>> GetColumnAndValues(IEnumerable<ColumnDefinition> columns)
    {
        foreach (var column in columns)
            yield return new KeyValuePair<ColumnDefinition, object?>(column, GetValue(column));
    }

    public IEnumerable<KeyValuePair<ColumnDefinition, object?>> GetChanges()
    {
        foreach (var change in MutatedData)
            yield return change;
    }

    IEnumerable<object?> IRowData.GetValues(IEnumerable<ColumnDefinition> columns)
    {
        throw new System.NotImplementedException();
    }
}

================
File: src/DataLinq/Instances/RowData.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Metadata;

namespace DataLinq.Instances;

public interface IRowData
{
    TableDefinition Table { get; }

    object? this[ColumnDefinition column] { get; }

    object? GetValue(ColumnDefinition column);

    IEnumerable<object?> GetValues(IEnumerable<ColumnDefinition> columns);

    IEnumerable<KeyValuePair<ColumnDefinition, object?>> GetColumnAndValues();

    IEnumerable<KeyValuePair<ColumnDefinition, object?>> GetColumnAndValues(IEnumerable<ColumnDefinition> columns);
}

public class RowData : IRowData, IEquatable<RowData>
{
    public RowData(IDataLinqDataReader reader, TableDefinition table, ReadOnlySpan<ColumnDefinition> columns)
    {
        Table = table;
        (Data, Size) = ReadReader(reader, columns);
    }

    protected Dictionary<ColumnDefinition, object?> Data { get; }

    public TableDefinition Table { get; }

    public int Size { get; }

    public object? this[ColumnDefinition column] => GetValue(column);

    public object? GetValue(ColumnDefinition column)
    {
        if (Data == null || !Data.TryGetValue(column, out var value))
            throw new InvalidOperationException($"Data dictionary is not initialized or column '{column.DbName}' key does not exist.");

        return value;
    }

    public IEnumerable<KeyValuePair<ColumnDefinition, object?>> GetColumnAndValues()
    {
        return Data.AsEnumerable();
    }

    public IEnumerable<KeyValuePair<ColumnDefinition, object?>> GetColumnAndValues(IEnumerable<ColumnDefinition> columns)
    {
        foreach (var column in columns)
            yield return new KeyValuePair<ColumnDefinition, object?>(column, GetValue(column));
    }

    public IEnumerable<object?> GetValues(IEnumerable<ColumnDefinition> columns)
    {
        foreach (var column in columns)
            yield return GetValue(column);
    }

    private static (Dictionary<ColumnDefinition, object?> data, int size) ReadReader(IDataLinqDataReader reader, ReadOnlySpan<ColumnDefinition> columns)
    {
        var data = new Dictionary<ColumnDefinition, object?>();
        var size = 0;

        foreach (var column in columns)
        {
            var value = reader.GetValue<object>(column);
            size += GetSize(column, value);

            data.Add(column, value);
        }

        return (data, size);
    }

    private static int GetSize(ColumnDefinition column, object? value)
    {
        if (value == null)
            return 0;

        if (column.ValueProperty.CsSize.HasValue)
            return column.ValueProperty.CsSize.Value;

        if (column.ValueProperty.CsType.Type == typeof(string) && value is string s)
            return s.Length * sizeof(char) + sizeof(int);

        if (column.ValueProperty.CsType.Type == typeof(byte[]) && value is byte[] b)
            return b.Length;

        throw new NotImplementedException($"Size for type '{column.ValueProperty.CsType}' not implemented");
    }

    public bool Equals(RowData? other)
    {
        if (Data.Count != other?.Data.Count)
            return false;

        foreach (var kvp in Data)
        {
            if (!other.Data.TryGetValue(kvp.Key, out var value) && value != kvp.Value)
                return false;
        }

        return true;
    }

    public override bool Equals(object? obj)
    {
        return obj is RowData other && Equals(other);
    }

    public override int GetHashCode()
    {
        var hash = new HashCode();

        foreach (var kvp in Data.OrderBy(kvp => kvp.Key))
        {
            hash.Add(kvp.Key);
            hash.Add(kvp.Value);
        }

        return hash.ToHashCode();
    }
}

================
File: src/DataLinq/Interfaces/IDatabaseProvider.cs
================
using System;
using System.Data;
using DataLinq.Cache;
using DataLinq.Metadata;
using DataLinq.Mutation;
using DataLinq.Query;

namespace DataLinq.Interfaces;

public interface IDatabaseProvider : IDisposable
{
    string DatabaseName { get; }
    string ConnectionString { get; }
    DatabaseDefinition Metadata { get; }
    DatabaseAccess DatabaseAccess { get; }
    State State { get; }
    IDatabaseProviderConstants Constants { get; }
    ReadOnlyAccess ReadOnlyAccess { get; }

    IDbCommand ToDbCommand(IQuery query);

    Transaction StartTransaction(TransactionType transactionType = TransactionType.ReadAndWrite);


    DatabaseTransaction GetNewDatabaseTransaction(TransactionType type);

    DatabaseTransaction AttachDatabaseTransaction(IDbTransaction dbTransaction, TransactionType type);

    string GetLastIdQuery();

    TableCache GetTableCache(TableDefinition table);

    Sql GetParameter(Sql sql, string key, object? value);

    Sql GetParameterValue(Sql sql, string key);

    Sql GetParameterComparison(Sql sql, string field, Query.Relation relation, string[] prefix);

    Sql GetLimitOffset(Sql sql, int? limit, int? offset);

    bool DatabaseExists(string? databaseName = null);
    bool FileOrServerExists();

    IDataLinqDataWriter GetWriter();
    Sql GetTableName(Sql sql, string tableName, string? alias = null);
    M Commit<M>(Func<Transaction, M> func);
    void Commit(Action<Transaction> action);
}

================
File: src/DataLinq/Interfaces/IDatabaseProviderConstants.cs
================
namespace DataLinq.Interfaces;

public interface IDatabaseProviderConstants
{
    string ParameterSign { get; }
    string LastInsertCommand { get; }
    string EscapeCharacter { get; }
    bool SupportsMultipleDatabases { get; }
}

================
File: src/DataLinq/Interfaces/IDatabaseProviderRegister.cs
================
using System;

namespace DataLinq.Interfaces;

public interface IDatabaseProviderRegister
{
    static bool HasBeenRegistered { get; }
    static void RegisterProvider() => throw new NotImplementedException();
}

================
File: src/DataLinq/Linq/Evaluator.cs
================
using System;
using System.Collections.Generic;
using System.Linq.Expressions;

namespace DataLinq.Linq;

internal static class Evaluator
{
    /// <summary>
    /// Performs evaluation and replacement of independent sub-trees
    /// </summary>
    /// <param name="expression">The root of the expression tree.</param>
    /// <param name="fnCanBeEvaluated">A function that decides whether a given expression node can be part of the local function.</param>
    /// <returns>A new tree with sub-trees evaluated and replaced.</returns>
    public static Expression? PartialEval(Expression expression, Func<Expression, bool> fnCanBeEvaluated)
    {
        return new SubtreeEvaluator(new Nominator(fnCanBeEvaluated).Nominate(expression)).Eval(expression);
    }

    /// <summary>
    /// Performs evaluation and replacement of independent sub-trees
    /// </summary>
    /// <param name="expression">The root of the expression tree.</param>
    /// <returns>A new tree with sub-trees evaluated and replaced.</returns>
    public static Expression? PartialEval(Expression expression)
    {
        return PartialEval(expression, Evaluator.CanBeEvaluatedLocally);
    }

    private static bool CanBeEvaluatedLocally(Expression expression)
    {
        return expression.NodeType != ExpressionType.Parameter;
    }

    /// <summary>
    /// Evaluates and replaces sub-trees when first candidate is reached (top-down)
    /// </summary>
    private class SubtreeEvaluator : ExpressionVisitor
    {
        private readonly HashSet<Expression> candidates;

        internal SubtreeEvaluator(HashSet<Expression> candidates)
        {
            this.candidates = candidates;
        }

        internal Expression? Eval(Expression exp)
        {
            return this.Visit(exp);
        }

        public override Expression? Visit(Expression? node)
        {
            if (node == null)
            {
                return null;
            }
            if (this.candidates.Contains(node))
            {
                return this.Evaluate(node);
            }
            return base.Visit(node);
        }

        private Expression Evaluate(Expression e)
        {
            if (e.NodeType == ExpressionType.Constant)
            {
                return e;
            }
            LambdaExpression lambda = Expression.Lambda(e);
            Delegate fn = lambda.Compile();
            return Expression.Constant(fn.DynamicInvoke(null), e.Type);
        }
    }

    /// <summary>
    /// Performs bottom-up analysis to determine which nodes can possibly
    /// be part of an evaluated sub-tree.
    /// </summary>
    private class Nominator : ExpressionVisitor
    {
        private readonly Func<Expression, bool> fnCanBeEvaluated;
        private HashSet<Expression> candidates = new HashSet<Expression>();
        private bool cannotBeEvaluated;

        internal Nominator(Func<Expression, bool> fnCanBeEvaluated)
        {
            this.fnCanBeEvaluated = fnCanBeEvaluated;
        }

        internal HashSet<Expression> Nominate(Expression expression)
        {
            //this.candidates = new HashSet<Expression>();
            this.Visit(expression);
            return this.candidates;
        }

        public override Expression? Visit(Expression? node)
        {
            if (node != null)
            {
                bool saveCannotBeEvaluated = this.cannotBeEvaluated;
                this.cannotBeEvaluated = false;
                base.Visit(node);
                if (!this.cannotBeEvaluated)
                {
                    if (this.fnCanBeEvaluated(node))
                    {
                        this.candidates.Add(node);
                    }
                    else
                    {
                        this.cannotBeEvaluated = true;
                    }
                }
                this.cannotBeEvaluated |= saveCannotBeEvaluated;
            }
            return node;
        }
    }
}

================
File: src/DataLinq/Linq/Queryable.cs
================
using System.Linq;
using System.Linq.Expressions;
using DataLinq.Linq;
using DataLinq.Metadata;
using DataLinq.Mutation;
using Remotion.Linq;
using Remotion.Linq.Parsing.Structure;

namespace DataLinq;

public class Queryable<T> : QueryableBase<T>
{
    protected static readonly IQueryParser queryParser = QueryParser.CreateDefault();

    public Queryable(IQueryProvider provider, Expression expression) : base(provider, expression) { }

    public Queryable(DataSourceAccess dataSource, TableDefinition table) : base(queryParser, new QueryExecutor(dataSource, table)) { }
}

================
File: src/DataLinq/Linq/QueryExecutor.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using DataLinq.Metadata;
using DataLinq.Mutation;
using DataLinq.Query;
using Remotion.Linq;
using Remotion.Linq.Clauses;
using Remotion.Linq.Clauses.Expressions;
using Remotion.Linq.Clauses.ResultOperators;

namespace DataLinq.Linq;

/// <summary>
/// The QueryExecutor class is responsible for converting a QueryModel into SQL queries and executing them
/// against a database using a provided Transaction context and TableMetadata.
/// </summary>
/// <remarks>
/// This class serves as a critical component in the LINQ to SQL translation and execution process.
/// It handles the parsing and execution of different query types such as collections, single entities,
/// and scalar values. It also applies result operators to the queries.
/// 
/// TODO: Consider implementing async versions of the Execute methods to improve performance
/// on I/O bound database operations and to allow for scalability in applications requiring asynchronous processing.
/// </remarks>
internal class QueryExecutor : IQueryExecutor
{
    /// <summary>
    /// Initializes a new instance of the QueryExecutor class with the specified transaction and table metadata.
    /// </summary>
    internal QueryExecutor(DataSourceAccess transaction, TableDefinition table)
    {
        this.Transaction = transaction;
        this.Table = table;
    }

    /// <summary>Gets the transaction associated with the query executor.</summary>
    private DataSourceAccess Transaction { get; }

    /// <summary>Gets the metadata for the table that queries will be executed against.</summary>
    private TableDefinition Table { get; }

    private static QueryModel? ExtractQueryModel(Expression? expression)
    {
        switch (expression)
        {
            case SubQueryExpression subQueryExpression:
                return subQueryExpression.QueryModel;

            case MemberExpression memberExpression:
                return QueryExecutor.ExtractQueryModel(memberExpression.Expression);

            case MethodCallExpression methodCallExpression:
                foreach (var argument in methodCallExpression.Arguments)
                {
                    var subQuery = QueryExecutor.ExtractQueryModel(argument);
                    if (subQuery != null)
                        return subQuery;
                }
                break;

            case UnaryExpression unaryExpression:
                return QueryExecutor.ExtractQueryModel(unaryExpression.Operand);

            case ConstantExpression constantExpression when constantExpression.Value is IQueryable queryable:
                return null;
        }

        return null;
    }

    /// <summary>
    /// Parses the provided QueryModel into a SQL query.
    /// </summary>
    /// <remarks>
    /// The method parses through body clauses and result operators to construct a SQL query.
    /// It uses the Where and OrderBy clauses to form the SQL conditions and ordering.
    /// </remarks>
    private Select<T> ParseQueryModel<T>(QueryModel queryModel)
    {
        // Extract the subquery model from the main clause if necessary
        var subQueryModel = ExtractQueryModel(queryModel.MainFromClause.FromExpression);
        if (subQueryModel != null)
        {
            // Recursively parse the subquery model
            return ParseQueryModel<T>(subQueryModel);
        }

        var query = new SqlQuery<T>(Table, Transaction);

        foreach (var body in queryModel.BodyClauses)
        {
            if (body is WhereClause where)
            {
                query.Where(where);
            }

            if (body is OrderByClause orderBy)
            {
                query.OrderBy(orderBy);
            }
        }

        foreach (var op in queryModel.ResultOperators)
        {
            if (op is TakeResultOperator takeOperator && takeOperator.Count is ConstantExpression takeExpression)
            {
                query.Limit((int)takeExpression.Value!);
            }
            else if (op is SkipResultOperator skipOperator && skipOperator.Count is ConstantExpression skipExpression)
            {
                query.Offset((int)skipExpression.Value!);
            }

            var opString = op.ToString();

            if (opString == "Single()")
                query.Limit(2);
            else if (opString == "SingleOrDefault()")
                query.Limit(2);
            else if (opString == "First()")
                query.Limit(1);
            else if (opString == "FirstOrDefault()")
                query.Limit(1);
            else if (opString == "Any()")
                query.Limit(1);
        }

        return query.SelectQuery();
    }

    private static Func<object?, T?> GetSelectFunc<T>(SelectClause selectClause)
    {
        if (selectClause != null && selectClause.Selector.NodeType == ExpressionType.MemberAccess)
        {
            if (selectClause.Selector is not MemberExpression memberExpression)
                throw new NotImplementedException($"'{selectClause.Selector}' selector is not implemented");

            if (memberExpression.Member is not PropertyInfo prop)
                throw new NotImplementedException($"'{memberExpression.Member}' member is not implemented");

            return x => (T?)prop.GetValue(x);
        }
        else if (selectClause?.Selector.NodeType == ExpressionType.New)
        {
            if (selectClause.Selector is not NewExpression newExpression)
                throw new NotImplementedException($"'{selectClause.Selector}' selector is not implemented");

            if (newExpression.Arguments[0] is not MemberExpression argumentExpression)
                throw new NotImplementedException($"'{newExpression.Arguments[0]}' argument is not implemented");

            if (argumentExpression.Expression == null)
                throw new NotImplementedException($"'{argumentExpression}' expression is not implemented");

            var memberType = argumentExpression.Expression.Type;
            var param = Expression.Parameter(typeof(object));
            var convert = Expression.Convert(param, memberType);

            var arguments = newExpression.Arguments.Select(x =>
            {
                if (x is not MemberExpression memberExp)
                    throw new NotImplementedException($"'{x}' argument is not implemented");

                return Expression.MakeMemberAccess(convert, memberExp.Member);
            });

            if (newExpression.Constructor == null)
                throw new NotImplementedException($"'{newExpression}' constructor is not implemented");

            var expression = Expression.New(newExpression.Constructor, arguments, newExpression.Members);
            var lambda = Expression.Lambda<Func<object?, T?>>(expression, param);

            return lambda.Compile();
        }

        return x => (T?)x;
    }

    /// <summary>
    /// Executes the query represented by the QueryModel as a collection of objects of type T.
    /// </summary>
    /// <remarks>
    /// This method performs the actual execution of the SQL query and maps the result set
    /// to a collection of objects of the specified type using a projection function.
    /// </remarks>
    public IEnumerable<T?> ExecuteCollection<T>(QueryModel queryModel)
    {
        return ParseQueryModel<T>(queryModel)
            .Execute()
            .Select(GetSelectFunc<T>(queryModel.SelectClause));
    }

    /// <summary>
    /// Executes the query represented by the QueryModel and returns a single object of type T.
    /// </summary>
    /// <remarks>
    /// This method caters to executing queries that are expected to return a single result.
    /// It applies the correct result operator based on the QueryModel's specifications.
    /// 
    /// TODO: Introduce error handling to provide more informative exceptions when queries
    /// do not behave as expected, e.g., when a Single() query returns multiple results.
    /// </remarks>
    public T? ExecuteSingle<T>(QueryModel queryModel, bool returnDefaultWhenEmpty)
    {
        var sequence = ParseQueryModel<T>(queryModel)
            .Execute()
            .Select(GetSelectFunc<T>(queryModel.SelectClause));

        if (queryModel.ResultOperators.Any())
        {
            var op = queryModel.ResultOperators[0].ToString();

            return op switch
            {
                "Single()" => sequence.Single(),
                "SingleOrDefault()" => sequence.SingleOrDefault(),
                "First()" => sequence.First(),
                "FirstOrDefault()" => sequence.FirstOrDefault(),
                "Last()" => sequence.Last(),
                "LastOrDefault()" => sequence.LastOrDefault(),
                _ => throw new NotImplementedException($"Unknown operator '{op}'")
            };
        }

        throw new NotImplementedException();
    }

    /// <summary>
    /// Executes the query represented by the QueryModel and returns a scalar value of type T.
    /// </summary>
    /// <remarks>
    /// This method is used for queries that are expected to return a single scalar value, such as counts or existence checks.
    /// 
    /// TODO: Investigate the possibility of extending support for more complex aggregate functions and
    /// grouping operations to enhance the capability of scalar queries.
    /// </remarks>
    public T ExecuteScalar<T>(QueryModel queryModel)
    {
        if (queryModel.ResultOperators.Any())
        {
            var select = ParseQueryModel<T>(queryModel);
            var op = queryModel.ResultOperators[0].ToString();

            // Modify the SQL query for Count() or Any()
            if (op == "Count()" || op == "Any()")
                select.What("COUNT(*)");
            else
                throw new NotImplementedException($"Query results operator '{op}' is not implemented");

            // Execute the scalar query
            var result = select.ExecuteScalar();

            // Handle the result for different types
            if (result is int intResult)
            {
                if (typeof(T) == typeof(int))
                    return (T)(object)intResult;

                if (typeof(T) == typeof(long))
                    return (T)(object)(long)intResult;

                if (typeof(T) == typeof(bool) && op == "Any()")
                    return (T)(object)(intResult > 0);
            }
            else if (result is long longResult)
            {
                if (typeof(T) == typeof(long))
                    return (T)(object)longResult;

                if (typeof(T) == typeof(int))
                    return (T)(object)(int)longResult;

                if (typeof(T) == typeof(bool) && op == "Any()")
                    return (T)(object)(longResult > 0);
            }

            throw new InvalidOperationException($"Unexpected result type '{result?.GetType()}' for operator '{op}'");
        }

        throw new NotImplementedException($"The query model lacks a results operator: '{queryModel}'");
    }
}

================
File: src/DataLinq/Linq/TypeSystem.cs
================
using System;
using System.Collections;
using System.Collections.Generic;

namespace DataLinq.Linq;

/// <summary>
/// Provides utility methods for working with types in a LINQ-to-SQL context,
/// particularly for determining the element types of sequences.
/// </summary>
internal static class TypeSystem
{
    /// <summary>
    /// Determines the element type of a sequence given a <see cref="Type"/> that represents the sequence.
    /// </summary>
    /// <param name="seqType">The type of the sequence.</param>
    /// <returns>The element type of the sequence. If the sequence type is not an <see cref="IEnumerable"/>,
    /// or if it is a string, returns the sequence type itself.</returns>
    internal static Type GetElementType(Type seqType)
    {
        var ienum = FindIEnumerable(seqType);

        // If no IEnumerable interface is found, return the sequence type itself.
        if (ienum == null)
            return seqType;

        // The element type is the generic argument of the IEnumerable interface.
        return ienum.GetGenericArguments()[0];
    }

    /// <summary>
    /// Finds the <see cref="IEnumerable{T}"/> interface for a given sequence type.
    /// </summary>
    /// <param name="seqType">The type of the sequence.</param>
    /// <returns>The <see cref="IEnumerable{T}"/> interface type if found; otherwise, null.</returns>
    /// <remarks>
    /// This method checks if the provided type is a string or null, an array, a generic type,
    /// or implements any interfaces that are assignable from <see cref="IEnumerable{T}"/>,
    /// and recursively checks the base type if necessary.
    /// </remarks>
    private static Type? FindIEnumerable(Type seqType)
    {
        if (seqType == null || seqType == typeof(string))
            return null;

        if (seqType.IsArray)
            return typeof(IEnumerable<>).MakeGenericType(seqType.GetElementType()!);

        if (seqType.IsGenericType)
        {
            foreach (Type arg in seqType.GetGenericArguments())
            {
                Type ienum = typeof(IEnumerable<>).MakeGenericType(arg);

                if (ienum.IsAssignableFrom(seqType))
                {
                    return ienum;
                }
            }
        }

        Type[] ifaces = seqType.GetInterfaces();

        if (ifaces != null && ifaces.Length > 0)
        {
            foreach (Type iface in ifaces)
            {
                var ienum = FindIEnumerable(iface);

                if (ienum != null)
                    return ienum;
            }
        }

        // Recursively check the base type if it's not the root object type.
        if (seqType.BaseType != null && seqType.BaseType != typeof(object))
        {
            return FindIEnumerable(seqType.BaseType);
        }

        return null;
    }
}

================
File: src/DataLinq/Linq/Visitors/OrderByVisitor.cs
================
using System;
using System.Linq.Expressions;
using DataLinq.Query;
using Remotion.Linq.Clauses;

namespace DataLinq.Linq.Visitors;

internal class OrderByVisitor<T> : ExpressionVisitor
{
    protected SqlQuery<T> select;
    protected OrderingDirection direction;

    internal OrderByVisitor(SqlQuery<T> query)
    {
        this.select = query;
    }

    internal void Parse(Ordering ordering)
    {
        direction = ordering.OrderingDirection;
        Visit(ordering.Expression);
    }

    //protected override Expression VisitExtension(Expression node)
    //{
    //    return base.VisitExtension(node);
    //}

    protected override Expression VisitMember(MemberExpression node)
    {
        if (node.NodeType == ExpressionType.MemberAccess)
        {
            var column = select.GetColumn(node);

            if (column == null)
                throw new Exception($"Database column for property '{node.Member.Name}' not found");

            select.OrderBy(column, null, direction == OrderingDirection.Asc);
        }
        else
            throw new NotImplementedException("Operation not implemented");

        return node;
    }

    //protected override Expression VisitBinary(BinaryExpression node)
    //{
    //    if (node.NodeType == ExpressionType.AndAlso)
    //    {
    //        Visit(node.Left);
    //        Visit(node.Right);

    //        return node;
    //    }

    //    var fields = select.GetFields(node);

    //    var where = select.Where(fields.Key);

    //    if (node.NodeType == ExpressionType.Equal)
    //        where.EqualTo(fields.Value);
    //    else if (node.NodeType == ExpressionType.NotEqual)
    //        where.NotEqualTo(fields.Value);
    //    else if (node.NodeType == ExpressionType.GreaterThan)
    //        where.GreaterThan(fields.Value);
    //    else if (node.NodeType == ExpressionType.GreaterThanOrEqual)
    //        where.GreaterThanOrEqual(fields.Value);
    //    else if (node.NodeType == ExpressionType.LessThan)
    //        where.LessThan(fields.Value);
    //    else if (node.NodeType == ExpressionType.LessThanOrEqual)
    //        where.LessThanOrEqual(fields.Value);
    //    else
    //        throw new NotImplementedException("Operation not implemented");

    //    return node;
    //}
}

================
File: src/DataLinq/Linq/Visitors/WhereVisitor.cs
================
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Xml.Linq;
using DataLinq.Query;
using DataLinq.Utils;
using Remotion.Linq.Clauses;
using Remotion.Linq.Clauses.ResultOperators;

namespace DataLinq.Linq.Visitors;

/// <summary>
/// The WhereVisitor class is responsible for traversing an expression tree 
/// that represents a LINQ Where clause and converting it into the corresponding 
/// SQL query predicates.
/// </summary>
internal class WhereVisitor<T> : ExpressionVisitor
{
    protected SqlQuery<T> query;
    // Tracks the number of negations (NOT operations) encountered.
    NonNegativeInt negations = new NonNegativeInt(0);
    // Tracks the number of OR operations encountered.
    NonNegativeInt ors = new NonNegativeInt(0);
    // A stack to manage groups of WHERE clauses.
    Stack<WhereGroup<T>> whereGroups = new Stack<WhereGroup<T>>();

    /// <summary>
    /// Initializes a new instance of the WhereVisitor with a given SQL query.
    /// </summary>
    /// <param name="query">The SQL query to be built upon.</param>
    internal WhereVisitor(SqlQuery<T> query)
    {
        this.query = query;
    }

    /// <summary>
    /// Parses a given WhereClause into SQL query predicates.
    /// </summary>
    /// <param name="whereClause">The LINQ WhereClause to parse.</param>
    internal void Parse(WhereClause whereClause)
    {
        Visit(whereClause.Predicate);
    }

    protected override Expression VisitConstant(ConstantExpression node)
    {
        return base.VisitConstant(node);
    }

    protected override Expression VisitConditional(ConditionalExpression node)
    {
        return base.VisitConditional(node);
    }

    // TODO: Consider handling other unary operators if needed.
    protected override Expression VisitUnary(UnaryExpression node)
    {
        if (node.NodeType == ExpressionType.Not)
            negations.Increment();

        // Unwraps nested Convert operations, if any, to get to the actual expression.
        if (node.NodeType == ExpressionType.Convert)
        {
            while (node.NodeType == ExpressionType.Convert && node.Operand is UnaryExpression expr)
                node = expr;

            return Visit(node.Operand);
        }

        return base.VisitUnary(node);
    }

    protected override Expression VisitExtension(Expression node)
    {
        if (node.CanReduce)
        {
            return Visit(node.Reduce());
        }

        if (node is Remotion.Linq.Clauses.Expressions.QuerySourceReferenceExpression querySourceRef)
        {
            return querySourceRef;
        }

        if (node is Remotion.Linq.Clauses.Expressions.SubQueryExpression subQuery)
        {
            foreach (var resultOperator in subQuery.QueryModel.ResultOperators)
            {
                if (resultOperator is ContainsResultOperator containsResultOperator)
                {
                    var field = (string)query.GetValue(Visit(containsResultOperator.Item));
                    var array = ConvertToList(query.GetValue(Visit(subQuery.QueryModel.MainFromClause.FromExpression)));

                    AddWhere(Operation.Contains, field, array);
                }
                else
                    throw new NotImplementedException($"Operation '{resultOperator}' not implemented");
            }

            return node;
        }

        return base.VisitExtension(node);
    }

    protected override Expression VisitMember(MemberExpression node)
    {
        if (node.Member.Name == "Value" && Nullable.GetUnderlyingType(node.Expression.Type) != null)
        {
            var nonNullableType = Nullable.GetUnderlyingType(node.Expression.Type);
            var memberExp = Expression.Property(node.Expression, nonNullableType.GetProperty("Value"));

            return Expression.Convert(memberExp, nonNullableType);
        }

        return base.VisitMember(node);
    }

    // TODO: Extend to support additional method calls as necessary.
    // Throws exceptions for unsupported scenarios, indicating areas that require implementation.
    protected override Expression VisitMethodCall(MethodCallExpression node)
    {
        if (node.Object == null)
            throw new ArgumentNullException(nameof(node.Object), "Parsing of node without object is not supported");

        if (node.Arguments.Count != 1)
            throw new NotImplementedException($"Operation '{node.Method.Name}' with {node.Arguments.Count} arguments not implemented");

        var field = (string)query.GetValue(node.Object);
        var value = query.GetValue(node.Arguments[0]);

        AddWhere(GetOperation(node.Method.Name), field, [value]);

        return node;
    }

    // Handles binary operations and translates them into SQL predicates.
    // TODO: Handle additional binary expressions as needed.
    protected override Expression VisitBinary(BinaryExpression node)
    {
        var left = node.Left;
        var right = node.Right;

        if (node.NodeType == ExpressionType.AndAlso || node.NodeType == ExpressionType.OrElse)
        {
            whereGroups.Push(negations.Decrement() > 0
                ? query.AddWhereNotGroup(ors.Decrement() > 0 ? BooleanType.Or : BooleanType.And)
                : query.AddWhereGroup(ors.Decrement() > 0 ? BooleanType.Or : BooleanType.And));

            Visit(left);

            if (node.NodeType == ExpressionType.OrElse)
                ors.Increment();

            Visit(right);

            whereGroups.Pop();

            return node;
        }

        left = Visit(left);
        right = Visit(right);

        var fields = query.GetFields(left, right);

        if (node.NodeType == ExpressionType.NotEqual && fields.Value is bool bValue && bValue == true)
        {
            whereGroups.Push(query.AddWhereGroup(BooleanType.And));
            AddWhere(Operation.EqualNull, fields.Key);
            ors.Increment();
            AddWhere(GetOperation(node.NodeType), fields.Key, fields.Value);
            whereGroups.Pop();
        }
        else       
            AddWhere(GetOperation(node.NodeType), fields.Key, fields.Value);

        //var group = whereGroups.Count > 0
        //    ? whereGroups.Peek()
        //    : query.GetBaseWhereGroup();

        //var where = negations.Decrement() > 0
        //    ? group.AddWhereNot(fields.Key, null, ors.Decrement() > 0 ? BooleanType.Or : BooleanType.And)
        //    : group.AddWhere(fields.Key, null, ors.Decrement() > 0 ? BooleanType.Or : BooleanType.And);

        //List<(ExpressionType type, object value)> nodeTypes = [(node.NodeType, fields.Value)];

        //if (node.NodeType == ExpressionType.NotEqual && fields.Value is bool bValue && bValue == true)
        //    nodeTypes.Add((ExpressionType.Equal, );

        //foreach (var (nodeType, value) in nodeTypes)
        //{
        //    switch (nodeType)
        //    {
        //        case ExpressionType.Equal:
        //            where.EqualTo(fields.Value);
        //            break;
        //        case ExpressionType.NotEqual:
        //            where.NotEqualTo(fields.Value);
        //            break;
        //        case ExpressionType.GreaterThan:
        //            where.GreaterThan(fields.Value);
        //            break;
        //        case ExpressionType.GreaterThanOrEqual:
        //            where.GreaterThanOrEqual(fields.Value);
        //            break;
        //        case ExpressionType.LessThan:
        //            where.LessThan(fields.Value);
        //            break;
        //        case ExpressionType.LessThanOrEqual:
        //            where.LessThanOrEqual(fields.Value);
        //            break;
        //        default:
        //            throw new NotImplementedException("Operation not implemented");
        //    }
        //}

        return node;
    }

    private void AddWhere(Operation operation, string field, params object[] values)
    {
        var group = whereGroups.Count > 0
                    ? whereGroups.Peek()
                    : query.GetBaseWhereGroup();

        var where = negations.Decrement() > 0
            ? group.AddWhereNot(field, null, ors.Decrement() > 0 ? BooleanType.Or : BooleanType.And)
            : group.AddWhere(field, null, ors.Decrement() > 0 ? BooleanType.Or : BooleanType.And);

        switch (operation)
        {
            case Operation.Equal:
                where.EqualTo(values[0]);
                break;
            case Operation.EqualNull:
                where.EqualToNull();
                break;
            case Operation.NotEqual:
                where.NotEqualTo(values[0]);
                break;
            case Operation.NotEqualNull:
                where.NotEqualToNull();
                break;
            case Operation.GreaterThan:
                where.GreaterThan(values[0]);
                break;
            case Operation.GreaterThanOrEqual:
                where.GreaterThanOrEqual(values[0]);
                break;
            case Operation.LessThan:
                where.LessThan(values[0]);
                break;
            case Operation.LessThanOrEqual:
                where.LessThanOrEqual(values[0]);
                break;
            case Operation.StartsWith:
                where.Like(values[0] + "%");
                break;
            case Operation.EndsWith:
                where.Like("%" + values[0]);
                break;
            case Operation.Contains:
                where.In(values);
                break;
            default: throw new NotImplementedException($"Operation '{operation}' not implemented");
        }
    }

    private static Operation GetOperation(ExpressionType expressionType) => expressionType switch
    {
        ExpressionType.Equal => Operation.Equal,
        ExpressionType.NotEqual => Operation.NotEqual,
        ExpressionType.GreaterThan => Operation.GreaterThan,
        ExpressionType.GreaterThanOrEqual => Operation.GreaterThanOrEqual,
        ExpressionType.LessThan => Operation.LessThan,
        ExpressionType.LessThanOrEqual => Operation.LessThanOrEqual,
        _ => throw new NotImplementedException($"Operation '{expressionType}' not implemented"),
    };

    private static Operation GetOperation(string operationName) => operationName switch
    {
        "Contains" => Operation.Contains,
        "StartsWith" => Operation.StartsWith,
        "EndsWith" => Operation.EndsWith,
        _ => throw new NotImplementedException($"Operation '{operationName}' not implemented"),
    };

    private enum Operation
    {
        Equal,
        EqualNull,
        NotEqual,
        NotEqualNull,
        GreaterThan,
        GreaterThanOrEqual,
        LessThan,
        LessThanOrEqual,
        StartsWith,
        EndsWith,
        Contains
    }

    private static object[] ConvertToList(object obj)
    {
        return obj switch
        {
            object[] arr => arr,
            IEnumerable<object> enumerable => enumerable.ToArray(),
            IEnumerable enumerable => enumerable.Cast<object>().ToArray(),
            _ => throw new ArgumentException("Object is not a list"),
        };
    }
}

================
File: src/DataLinq/Logging/DataLinqLoggingConfiguration.cs
================
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;

namespace DataLinq.Logging;

public sealed class DataLinqLoggingConfiguration(ILoggerFactory loggerFactory)
{
    public static DataLinqLoggingConfiguration NullConfiguration { get; } = new DataLinqLoggingConfiguration(NullLoggerFactory.Instance);

    public ILoggerFactory LoggerFactory { get; } = loggerFactory;
    public ILogger SqlCommandLogger { get; } = loggerFactory.CreateLogger("DataLinq.SqlCommand");
    public ILogger TransactionLogger { get; } = loggerFactory.CreateLogger("DataLinq.Transaction");
    public ILogger CacheLogger { get; } = loggerFactory.CreateLogger("DataLinq.Cache");
}

================
File: src/DataLinq/Logging/DataLinqLogLevel.cs
================
namespace DataLinq.Logging;

public enum DataLinqLogLevel
{
	Trace = 1,
	Debug = 2,
	Info = 3,
	Warn = 4,
	Error = 5,
	Fatal = 6,
}

================
File: src/DataLinq/Logging/EventIds.cs
================
namespace DataLinq.Logging;

internal static class EventIds
{
	// Sql
	public const int SqlCommand = 1000;

	// Cache
	public const int IndexCachePreload = 2000;
    public const int RowCachePreload = 2001;
    public const int LoadRowsFromCache = 2002;
    public const int LoadRowsFromDatabase = 2003;
}

================
File: src/DataLinq/Logging/Log.cs
================
using System;
using System.Data;
using System.Text;
using DataLinq.Metadata;
using Microsoft.Extensions.Logging;

namespace DataLinq.Logging;

public static partial class Log
{
    [LoggerMessage(EventIds.SqlCommand, LogLevel.Debug, "{sql}")]
    public static partial void Sql(ILogger logger, string sql);

    public static void SqlCommand(ILogger logger, IDbCommand command)
    {
        if(logger.IsEnabled(LogLevel.Debug))
            Sql(logger, command.FormatCommand());
    }

    [LoggerMessage(EventIds.IndexCachePreload, LogLevel.Debug, "Preloaded {rowsLoaded} keys to index cache: {index}")]
    public static partial void IndexCachePreload(ILogger logger, ColumnIndex index, int rowsLoaded);

    [LoggerMessage(EventIds.RowCachePreload, LogLevel.Debug, "Preloaded {rowsLoaded} rows to table cache: {table}")]
    public static partial void RowCachePreload(ILogger logger, TableDefinition table, int rowsLoaded);

    [LoggerMessage(EventIds.LoadRowsFromCache, LogLevel.Debug, "Fetched {rowsLoaded} rows from table cache: {table}")]
    public static partial void LoadRowsFromCache(ILogger logger, TableDefinition table, int rowsLoaded);

    [LoggerMessage(EventIds.LoadRowsFromDatabase, LogLevel.Debug, "Fetched {rowsLoaded} rows from database and added to table cache: {table}")]
    public static partial void LoadRowsFromDatabase(ILogger logger, TableDefinition table, int rowsLoaded);
}

public static class DbCommandExtensions
{
    public static string FormatCommand(this IDbCommand command)
    {
        var sb = new StringBuilder();
        sb.AppendLine(command.CommandText);

        if (command.Parameters.Count > 0)
        {
            sb.AppendLine("Parameters:");
            foreach (IDbDataParameter param in command.Parameters)
            {
                sb.AppendLine($"{param.ParameterName} = {ConvertParamValue(param)} (Type: {param.DbType})");
            }
        }

        if (command.Transaction != null)
        {
            sb.AppendLine("Transaction:");
            sb.AppendLine($"Isolation Level: {command.Transaction.IsolationLevel}");
        }

        return sb.ToString();

        string ConvertParamValue(IDbDataParameter param)
        {
            return param.Value switch
            {
                null => "NULL",
                DBNull _ => "NULL",
                byte[] byteArray => TryParseGuid(byteArray, out var guid) ? guid.ToString() : BitConverter.ToString(byteArray).Replace("-", " "),
                DateTime dateTime => dateTime.ToString("o"), // ISO 8601 format
                string str => Guid.TryParse(str, out var guid) ? guid.ToString() : $"\"{str}\"",
                _ => param.Value?.ToString() ?? "NULL",
            };
        }

        bool TryParseGuid(byte[] byteArray, out Guid guid)
        {
            // Assuming the byte array represents a GUID in a common format
            if (byteArray.Length == 16)
            {
                guid = new Guid(byteArray);
                return true;
            }

            guid = default;
            return false;
        }
    }
}

================
File: src/DataLinq/Metadata/MetadataFromTypeFactory.cs
================
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Reflection;
using DataLinq.Attributes;
using DataLinq.Core.Factories;
using DataLinq.Instances;

namespace DataLinq.Metadata;

public static class MetadataFromTypeFactory
{
    public static DatabaseDefinition ParseDatabaseFromDatabaseModel(Type type)
    {
        var database = new DatabaseDefinition(type.Name, csType: new CsTypeDeclaration(type));
        database.SetAttributes(type.GetCustomAttributes(false).Cast<Attribute>());
        database.ParseAttributes();
        database.SetTableModels(type
            .GetProperties(BindingFlags.Instance | BindingFlags.Public)
            .Select(GetTableType)
            .Select(x => database.ParseTableModel(x.type, x.csName)));

        MetadataFactory.ParseIndices(database);
        MetadataFactory.ParseRelations(database);

        return database;
    }

    private static TableModel ParseTableModel(this DatabaseDefinition database, Type type, string csPropertyName) =>
        new(csPropertyName, database, type.ParseModel());

    private static (string csName, Type type) GetTableType(this PropertyInfo property)
    {
        var type = property.PropertyType;

        if (type.GetGenericTypeDefinition() == typeof(DbRead<>))
            return (property.Name, type.GetGenericArguments()[0]);
        else
            throw new NotImplementedException();
    }

    private static ModelDefinition ParseModel(this Type type)
    {
        var model = new ModelDefinition(new CsTypeDeclaration(type));

        model.SetAttributes(type.GetCustomAttributes(false).Cast<Attribute>());

        model.SetInterfaces(type.GetInterfaces().Where(x => !IsModelInstanceInterface(x)).Select(x => new CsTypeDeclaration(x)));
        model.SetModelInstanceInterface(type.GetInterfaces().Where(IsModelInstanceInterface).Select(x => new CsTypeDeclaration(x)).FirstOrDefault());

        if (type.Namespace != null)
            model.SetUsings([new(type.Namespace)]);

        type
            .GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
            .Select(x => ParseProperty(x, model))
            .Where(x => x.Attributes.Any(x => x is ColumnAttribute || x is RelationAttribute))
            .Where(x => x.PropertyName != "EqualityContract")
            .ToList()
            .ForEach(model.AddProperty);

        model.SetUsings(model.ValueProperties.Values
            .Select(x => x.CsType.Namespace)
            .Distinct()
            .Where(x => x != null)
            .Select(name => (name!.StartsWith("System"), name))
            .OrderByDescending(x => x.Item1)
            .ThenBy(x => x.name)
            .Select(x => new ModelUsing(x.name)));

        model.SetImmutableType(FindType(type, $"{model.CsType.Namespace}.Immutable{model.CsType.Name}"));

        if (model.OriginalInterfaces.Any(x => x.Name.StartsWith("ITableModel")))
            model.SetMutableType(FindType(type, $"{model.CsType.Namespace}.Mutable{model.CsType.Name}"));

        return model;
    }

    private static bool IsModelInstanceInterface(Type type)
    {
        if (type.Namespace?.StartsWith("System") == true ||
            type.Namespace?.StartsWith("DataLinq.Instance") == true ||
            type.Namespace?.StartsWith("DataLinq.Interfaces") == true)
            return false;

        return type.GetInterfaces().Any(x => x.Name.StartsWith("IModelInstance"));
    }

    private static CsTypeDeclaration FindType(Type modelType, string name)
    {
        var type = modelType.Assembly.GetTypes().FirstOrDefault(x => x.FullName == name);

        return type == null
            ? throw new NotImplementedException($"Type '{name}' not found")
            : new CsTypeDeclaration(type);
    }

    private static PropertyDefinition ParseProperty(this PropertyInfo propertyInfo, ModelDefinition model)
    {
        var attributes = propertyInfo
                .GetCustomAttributes(false)
                .OfType<Attribute>()
                .ToList();

        var type = Nullable.GetUnderlyingType(propertyInfo.PropertyType) ?? propertyInfo.PropertyType;
        PropertyDefinition property = attributes.Any(attribute => attribute is RelationAttribute)
            ? new RelationProperty(propertyInfo.Name, new CsTypeDeclaration(type), model, attributes)
            : new ValueProperty(propertyInfo.Name, new CsTypeDeclaration(type), model, attributes);

        if (property is ValueProperty valueProp)
        {
            valueProp.SetCsNullable(propertyInfo.PropertyType.IsGenericType && propertyInfo.PropertyType.GetGenericTypeDefinition() == typeof(Nullable<>));

            if (property.CsType.Type?.IsEnum == true)
            {
                valueProp.SetCsSize(MetadataTypeConverter.CsTypeSize("enum"));

                var enumValueList = attributes.Any(attribute => attribute is EnumAttribute)
                    ? attributes.OfType<EnumAttribute>().Single().Values.Select((x, i) => (x, i)).ToList()
                    : new List<(string name, int value)>();

                var enumValues = Enum.GetValues(property.CsType.Type).Cast<int>().ToList();
                valueProp.SetEnumProperty(new EnumProperty(enumValueList, Enum.GetNames(property.CsType.Type).Select((x, i) => (x, enumValues[i])).ToList(), true));
            }
            else
                valueProp.SetCsSize(MetadataTypeConverter.CsTypeSize(property.CsType.Name));
        }

        return property;
    }
}

================
File: src/DataLinq/Metadata/PluginHook.cs
================
using System.Collections.Generic;
using DataLinq.Core.Factories;
using DataLinq.ErrorHandling;
using DataLinq.Interfaces;
using DataLinq.Query;
using Microsoft.Extensions.Logging;
using ThrowAway;

namespace DataLinq.Metadata;

public interface IDatabaseProviderCreator
{
    Database<T> GetDatabaseProvider<T>(string connectionString, string databaseName) where T : class, IDatabaseModel;
    bool IsDatabaseType(string typeName);
    IDatabaseProviderCreator UseLoggerFactory(ILoggerFactory? loggerFactory);
}

public interface ISqlFromMetadataFactory
{
    Option<Sql, IDLOptionFailure> GetCreateTables(DatabaseDefinition metadata, bool foreignKeyRestrict);
    Option<int, IDLOptionFailure> CreateDatabase(Sql sql, string databaseName, string connectionString, bool foreignKeyRestrict);
}

public interface IMetadataFromDatabaseFactoryCreator
{
    IMetadataFromSqlFactory GetMetadataFromSqlFactory(MetadataFromDatabaseFactoryOptions options);
}

public interface IMetadataFromSqlFactory
{
    Option<DatabaseDefinition> ParseDatabase(string name, string csTypeName, string csNamespace, string dbName, string connectionString);
}

public static class PluginHook
{
    public static Dictionary<DatabaseType, IDatabaseProviderCreator> DatabaseProviders = new();
    public static Dictionary<DatabaseType, ISqlFromMetadataFactory> SqlFromMetadataFactories = new();
    public static Dictionary<DatabaseType, IMetadataFromDatabaseFactoryCreator> MetadataFromSqlFactories = new();

    public static Option<int, IDLOptionFailure> CreateDatabaseFromSql(this DatabaseType type, Sql sql, string databaseOrFile, string connectionString, bool foreignKeyRestrict)
    {
        if (!MetadataFromSqlFactories.ContainsKey(type))
            return new DLOptionFailure<string>($"No creator for {type}");

        return SqlFromMetadataFactories[type].CreateDatabase(sql, databaseOrFile, connectionString, foreignKeyRestrict);
    }

    public static Option<int, IDLOptionFailure> CreateDatabaseFromMetadata(this DatabaseType type, DatabaseDefinition metadata, string databaseNameOrFile, string connectionString, bool foreignKeyRestrict)
    {
        Sql sql = GenerateSql(type, metadata, foreignKeyRestrict);
        return CreateDatabaseFromSql(type, sql, databaseNameOrFile, connectionString, foreignKeyRestrict);
    }

    public static Option<Sql, IDLOptionFailure> GenerateSql(this DatabaseType type, DatabaseDefinition metadata, bool foreignKeyRestrict)
    {
        if (!SqlFromMetadataFactories.ContainsKey(type))
            return new DLOptionFailure<string>($"No handler for {type}");

        return SqlFromMetadataFactories[type].GetCreateTables(metadata, foreignKeyRestrict);
    }
}

================
File: src/DataLinq/Metadata/SqlGeneration.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Extensions.Helpers;
using DataLinq.Query;

namespace DataLinq.Metadata;


public class SqlGeneration
{
    public SqlGeneration(int indentationSpaces = 4, char quoteChar = '`', string generatedText = "")
    {
        IndentationSpaces = indentationSpaces;
        QuoteCharacter = quoteChar;
        if (!string.IsNullOrEmpty(generatedText))
            sql.AddText(generatedText.Replace("%datetime%", DateTime.Now.ToString()));
    }

    // Sort tables when generating SQL code to ensure that tables with foreign key columns are created after the candidate key tables.
    public List<TableDefinition> SortTablesByForeignKeys(List<TableDefinition> tables)
    {
        for (var i = 0; i < tables.Count; i++)
        {
            var table = tables[i];
            foreach (var column in table.Columns.Where(x => x.ForeignKey))
            {
                foreach (var fk in column.ColumnIndices.Where(x => x.Characteristic == Attributes.IndexCharacteristic.ForeignKey).SelectMany(x => x.RelationParts))
                {
                    var otherTable = fk.GetOtherSide().ColumnIndex.Table;

                    if (otherTable == null)
                        continue;

                    var fkIndex = tables.IndexOf(otherTable);
                    var fkTable = tables[fkIndex];
                    if (fkIndex > i)
                    {
                        tables[i] = fkTable;
                        tables[fkIndex] = table;
                        return SortTablesByForeignKeys(tables);
                    }
                }
            }
        }
        return tables;
    }

    public List<ViewDefinition> SortViewsByForeignKeys(List<ViewDefinition> views)
    {
        for (var i = 0; i < views.Count; i++)
        {
            var view = views[i];

            foreach (var fkView in views.Where(x => x.Definition?.Contains(view.DbName) == true))
            {
                var fkIndex = views.IndexOf(fkView);
                //var fkTable = views[fkIndex];
                if (fkIndex < i)
                {
                    views[i] = fkView;
                    views[fkIndex] = view;
                    return SortViewsByForeignKeys(views);
                }
            }

        }
        return views;
    }

    public int IndentationSpaces { get; set; } = 4;
    public char QuoteCharacter { get; set; } = '`';

    public string Buffer = "";
    List<string> CreateRows { get; set; } = new();

    public Sql sql = new();
    public SqlGeneration NewRow() { if (Buffer != "") CreateRows.Add(Buffer); Buffer = ""; return this; }
    public SqlGeneration Add(string s) { Buffer += s; return this; }
    public SqlGeneration NewLine()
        => Add("\n");

    public SqlGeneration ColumnName(string column) => Add(QuotedString(column));
    public string QuotedString(string s)
        => $"{QuoteCharacter}{s}{QuoteCharacter}";
    public SqlGeneration Space()
        => Add(" ");
    public string QuotedParenthesis(string s)
        => $"({QuotedString(s)})";
    public string Parenthesis(string s)
        => $"({s})";
    public string ParenthesisList(string[] columns) =>
        $"{Parenthesis(string.Join(", ", columns.Select(key => QuotedString(key))))}";
    public string ValueWithSpace(string? s)
        => string.IsNullOrWhiteSpace(s) ? " " : $" {s} ";


    //public SqlGeneration CreateDatabase(string databaseName)
    //{
    //    sql.AddText($"CREATE DATABASE IF NOT EXISTS {QuoteCharacter}{databaseName}{QuoteCharacter}; \n");
    //    NewRow();
    //    sql.AddText($"USE {databaseName};\n");

    //    sql.HasCreateDatabase = true;
    //    return this;
    //}

    public SqlGeneration CreateTable(string tableName, Action<SqlGeneration> func)
    {
        sql.AddText($"CREATE TABLE IF NOT EXISTS {QuoteCharacter}{tableName}{QuoteCharacter} (\n");
        func(this);
        NewRow();
        sql.AddText(string.Join(",\n", CreateRows.ToArray()));
        CreateRows.Clear();
        sql.AddText("\n);\n\n");
        return this;
    }
    public SqlGeneration CreateView(string viewName, string definition)
    {
        sql.AddText($"CREATE VIEW IF NOT EXISTS {QuoteCharacter}{viewName}{QuoteCharacter}\n");
        sql.AddText($"AS {definition};");
        sql.AddText("\n\n");
        return this;
    }
    public SqlGeneration Indent()
        => Add(new string(' ', IndentationSpaces));
    public SqlGeneration NewLineComma()
        => Add(",").NewLine();
    public SqlGeneration DefaultValue(string defaultValue) => Space().Add($"DEFAULT {defaultValue}");
    public SqlGeneration Nullable(bool nullable) => Space().Add(nullable ? "NULL" : "NOT NULL");
    public SqlGeneration Autoincrement(bool inc) => inc ? Space().Add("AUTO_INCREMENT") : this;
    public SqlGeneration Type(string type, string columnName, int longestColumnName) => Add(Align(longestColumnName, columnName) + type);
    public SqlGeneration TypeLength(long? length, int? decimals) => length.HasValue
        ? decimals.HasValue
            ? Add($"({length},{decimals})")
            : Add($"({length})")
        : this;
    public SqlGeneration EnumValues(IEnumerable<string> values) => Add($"({string.Join(",", values.Select(x => $"'{x}'"))})");
    public SqlGeneration Unsigned(bool? signed) => signed.HasValue && !signed.Value ? Space().Add("UNSIGNED") : this;
    public string Align(int longest, string text) => new string(' ', longest - text.Length);

    public SqlGeneration Index(string name, string? characteristic, string type, params string[] columns)
        => NewRow().Indent().Add($"{(string.IsNullOrWhiteSpace(characteristic) ? "" : $"{characteristic} ")}INDEX {QuotedString(name)} {ParenthesisList(columns)} USING {type}");
    public SqlGeneration PrimaryKey(params string[] columns)
        => NewRow().Indent().Add($"PRIMARY KEY {ParenthesisList(columns)}");
    public virtual SqlGeneration UniqueKey(string name, params string[] columns)
        => NewRow().Indent().Add($"UNIQUE KEY {QuotedString(name)} {ParenthesisList(columns)}");
    public SqlGeneration ForeignKey(RelationPart relation, bool restrict)
        => ForeignKey(
            relation.Relation.ConstraintName == relation.ColumnIndex.Columns.First().DbName ? null : relation.Relation.ConstraintName, 
            relation.ColumnIndex.Columns.Select(x=> x.DbName).ToJoinedString(", "), 
            relation.Relation.CandidateKey.ColumnIndex.Table.DbName, 
            relation.Relation.CandidateKey.ColumnIndex.Columns.Select(x => x.DbName).ToJoinedString(", "), 
            restrict);
    public SqlGeneration ForeignKey(string? constraintName, string from, string table, string to, bool restrict)
        => NewRow().Indent().Add($"{(string.IsNullOrWhiteSpace(constraintName) ? "" : $"CONSTRAINT {QuotedString(constraintName)} ")}FOREIGN KEY {QuotedParenthesis(from)} REFERENCES {QuotedString(table)} {QuotedParenthesis(to)} {OnUpdateDelete(restrict)}");
    public string OnUpdateDelete(bool restrict)
        => restrict ? "ON UPDATE RESTRICT ON DELETE RESTRICT" : "ON UPDATE NO ACTION ON DELETE NO ACTION";
}

================
File: src/DataLinq/Mutation/DataSourceAccess.cs
================
using System.Collections.Generic;
using System.Data;
using DataLinq.Interfaces;

namespace DataLinq.Mutation;

public abstract class DataSourceAccess : IDataSourceAccess
{

    /// <summary>
    /// Gets the database provider.
    /// </summary>
    public IDatabaseProvider Provider { get; }

    /// <summary>
    /// Gets or sets the database transaction.
    /// </summary>
    public abstract DatabaseAccess DatabaseAccess { get; }

    protected DataSourceAccess(IDatabaseProvider provider)
    {
        Provider = provider;
    }

    /// <summary>
    /// Gets models from a query.
    /// </summary>
    /// <typeparam name="T">The type of the model.</typeparam>
    /// <param name="query">The query to execute.</param>
    /// <returns>The models returned by the query.</returns>
    public abstract IEnumerable<T> GetFromQuery<T>(string query) where T : IModel;

    /// <summary>
    /// Gets models from a command.
    /// </summary>
    /// <typeparam name="T">The type of the model.</typeparam>
    /// <param name="dbCommand">The command to execute.</param>
    /// <returns>The models returned by the command.</returns>
    public abstract IEnumerable<T> GetFromCommand<T>(IDbCommand dbCommand) where T : IModel;
}

================
File: src/DataLinq/Mutation/History.cs
================
using System.Collections.Generic;

namespace DataLinq.Mutation;

public class History
{
    public List<StateChange> Changes { get; }

    public void AddChanges(params StateChange[] changes)
    {
        Changes.AddRange(changes);
    }
}

================
File: src/DataLinq/Mutation/ReadOnlyAccess.cs
================
using System.Collections.Generic;
using System.Data;
using System.Linq;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Metadata;
using DataLinq.Query;

namespace DataLinq.Mutation;

public class ReadOnlyAccess : DataSourceAccess
{
    public override DatabaseAccess DatabaseAccess => Provider.DatabaseAccess;

    public ReadOnlyAccess(IDatabaseProvider provider) : base(provider)
    {
    }

    //private T GetModelFromCache<T>(T model) where T : IModel
    //{
    //    var metadata = model.Metadata();
    //    var keys = model.PrimaryKeys(metadata);

    //    return (T)Provider.GetTableCache(metadata.Table).GetRow(keys, this);
    //}

    /// <summary>
    /// Gets models from a query.
    /// </summary>
    /// <typeparam name="T">The type of the model.</typeparam>
    /// <param name="query">The query to execute.</param>
    /// <returns>The models returned by the query.</returns>
    public override IEnumerable<T> GetFromQuery<T>(string query)
    {
        var table = Provider.Metadata.TableModels.Single(x => x.Model.CsType.Type == typeof(T)).Table;

        return Provider
            .DatabaseAccess
            .ReadReader(query)
            .Select(x => new RowData(x, table, table.Columns))
            .Select(x => InstanceFactory.NewImmutableRow<T>(x, Provider, this));
    }

    /// <summary>
    /// Gets models from a command.
    /// </summary>
    /// <typeparam name="T">The type of the model.</typeparam>
    /// <param name="dbCommand">The command to execute.</param>
    /// <returns>The models returned by the command.</returns>
    public override IEnumerable<T> GetFromCommand<T>(IDbCommand dbCommand)
    {
        var table = Provider.Metadata.TableModels.Single(x => x.Model.CsType.Type == typeof(T)).Table;

        return Provider
            .DatabaseAccess
            .ReadReader(dbCommand)
            .Select(x => new RowData(x, table, table.Columns))
            .Select(x => InstanceFactory.NewImmutableRow<T>(x, Provider, this));
    }
}


/// <summary>
/// Represents a database transaction.
/// </summary>
/// <typeparam name="T">The type of the database model.</typeparam>
public class ReadOnlyAccess<T> : ReadOnlyAccess where T : class, IDatabaseModel
{
    /// <summary>
    /// Gets the database for the transaction.
    /// </summary>
    protected T Database { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="Transaction{T}"/> class.
    /// </summary>
    /// <param name="databaseProvider">The database provider.</param>
    public ReadOnlyAccess(DatabaseProvider<T> databaseProvider) : base(databaseProvider)
    {
        Database = InstanceFactory.NewDatabase<T>(this);
    }

    /// <summary>
    /// Gets the schema.
    /// </summary>
    /// <returns>The schema.</returns>
    public T Query() => Database;

    /// <summary>
    /// Creates a new SQL query from the specified table name.
    /// </summary>
    /// <param name="tableName">The name of the table.</param>
    /// <returns>The SQL query.</returns>
    public SqlQuery From(string tableName)
    {
        var table = Provider.Metadata.TableModels.Single(x => x.Table.DbName == tableName).Table;

        return new SqlQuery(table, this);
    }

    /// <summary>
    /// Creates a new SQL query from the specified table metadata.
    /// </summary>
    /// <param name="table">The table metadata.</param>
    /// <returns>The SQL query.</returns>
    public SqlQuery From(TableDefinition table)
    {
        return new SqlQuery(table, this);
    }

    /// <summary>
    /// Creates a new SQL query from the specified model type.
    /// </summary>
    /// <typeparam name="V">The type of the model.</typeparam>
    /// <returns>The SQL query.</returns>
    public SqlQuery<V> From<V>() where V : IModel
    {
        return new SqlQuery<V>(this);
    }
}

================
File: src/DataLinq/Mutation/State.cs
================
using System;
using System.Collections.Generic;
using DataLinq.Cache;
using DataLinq.Logging;

namespace DataLinq.Mutation;

/// <summary>
/// Represents the state of the database, including history and cache. It provides methods to apply changes to the state,
/// manage the transactions in the cache, and handle cleanup of resources.
/// </summary>
public class State : IDisposable
{
    private readonly DataLinqLoggingConfiguration loggingConfiguration;

    /// <summary>
    /// Gets or sets the history of changes made to the database.
    /// </summary>
    public History History { get; set; }

    /// <summary>
    /// Gets or sets the cache associated with the database state.
    /// </summary>
    public DatabaseCache Cache { get; set; }

    /// <summary>
    /// Gets the database provider associated with the state.
    /// </summary>
    public DatabaseProvider Database { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="State"/> class with the specified database provider.
    /// </summary>
    /// <param name="database">The database provider to associate with the state.</param>
    public State(DatabaseProvider database, DataLinqLoggingConfiguration loggingConfiguration)
    {
        this.Database = database;
        this.loggingConfiguration = loggingConfiguration;
        this.Cache = new DatabaseCache(database, loggingConfiguration);
        this.History = new History();
    }

    /// <summary>
    /// Applies a collection of state changes to the database using an optional transaction context.
    /// </summary>
    /// <param name="changes">The state changes to apply.</param>
    /// <param name="transaction">The transaction to associate with the changes, if any.</param>
    public void ApplyChanges(IEnumerable<StateChange> changes, Transaction? transaction = null)
    {
        Cache.ApplyChanges(changes, transaction);
    }

    /// <summary>
    /// Removes a transaction from the cache, effectively rolling back any changes associated with the transaction.
    /// </summary>
    /// <param name="transaction">The transaction to remove from the cache.</param>
    public void RemoveTransactionFromCache(Transaction transaction)
    {
        Cache.RemoveTransaction(transaction);
    }

    /// <summary>
    /// Clears all entries from the cache.
    /// </summary>
    public void ClearCache()
    {
        Cache.ClearCache();
    }

    /// <summary>
    /// Releases all resources used by the cache.
    /// </summary>
    public void Dispose()
    {
        Cache.Dispose();
    }
}

================
File: src/DataLinq/Mutation/StateChange.cs
================
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using DataLinq.Instances;
using DataLinq.Metadata;
using DataLinq.Query;

namespace DataLinq.Mutation;

/// <summary>
/// Represents a change of state to be applied to a model within a transaction.
/// </summary>
public class StateChange
{
    /// <summary>
    /// Gets the type of change that will be applied to the model.
    /// </summary>
    public TransactionChangeType Type { get; }

    /// <summary>
    /// Gets the model that the change will be applied to.
    /// </summary>
    public IModelInstance Model { get; }

    /// <summary>
    /// Gets the table metadata associated with the model.
    /// </summary>
    public TableDefinition Table { get; }

    /// <summary>
    /// Gets the primary keys for the model.
    /// </summary>
    public IKey PrimaryKeys { get; }

    /// <summary>
    /// Determines if the model has an auto-incrementing primary key.
    /// </summary>
    public bool HasAutoIncrement =>
        Table.PrimaryKeyColumns.Any(x => x.AutoIncrement);

    /// <summary>
    /// Initializes a new instance of the <see cref="StateChange"/> class.
    /// </summary>
    /// <param name="model">The model to apply the change to.</param>
    /// <param name="table">The table metadata for the model.</param>
    /// <param name="type">The type of change to be applied.</param>
    public StateChange(IModelInstance model, TableDefinition table, TransactionChangeType type)
    {
        ArgumentNullException.ThrowIfNull(model);
        ArgumentNullException.ThrowIfNull(table);

        if (table.Type == TableType.View)
            throw new InvalidOperationException("Cannot change a view.");

        if (type == TransactionChangeType.Update && model is not IMutableInstance)
            throw new InvalidOperationException("Cannot update a model that is not mutable.");

        if (type == TransactionChangeType.Insert && model is not IMutableInstance)
            throw new InvalidOperationException("Cannot insert a model that is not mutable.");

        if (model is IMutableInstance mutable)
        {
            if (type == TransactionChangeType.Delete && mutable.IsNew())
                throw new InvalidOperationException("Cannot delete a new model.");

            if (mutable.IsDeleted())
                throw new InvalidOperationException("Cannot change a deleted model.");
        }


        Model = model;
        Table = table;
        Type = type;

        PrimaryKeys = model.PrimaryKeys();
    }

    public IEnumerable<KeyValuePair<ColumnDefinition, object?>> GetChanges() =>
        Model is IMutableInstance mutable
        ? mutable.GetChanges()
        : [];

    /// <summary>
    /// Executes the query associated with the state change on the given transaction.
    /// </summary>
    /// <param name="transaction">The transaction to execute the query on.</param>
    public void ExecuteQuery(Transaction transaction)
    {
        if (Type == TransactionChangeType.Insert && HasAutoIncrement && !Model.HasPrimaryKeysSet())
        {
            var newId = transaction.DatabaseAccess.ExecuteScalar(GetDbCommand(transaction));

            if (Model is IMutableInstance mutable)
            {
                var autoIncrement = Table.PrimaryKeyColumns.FirstOrDefault(x => x.AutoIncrement);

                if (autoIncrement != null)
                    mutable[autoIncrement] = newId;
            }
        }
        else
            transaction.DatabaseAccess.ExecuteNonQuery(GetDbCommand(transaction));
    }

    /// <summary>
    /// Creates a database command for the state change to be executed within the transaction.
    /// </summary>
    /// <param name="transaction">The transaction the command is for.</param>
    /// <returns>The database command to execute.</returns>
    public IDbCommand GetDbCommand(Transaction transaction) =>
        transaction.Provider.ToDbCommand(GetQuery(transaction));

    /// <summary>
    /// Generates the query for the state change.
    /// </summary>
    /// <param name="transaction">The transaction the query is for.</param>
    /// <returns>The query representing the state change.</returns>
    public IQuery GetQuery(Transaction transaction)
    {
        var query = new SqlQuery(Table, transaction);
        var writer = transaction.Provider.GetWriter();

        return Type switch
        {
            TransactionChangeType.Insert => BuildInsertQuery(query, writer),
            TransactionChangeType.Update => BuildUpdateQuery(query, writer),
            TransactionChangeType.Delete => BuildDeleteQuery(query, writer),
            _ => throw new NotImplementedException("The transaction change type is not implemented."),
        };
    }

    private IQuery BuildInsertQuery(SqlQuery query, IDataLinqDataWriter writer)
    {
        foreach (var column in Table.Columns)
        {
            var val = writer.ConvertColumnValue(column, Model[column]);
            query.Set(column.DbName, val);
        }

        if (HasAutoIncrement)
            query.AddLastIdQuery();

        return query.InsertQuery();
    }

    private IQuery BuildUpdateQuery(SqlQuery query, IDataLinqDataWriter writer)
    {
        foreach (var column in Table.PrimaryKeyColumns)
            query.Where(column.DbName).EqualTo(writer.ConvertColumnValue(column, Model[column]));

        foreach (var change in ((IMutableInstance)Model).GetChanges())
            query.Set(change.Key.DbName, writer.ConvertColumnValue(change.Key, change.Value));

        return query.UpdateQuery();
    }

    private IQuery BuildDeleteQuery(SqlQuery query, IDataLinqDataWriter writer)
    {
        foreach (var column in Table.PrimaryKeyColumns)
            query.Where(column.DbName).EqualTo(writer.ConvertColumnValue(column, Model[column]));

        return query.DeleteQuery();
    }
}

================
File: src/DataLinq/Mutation/Transaction.cs
================
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Threading;
using CommunityToolkit.HighPerformance;
using DataLinq.Exceptions;
using DataLinq.Instances;
using DataLinq.Interfaces;
using DataLinq.Metadata;
using DataLinq.Query;

namespace DataLinq.Mutation;

/// <summary>
/// Enumerates the types of transactions.
/// </summary>
public enum TransactionType
{
    /// <summary>
    /// Transaction that allows both read and write operations.
    /// </summary>
    ReadAndWrite,
    /// <summary>
    /// Transaction that only allows read operations.
    /// </summary>
    ReadOnly,
    /// <summary>
    /// Transaction that only allows write operations.
    /// </summary>
    WriteOnly
}

/// <summary>
/// Enumerates the types of changes that can be made to a transaction.
/// </summary>
public enum TransactionChangeType
{
    /// <summary>
    /// Insert a new row into the database.
    /// </summary>
    Insert,
    /// <summary>
    /// Update an existing row in the database.
    /// </summary>
    Update,
    /// <summary>
    /// Delete an existing row from the database.
    /// </summary>
    Delete
}

/// <summary>
/// Provides data for the <see cref="Transaction.OnStatusChanged"/> event.
/// </summary>
public class TransactionStatusChangeEventArgs : EventArgs
{
    /// <summary>
    /// Initializes a new instance of the <see cref="TransactionStatusChangeEventArgs"/> class.
    /// </summary>
    /// <param name="transaction">The transaction that raised the event.</param>
    /// <param name="status">The new status of the transaction.</param>
    public TransactionStatusChangeEventArgs(Transaction transaction, DatabaseTransactionStatus status)
    {
        Transaction = transaction;
        Status = status;
    }

    /// <summary>
    /// Gets the transaction that raised the event.
    /// </summary>
    public Transaction Transaction { get; }

    /// <summary>
    /// Gets the new status of the transaction.
    /// </summary>
    public DatabaseTransactionStatus Status { get; }
}

/// <summary>
/// Represents a database transaction.
/// </summary>
public class Transaction : DataSourceAccess, IDisposable, IEquatable<Transaction>
{
    private static uint transactionCount = 0;

    /// <summary>
    /// Gets the ID of the transaction.
    /// </summary>
    public uint TransactionID { get; }

    /// <summary>
    /// Gets the list of state changes.
    /// </summary>
    public List<StateChange> Changes { get; } = new List<StateChange>();

    /// <summary>
    /// Gets the type of the transaction.
    /// </summary>
    public TransactionType Type { get; protected set; }

    /// <summary>
    /// Gets the status of the database transaction.
    /// </summary>
    public DatabaseTransactionStatus Status => DatabaseAccess.Status;

    public override DatabaseTransaction DatabaseAccess { get; }

    /// <summary>
    /// Occurs when the status of the transaction changes.
    /// </summary>
    public event EventHandler<TransactionStatusChangeEventArgs>? OnStatusChanged;

    /// <summary>
    /// Initializes a new instance of the <see cref="Transaction"/> class.
    /// </summary>
    /// <param name="databaseProvider">The database provider.</param>
    /// <param name="type">The type of the transaction.</param>
    public Transaction(IDatabaseProvider databaseProvider, TransactionType type) : base(databaseProvider)
    {
        //Provider = databaseProvider;
        DatabaseAccess = databaseProvider.GetNewDatabaseTransaction(type);
        DatabaseAccess.OnStatusChanged += (_, args) => OnStatusChanged?.Invoke(this, new TransactionStatusChangeEventArgs(this, args.Status));
        Type = type;

        TransactionID = Interlocked.Increment(ref transactionCount);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="Transaction"/> class.
    /// </summary>
    /// <param name="databaseProvider">The database provider.</param>
    /// <param name="dbTransaction">The database transaction.</param>
    /// <param name="type">The type of the transaction.</param>
    public Transaction(IDatabaseProvider databaseProvider, IDbTransaction dbTransaction, TransactionType type) : base(databaseProvider)
    {
        //Provider = databaseProvider;
        DatabaseAccess = databaseProvider.AttachDatabaseTransaction(dbTransaction, type);
        DatabaseAccess.OnStatusChanged += (_, args) => OnStatusChanged?.Invoke(this, new TransactionStatusChangeEventArgs(this, args.Status));
        Type = type;

        TransactionID = Interlocked.Increment(ref transactionCount);
    }

    /// <summary>
    /// Inserts a new row into the database.
    /// </summary>
    /// <typeparam name="T">The type of the model.</typeparam>
    /// <param name="model">The model to insert.</param>
    /// <returns>The inserted model.</returns>
    public T Insert<T>(Mutable<T> model) where T : IImmutableInstance
    {
        CheckIfTransactionIsValid();

        if (model == null)
            throw new ArgumentException("Model argument has null value");

        if (!model.IsNew())
            throw new ArgumentException("Model is not a new row, unable to insert");

        AddAndExecute(model, TransactionChangeType.Insert);

        var immutable = GetModelFromCache(model) ?? throw new ModelLoadFailureException(model.PrimaryKeys());
        model.Reset(immutable);

        return immutable;
    }

    /// <summary>
    /// Inserts multiple new rows into the database.
    /// </summary>
    /// <typeparam name="T">The type of the model.</typeparam>
    /// <param name="models">The models to insert.</param>
    /// <returns>The inserted models.</returns>
    public List<T> Insert<T>(IEnumerable<Mutable<T>> models) where T : IImmutableInstance
    {
        return models
            .Select(Insert)
            .ToList();
    }

    /// <summary>
    /// Updates an existing row in the database.
    /// </summary>
    /// <typeparam name="T">The type of the model.</typeparam>
    /// <param name="model">The model to update.</param>
    /// <returns>The updated model.</returns>
    public T Update<T>(Mutable<T> model) where T : IImmutableInstance
    {
        CheckIfTransactionIsValid();

        if (model == null)
            throw new ArgumentException("Model argument has null value");

        if (model.IsNew())
            throw new ArgumentException("Model is a new row, unable to update");

        // If there are no changes to save, skip saving and return the model from the cache directly.
        if (!model.GetChanges().Any())
            return GetModelFromCache(model) ?? throw new ModelLoadFailureException(model.PrimaryKeys());

        AddAndExecute(model, TransactionChangeType.Update);

        var immutable = GetModelFromCache(model) ?? throw new ModelLoadFailureException(model.PrimaryKeys());
        model.Reset(immutable);

        return immutable;
    }

    /// <summary>
    /// Updates an existing row in the database with the specified changes.
    /// </summary>
    /// <typeparam name="T">The type of the model.</typeparam>
    /// <param name="model">The model to update.</param>
    /// <param name="changes">The changes to apply to the model.</param>
    /// <returns>The updated model.</returns>
    public T Update<T>(T model, Action<Mutable<T>> changes) where T : IImmutableInstance
    {
        var mut = new Mutable<T>(model);
        changes(mut);

        return Update(mut);
    }

    /// <summary>
    /// Inserts a new row into the database or updates an existing row if it already exists.
    /// </summary>
    /// <typeparam name="T">The type of the model.</typeparam>
    /// <param name="model">The model to insert or update.</param>
    /// <returns>The inserted or updated model.</returns>
    public T Save<T>(Mutable<T> model) where T : IImmutableInstance
    {
        if (model == null)
            throw new ArgumentException("Model argument has null value");

        if (model.IsNew())
            return Insert(model);
        else
            return Update(model);
    }

    /// <summary>
    /// Inserts a new row into the database or updates an existing row if it already exists with the specified changes.
    /// </summary>
    /// <typeparam name="T">The type of the model.</typeparam>
    /// <param name="model">The model to insert or update.</param>
    /// <param name="changes">The changes to apply to the model.</param>
    /// <returns>The inserted or updated model.</returns>
    public T Save<T>(T model, Action<Mutable<T>> changes) where T : IImmutableInstance
    {
        var mut = model == null
            ? new Mutable<T>()
            : new Mutable<T>(model);

        changes(mut);

        return Save(mut);
    }

    /// <summary>
    /// Inserts a new row into the database or updates an existing row if it already exists with the specified changes.
    /// </summary>
    /// <typeparam name="T">The type of the model.</typeparam>
    /// <param name="model">The model to insert or update.</param>
    /// <param name="changes">The changes to apply to the model.</param>
    /// <returns>The inserted or updated model.</returns>
    public T Save<T>(Mutable<T> model, Action<Mutable<T>> changes) where T : IImmutableInstance
    {
        var mut = model ?? new Mutable<T>();

        changes(mut);

        return Save(mut);
    }

    /// <summary>
    /// Deletes an existing row from the database.
    /// </summary>
    /// <param name="model">The model to delete.</param>
    public void Delete(IModelInstance model)
    {
        CheckIfTransactionIsValid();

        if (model == null)
            throw new ArgumentException("Model argument has null value");

        AddAndExecute(model, TransactionChangeType.Delete);

        if (model is IMutableInstance mutable)
            mutable.SetDeleted();
    }

    /// <summary>
    /// Gets models from a query.
    /// </summary>
    /// <typeparam name="T">The type of the model.</typeparam>
    /// <param name="query">The query to execute.</param>
    /// <returns>The models returned by the query.</returns>
    public override IEnumerable<T> GetFromQuery<T>(string query)
    {
        var table = Provider.Metadata.TableModels.Single(x => x.Model.CsType.Type == typeof(T)).Table;

        return DatabaseAccess
            .ReadReader(query)
            .Select(x => new RowData(x, table, table.Columns.AsSpan()))
            .Select(x => InstanceFactory.NewImmutableRow<T>(x, Provider, this));
    }

    /// <summary>
    /// Gets models from a command.
    /// </summary>
    /// <typeparam name="T">The type of the model.</typeparam>
    /// <param name="dbCommand">The command to execute.</param>
    /// <returns>The models returned by the command.</returns>
    public override IEnumerable<T> GetFromCommand<T>(IDbCommand dbCommand)
    {
        var table = Provider.Metadata.TableModels.Single(x => x.Model.CsType.Type == typeof(T)).Table;

        return DatabaseAccess
            .ReadReader(dbCommand)
            .Select(x => new RowData(x, table, table.Columns.AsSpan()))
            .Select(x => InstanceFactory.NewImmutableRow<T>(x, Provider, this));
    }

    private void AddAndExecute(IModelInstance model, TransactionChangeType type)
    {
        var table = model.Metadata().Table;

        AddAndExecute(new StateChange(model, table, type));
    }

    private void AddAndExecute(params StateChange[] changes)
    {
        Changes.AddRange(changes);

        foreach (var change in changes)
            change.ExecuteQuery(this);

        Provider.State.ApplyChanges(changes, this);
    }

    /// <summary>
    /// Commits the transaction.
    /// </summary>
    public void Commit()
    {
        CheckIfTransactionIsValid();

        DatabaseAccess.Commit();

        Provider.State.ApplyChanges(Changes);
        Provider.State.RemoveTransactionFromCache(this);
    }

    /// <summary>
    /// Rolls back the transaction.
    /// </summary>
    public void Rollback()
    {
        CheckIfTransactionIsValid();

        DatabaseAccess.Rollback();
        Provider.State.RemoveTransactionFromCache(this);
    }

    private T? GetModelFromCache<T>(Mutable<T> model) where T : IImmutableInstance
    {
        var metadata = model.Metadata();
        var keys = model.PrimaryKeys();

        return (T?)Provider.GetTableCache(metadata.Table).GetRow(keys, this);
    }

    private void CheckIfTransactionIsValid()
    {
        if (Type == TransactionType.ReadOnly)
            return;

        if (Status == DatabaseTransactionStatus.Committed)
            throw new Exception("Transaction is already committed");

        if (Status == DatabaseTransactionStatus.RolledBack)
            throw new Exception("Transaction is rolled back");
    }

    /// <summary>
    /// Disposes of the transaction.
    /// </summary>
    public void Dispose()
    {
        Provider.State.RemoveTransactionFromCache(this);
        DatabaseAccess.Dispose();
    }

    /// <summary>
    /// Determines whether the specified object is equal to the current object.
    /// </summary>
    /// <param name="other">The object to compare with the current object.</param>
    /// <returns>true if the specified object is equal to the current object; otherwise, false.</returns>
    public bool Equals(Transaction? other)
    {
        if (ReferenceEquals(null, other))
            return false;
        if (ReferenceEquals(this, other))
            return true;

        return TransactionID.Equals(other.TransactionID);
    }

    /// <summary>
    /// Determines whether the specified object is equal to the current object.
    /// </summary>
    /// <param name="obj">The object to compare with the current object.</param>
    /// <returns>true if the specified object is equal to the current object; otherwise, false.</returns>
    public override bool Equals(object? obj)
    {
        if (ReferenceEquals(null, obj))
            return false;
        if (ReferenceEquals(this, obj))
            return true;
        if (obj.GetType() != typeof(Transaction))
            return false;

        return TransactionID.Equals(((Transaction)obj).TransactionID);
    }

    /// <summary>
    /// Serves as the default hash function.
    /// </summary>
    /// <returns>A hash code for the current object.</returns>
    public override int GetHashCode()
    {
        return TransactionID.GetHashCode();
    }

    /// <summary>
    /// Returns a string that represents the current object.
    /// </summary>
    /// <returns>A string that represents the current object.</returns>
    public override string ToString()
    {
        return $"Transaction with ID '{TransactionID}': {Type}";
    }
}

/// <summary>
/// Represents a database transaction.
/// </summary>
/// <typeparam name="T">The type of the database model.</typeparam>
public class Transaction<T> : Transaction where T : class, IDatabaseModel
{
    /// <summary>
    /// Gets the database for the transaction.
    /// </summary>
    protected T Database { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="Transaction{T}"/> class.
    /// </summary>
    /// <param name="databaseProvider">The database provider.</param>
    /// <param name="type">The type of the transaction.</param>
    public Transaction(DatabaseProvider<T> databaseProvider, TransactionType type) : base(databaseProvider, type)
    {
        Database = InstanceFactory.NewDatabase<T>(this);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="Transaction{T}"/> class.
    /// </summary>
    /// <param name="databaseProvider">The database provider.</param>
    /// <param name="dbTransaction">The database transaction.</param>
    /// <param name="type">The type of the transaction.</param>
    public Transaction(DatabaseProvider<T> databaseProvider, IDbTransaction dbTransaction, TransactionType type) : base(databaseProvider, dbTransaction, type)
    {
        Database = InstanceFactory.NewDatabase<T>(this);
    }

    /// <summary>
    /// Gets the schema.
    /// </summary>
    /// <returns>The schema.</returns>
    public T Query() => Database;

    /// <summary>
    /// Creates a new SQL query from the specified table name.
    /// </summary>
    /// <param name="tableName">The name of the table.</param>
    /// <returns>The SQL query.</returns>
    public SqlQuery From(string tableName)
    {
        var table = Provider.Metadata.TableModels.Single(x => x.Table.DbName == tableName).Table;

        return new SqlQuery(table, this);
    }

    /// <summary>
    /// Creates a new SQL query from the specified table metadata.
    /// </summary>
    /// <param name="table">The table metadata.</param>
    /// <returns>The SQL query.</returns>
    public SqlQuery From(TableDefinition table)
    {
        return new SqlQuery(table, this);
    }

    /// <summary>
    /// Creates a new SQL query from the specified model type.
    /// </summary>
    /// <typeparam name="V">The type of the model.</typeparam>
    /// <returns>The SQL query.</returns>
    public SqlQuery<V> From<V>() where V : IModel
    {
        return new SqlQuery<V>(this);
    }
}

================
File: src/DataLinq/Query/Delete.cs
================
using System;
using System.Data;

namespace DataLinq.Query;

public class Delete<T> : IQuery
{
    private readonly SqlQuery<T> query;

    public Delete(SqlQuery<T> query)
    {
        this.query = query;
    }

    public IDbCommand ToDbCommand()
    {
        throw new System.NotImplementedException();
    }

    public Sql ToSql(string? paramPrefix = null)
    {
        var sql = new Sql();

        sql.AddText("DELETE FROM ");
        query.AddTableName(sql, query.Table.DbName, query.Alias);
        query.GetWhere(sql, paramPrefix);

        return sql;
    }

    public QueryResult Execute()
    {
        throw new NotImplementedException();
    }
}

================
File: src/DataLinq/Query/Insert.cs
================
using System;
using System.Data;
using System.Linq;

namespace DataLinq.Query;

public class Insert<T> : IQuery
{
    private readonly SqlQuery<T> query;

    public Insert(SqlQuery<T> query)
    {
        this.query = query;
    }

    protected Sql GetSet(Sql sql, string? paramPrefix)
    {
        int length = query.SetList.Count;
        if (length == 0)
            return sql.AddFormat("VALUES (NULL)");

        sql.AddFormat("({0}) VALUES (", string.Join(",", query.SetList.Keys.Select(x => $"{query.EscapeCharacter}{x}{query.EscapeCharacter}")));

        int i = 0;
        foreach (var with in query.SetList)
        {
            query.DataSource.Provider.GetParameter(sql, paramPrefix + "v" + i, with.Value);
            query.DataSource.Provider.GetParameterValue(sql, paramPrefix + "v" + i);

            if (i + 1 < length)
                sql.AddText(",");
            else
                sql.AddText(")");

            i++;
        }

        return sql;
    }

    public Sql ToSql(string? paramPrefix = null)
    {
        var sql = new Sql();

        sql.AddFormat("INSERT INTO ");
        query.AddTableName(sql, query.Table.DbName, query.Alias);
        sql.AddText(" ");
        GetSet(sql, paramPrefix);

        if (query.LastIdQuery)
            sql.AddFormat(";\n{0}", query.DataSource.Provider.GetLastIdQuery());

        return sql;
    }

    public IDbCommand ToDbCommand()
    {
        return query.DataSource.Provider.ToDbCommand(this);
    }

    public QueryResult Execute()
    {
        throw new NotImplementedException();
    }
}

================
File: src/DataLinq/Query/IQueryPart.cs
================
namespace DataLinq.Query;

public interface IQueryPart
{
    void AddCommandString(Sql sql, string prefix, bool addCommandParameter = true, bool addParentheses = false);
    //protected abstract void GetCommandParameter(Sql sql, string prefix);
}

================
File: src/DataLinq/Query/Join.cs
================
using System;

namespace DataLinq.Query;

internal enum JoinType
{
    Inner,
    LeftOuter,
    RightOuter
}

public class Join<T>
{
    public readonly SqlQuery<T> Query;
    readonly string TableName;
    readonly JoinType Type;
    protected WhereGroup<T>? WhereContainer = null;
    private readonly string? Alias;

    internal Join(SqlQuery<T> query, string tableName, string? alias, JoinType type)
    {
        this.Query = query;
        this.TableName = tableName;
        this.Type = type;
        this.Alias = alias;
    }

    public Where<T> On(string columnName, string? alias = null)
    {
        if (WhereContainer == null)
            WhereContainer = new WhereGroup<T>(Query);

        if (alias == null)
            (columnName, alias) = QueryUtils.ParseColumnNameAndAlias(columnName);

        return WhereContainer.AddWhere(columnName, alias, BooleanType.And);
    }

    public Sql GetSql(Sql sql, string? paramPrefix)
    {
        if (Type == JoinType.Inner)
            sql.AddText("\nJOIN ");
        else if (Type == JoinType.LeftOuter)
            sql.AddText("\nLEFT JOIN ");
        else if (Type == JoinType.RightOuter)
            sql.AddText("\nRIGHT JOIN ");
        else
            throw new NotImplementedException("Wrong JoinType: " + Type);

        Query.AddTableName(sql, TableName, Alias);
        sql.AddText(" ON ");

        if (WhereContainer == null)
            throw new InvalidOperationException("Join without ON clause.");

        WhereContainer.AddCommandString(sql, paramPrefix, true);

        return sql;
    }
}

================
File: src/DataLinq/Query/Literal.cs
================
using System.Collections.Generic;
using System.Data;
using System.Linq;
using DataLinq.Mutation;

namespace DataLinq.Query;

public class Literal : IQuery
{
    private readonly string sql;
    private readonly IEnumerable<IDataParameter> parameters;
    protected Transaction transaction;
    public Transaction Transaction => transaction;

    public Literal(Transaction transaction, string sql)
    {
        this.transaction = transaction;
        this.sql = sql;
        this.parameters = new List<IDataParameter>();
    }

    public Literal(Transaction database, string sql, IEnumerable<IDataParameter> parameters)
    {
        this.transaction = database;
        this.sql = sql;
        this.parameters = parameters;
    }

    public Sql ToSql(string? paramPrefix = null)
    {
        return new Sql(sql, parameters.ToArray());
    }

    public IDbCommand ToDbCommand()
    {
        return Transaction.Provider.ToDbCommand(this);
    }

    public int ParameterCount
    {
        get { return parameters.Count(); }
    }
}

================
File: src/DataLinq/Query/OrderBy.cs
================
using DataLinq.Metadata;

namespace DataLinq.Query;

public class OrderBy
{
    public ColumnDefinition Column { get; }
    public string? Alias { get; }
    public bool Ascending { get; }

    internal string DbName(string escapeCharacter) => string.IsNullOrEmpty(Alias)
        ? $"{escapeCharacter}{Column.DbName}{escapeCharacter}"
        : $"{Alias}.{escapeCharacter}{Column.DbName}{escapeCharacter}";

    public OrderBy(ColumnDefinition column, string? alias, bool ascending)
    {
        this.Column = column;
        this.Alias = alias;
        this.Ascending = ascending;
    }
}

================
File: src/DataLinq/Query/QueryResult.cs
================
namespace DataLinq.Query;

public class QueryResult
{

}

================
File: src/DataLinq/Query/QueryUtils.cs
================
using System;

namespace DataLinq.Query;

public static class QueryUtils
{
    public static (string name, string alias) ParseTableNameAndAlias(string nameAndAlias)
    {
        return nameAndAlias.IndexOf(' ') switch
        {
            -1 => (nameAndAlias, null),
            var i when i > -1 => (nameAndAlias.Substring(0, i), nameAndAlias.Substring(i + 1)),
            _ => throw new NotImplementedException()
        };
    }

    public static (string name, string alias) ParseColumnNameAndAlias(string nameAndAlias)
    {
        return nameAndAlias.IndexOf('.') switch
        {
            -1 => (nameAndAlias, null),
            var i when i > -1 => (nameAndAlias.Substring(i + 1), nameAndAlias.Substring(0, i)),
            _ => throw new NotImplementedException()
        };
    }
}

================
File: src/DataLinq/Query/Select.cs
================
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using CommunityToolkit.HighPerformance;
using DataLinq.Extensions.Helpers;
using DataLinq.Instances;
using DataLinq.Metadata;

namespace DataLinq.Query;

public class Select<T> : IQuery
{
    protected readonly SqlQuery<T> query;
    public SqlQuery<T> Query => query;

    public Select(SqlQuery<T> query)
    {
        this.query = query;
    }

    public Sql ToSql(string? paramPrefix = null)
    {
        var columns = (query.WhatList ?? query.Table.Columns.Select(x => $"{query.EscapeCharacter}{x.DbName}{query.EscapeCharacter}"))
            .Select(x => $"{(!string.IsNullOrWhiteSpace(query.Alias) ? $"{query.Alias}." : "")}{x}")
            .ToJoinedString(", ");

        var sql = new Sql().AddFormat($"SELECT {columns} FROM ");
        query.AddTableName(sql, query.Table.DbName, query.Alias);
        query.GetJoins(sql, paramPrefix);
        query.GetWhere(sql, paramPrefix);
        query.GetOrderBy(sql);
        query.GetLimit(sql);

        return sql;
    }

    public IDbCommand ToDbCommand()
    {
        return query.DataSource.Provider.ToDbCommand(this);
    }

    public Select<T> What(IEnumerable<ColumnDefinition> columns)
    {
        query.What(columns);

        return this;
    }

    public Select<T> What(params string[] selectors)
    {
        query.What(selectors);

        return this;
    }

    public IEnumerable<IDataLinqDataReader> ReadReader()
    {
        return query.DataSource
            .DatabaseAccess
            .ReadReader(query.DataSource.Provider.ToDbCommand(this));
    }

    public IEnumerable<RowData> ReadRows()
    {
        return ReadReader()
            .Select(x => new RowData(x, query.Table, query.Table.Columns.AsSpan()));
    }

    public IEnumerable<IKey> ReadKeys()
    {
        return KeyFactory.GetKeys(this, query.Table.PrimaryKeyColumns);
    }

    //public IEnumerable<IKey> ReadForeignKeys(ColumnIndex foreignKeyIndex)
    //{
    //    return ReadReader()
    //        .Select(x => new RowData(x, query.Table, foreignKeyIndex.Columns.AsSpan()))
    //        .Select(x => new ForeignKey(foreignKeyIndex, x.GetValues(foreignKeyIndex.Columns).ToArray()));
    //}

    public IEnumerable<(IKey fk, IKey[] pks)> ReadPrimaryAndForeignKeys(ColumnIndex foreignKeyIndex)
    {
        return ReadReader()
            .Select(x => new RowData(x, query.Table, query.Table.PrimaryKeyColumns.Concat(foreignKeyIndex.Columns).Distinct().ToArray()))
            .Select(x => (fk: KeyFactory.CreateKeyFromValues(x.GetValues(foreignKeyIndex.Columns)), pk: KeyFactory.GetKey(x, query.Table.PrimaryKeyColumns)))
            .GroupBy(x => x.fk)
            .Select(x => (x.Key, x.Select(y => y.pk).ToArray()));
    }

    public IEnumerable<V> ExecuteAs<V>() =>
        Execute().Select(x => (V)x);

    public IEnumerable<IImmutableInstance> Execute()
    {
        if (query.Table.PrimaryKeyColumns.Length != 0)
        {
            this.What(query.Table.PrimaryKeyColumns);

            var keys = this
                .ReadKeys()
                .ToArray();

            foreach (var row in query.DataSource.Provider.GetTableCache(query.Table).GetRows(keys, query.DataSource, orderings: query.OrderByList))
                yield return row;
        }
        else
        {
            var rows = this
                .ReadRows()
                .Select(x => InstanceFactory.NewImmutableRow(x, query.DataSource.Provider, query.DataSource));

            foreach (var row in rows)
                yield return row;
        }
    }

    public V ExecuteScalar<V>()
    {
        return query.DataSource.DatabaseAccess.ExecuteScalar<V>(query.DataSource.Provider.ToDbCommand(this));
    }

    public object? ExecuteScalar()
    {
        return query.DataSource.DatabaseAccess.ExecuteScalar(query.DataSource.Provider.ToDbCommand(this));
    }

    public override string ToString()
    {
        return ToSql().ToString();
    }
}

================
File: src/DataLinq/Query/Sql.cs
================
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text;
using DataLinq.Extensions.Helpers;

namespace DataLinq.Query;

public class Sql
{
    private readonly StringBuilder builder = new StringBuilder();
    public List<IDataParameter> Parameters = new List<IDataParameter>();
    public int Index { get; protected set; } = 0;
    public string Text { get { return builder.ToString(); } }
    //public bool HasCreateDatabase { get; set; }

    public Sql()
    {
    }

    public int IndexAdd()
    {
        return Index++;
    }

    public Sql(string text, params IDataParameter[] parameters)
    {
        AddText(text);
        AddParameters(parameters);
    }

    public Sql AddParameters(params IDataParameter[] parameters)
    {
        Parameters.AddRange(parameters);

        return this;
    }

    public Sql AddText(string text)
    {
        builder.Append(text);

        return this;
    }

    public Sql AddLineBreak()
    {
        builder.Append('\n');

        return this;
    }

    public Sql AddFormat(string format, params string[] values)
    {
        builder.AppendFormat(format, values);

        return this;
    }

    public Sql Join(string separator, params string[] values)
    {
        int length = values.Length;

        for (int i = 0; i < length; i++)
        {
            builder.Append(values[i]);

            if (i + 1 < length)
                builder.Append(separator);
        }

        return this;
    }

    public Sql AddWhereText(string format, params string[] values)
    {
        builder.AppendFormat(format, values);

        return this;
    }

    public override string ToString()
    {
        return $"{Text}\n{Parameters.Select(x => x.Value).ToJoinedString("\n")}";
    }
}

================
File: src/DataLinq/Query/SqlQuery.cs
================
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Linq.Expressions;
using DataLinq.Exceptions;
using DataLinq.Linq.Visitors;
using DataLinq.Metadata;
using DataLinq.Mutation;
using Remotion.Linq.Clauses;

namespace DataLinq.Query;

public interface IQuery
{
    Sql ToSql(string? paramPrefix = null);
}

public class SqlQuery : SqlQuery<object>
{
    public SqlQuery(DataSourceAccess transaction, string? alias = null) : base(transaction, alias)
    {
    }

    public SqlQuery(TableDefinition table, DataSourceAccess transaction, string? alias = null) : base(table, transaction, alias)
    {
    }

    public SqlQuery(string tableName, DataSourceAccess transaction, string? alias = null) : base(tableName, transaction, alias)
    {
    }

    //public SqlQuery Where(WhereClause where)
    //{
    //    new WhereVisitor<object>(this).Parse(where);

    //    return this;
    //}

    //public SqlQuery OrderBy(OrderByClause orderBy)
    //{
    //    foreach (var ordering in orderBy.Orderings)
    //    {
    //        new OrderByVisitor<object>(this).Parse(ordering);
    //    }

    //    return this;
    //}
}

public class SqlQuery<T>
{
    protected WhereGroup<T> WhereGroup;
    internal Dictionary<string, object> SetList = new Dictionary<string, object>();
    protected List<Join<T>> JoinList = new List<Join<T>>();
    internal List<OrderBy> OrderByList = new List<OrderBy>();
    internal List<string> WhatList;
    protected int? limit;
    protected int? offset;
    public bool LastIdQuery { get; protected set; }
    public DataSourceAccess DataSource { get; }

    public TableDefinition Table { get; }
    public string? Alias { get; }

    internal string EscapeCharacter => DataSource.Provider.Constants.EscapeCharacter;

    public SqlQuery(DataSourceAccess dataSource, string? alias = null)
    {
        CheckTransaction(dataSource);

        this.DataSource = dataSource;
        this.Table = dataSource.Provider.Metadata.TableModels.Single(x => x.Model.CsType.Type == typeof(T)).Table;
        this.Alias = alias;
    }

    public SqlQuery(TableDefinition table, DataSourceAccess transaction, string? alias = null)
    {
        CheckTransaction(transaction);

        this.DataSource = transaction;
        this.Table = table;
        this.Alias = alias;
    }

    public SqlQuery(string tableName, DataSourceAccess transaction, string? alias = null)
    {
        CheckTransaction(transaction);

        this.DataSource = transaction;
        this.Table = transaction.Provider.Metadata.TableModels.Single(x => x.Table.DbName == tableName).Table;
        this.Alias = alias;
    }

    private void CheckTransaction(DataSourceAccess dataSource)
    {
        if (dataSource is Transaction transaction && (transaction.Status == DatabaseTransactionStatus.Committed || transaction.Status == DatabaseTransactionStatus.RolledBack))
            throw new Exception("Can't open a new connection on a committed or rolled back transaction");
    }

    public IEnumerable<T> Select()
    {
        return new Select<T>(this).ExecuteAs<T>();
    }

    public QueryResult Delete()
    {
        return new Delete<T>(this).Execute();
    }

    public QueryResult Insert()
    {
        return new Insert<T>(this).Execute();
    }

    public QueryResult Update()
    {
        return new Update<T>(this).Execute();
    }

    public virtual Select<T> SelectQuery()
    {
        return new Select<T>(this);
    }

    public Delete<T> DeleteQuery()
    {
        return new Delete<T>(this);
    }

    public Insert<T> InsertQuery()
    {
        return new Insert<T>(this);
    }

    public Update<T> UpdateQuery()
    {
        return new Update<T>(this);
    }

    public Where<T> Where(string columnName, string? alias = null)
    {
        if (WhereGroup == null)
            WhereGroup = new WhereGroup<T>(this);

        return WhereGroup.AddWhere(columnName, alias, BooleanType.And);
    }

    public WhereGroup<T> Where(IEnumerable<(string columnName, object? value)> wheres, BooleanType type = BooleanType.And, string? alias = null)
    {
        if (WhereGroup == null)
            WhereGroup = new WhereGroup<T>(this);

        foreach (var (columnName, value) in wheres)
            WhereGroup.AddWhere(columnName, alias, type).EqualTo(value);

        return WhereGroup;
    }

    public WhereGroup<T> Where(Func<Func<string, Where<T>>, WhereGroup<T>> func)
    {
        if (WhereGroup == null)
            WhereGroup = new WhereGroup<T>(this);

        return WhereGroup.And(func);
    }

    public Where<T> WhereNot(string columnName, string? alias = null)
    {
        if (WhereGroup == null)
            WhereGroup = new WhereGroup<T>(this);

        return WhereGroup.AddWhereNot(columnName, alias, BooleanType.And);
    }

    public WhereGroup<T> WhereNot(IEnumerable<(string columnName, object? value)> wheres, BooleanType type = BooleanType.And, string? alias = null)
    {
        if (WhereGroup == null)
            WhereGroup = new WhereGroup<T>(this);

        foreach (var (columnName, value) in wheres)
            WhereGroup.AddWhereNot(columnName, alias, type).EqualTo(value);

        return WhereGroup;
    }

    public WhereGroup<T> AddWhereGroup(BooleanType type = BooleanType.And)
    {
        if (WhereGroup == null)
            WhereGroup = new WhereGroup<T>(this);

        return WhereGroup.AddWhereGroup(new WhereGroup<T>(this), type);
    }

    public WhereGroup<T> AddWhereNotGroup(BooleanType type = BooleanType.And)
    {
        if (WhereGroup == null)
            WhereGroup = new WhereGroup<T>(this);

        return WhereGroup.AddWhereGroup(new WhereGroup<T>(this, true), type);
    }

    public WhereGroup<T> GetBaseWhereGroup(BooleanType type = BooleanType.And)
    {
        if (WhereGroup == null)
            WhereGroup = new WhereGroup<T>(this);

        return WhereGroup;
    }

    public SqlQuery<T> Where(WhereClause where)
    {
        new WhereVisitor<T>(this).Parse(where);

        return this;
    }

    public SqlQuery<T> OrderBy(OrderByClause orderBy)
    {
        foreach (var ordering in orderBy.Orderings)
        {
            new OrderByVisitor<T>(this).Parse(ordering);
        }

        return this;
    }

    internal Sql GetWhere(Sql sql, string? paramPrefix)
    {
        if (WhereGroup == null)
            return sql;

        sql.AddText("\nWHERE\n");
        WhereGroup.AddCommandString(sql, paramPrefix, true);

        return sql;
    }

    internal KeyValuePair<string, object> GetFields(Expression left, Expression right)
    {
        if (left is ConstantExpression && right is ConstantExpression)
            throw new InvalidQueryException("Unable to compare 2 constants.");

        if (left is MemberExpression && right is MemberExpression)
            throw new InvalidQueryException("Unable to compare 2 members.");

        if (left is MemberExpression)
            return GetValues(left, right);
        else
            return GetValues(right, left);
    }

    internal KeyValuePair<string, object> GetValues(Expression field, Expression value)
    {
        return new KeyValuePair<string, object>((string)GetValue(field), GetValue(value));
    }

    internal object GetValue(Expression expression)
    {
        if (expression is ConstantExpression constExp)
            return constExp.Value;
        else if (expression is MemberExpression propExp)
            return GetColumn(propExp).DbName;
        else
            throw new InvalidQueryException("Value is not a member or constant.");
    }

    internal ColumnDefinition? GetColumn(MemberExpression expression)
    {
        return Table.Columns.SingleOrDefault(x => x.ValueProperty.PropertyName == expression.Member.Name);
    }

    internal Sql AddTableName(Sql sql, string tableName, string? alias)
    {
        DataSource.Provider.GetTableName(sql, tableName, alias);

        return sql;
    }

    internal Sql GetJoins(Sql sql, string? paramPrefix)
    {
        foreach (var join in JoinList)
            join.GetSql(sql, paramPrefix);

        return sql;
    }

    public Join<T> Join(string tableName, string? alias = null)
    {
        return Join(tableName, alias, JoinType.Inner);
    }

    public Join<T> LeftJoin(string tableName, string? alias = null)
    {
        return Join(tableName, alias, JoinType.LeftOuter);
    }

    public Join<T> RightJoin(string tableName, string? alias = null)
    {
        return Join(tableName, alias, JoinType.RightOuter);
    }

    private Join<T> Join(string tableName, string? alias, JoinType type)
    {
        if (JoinList == null)
            JoinList = new List<Join<T>>();

        if (alias == null)
            (tableName, alias) = QueryUtils.ParseTableNameAndAlias(tableName);

        var join = new Join<T>(this, tableName, alias, type);
        JoinList.Add(join);

        return join;
    }


    internal Sql GetOrderBy(Sql sql)
    {
        int length = OrderByList.Count;
        if (length == 0)
            return sql;

        sql.AddText("\nORDER BY ");
        sql.AddText(string.Join(", ", OrderByList.Select(x => $"{x.DbName(EscapeCharacter)}{(x.Ascending ? "" : " DESC")}")));

        return sql;
    }

    public SqlQuery<T> OrderBy(string columnName, string? alias = null, bool ascending = true)
    {
        if (alias == null)
            (columnName, alias) = QueryUtils.ParseColumnNameAndAlias(columnName);

        return OrderBy(this.Table.Columns.Single(x => x.DbName == columnName), alias, ascending);
    }

    public SqlQuery<T> OrderBy(ColumnDefinition column, string? alias = null, bool ascending = true)
    {
        if (!this.Table.Columns.Contains(column))
            throw new ArgumentException($"Column '{column.DbName}' does not belong to table '{Table.DbName}'");

        this.OrderByList.Add(new OrderBy(column, alias, ascending));

        return this;
    }

    public SqlQuery<T> OrderByDesc(string columnName, string? alias = null)
    {
        if (alias == null)
            (columnName, alias) = QueryUtils.ParseColumnNameAndAlias(columnName);

        return OrderByDesc(this.Table.Columns.Single(x => x.DbName == columnName), alias);
    }

    public SqlQuery<T> OrderByDesc(ColumnDefinition column, string? alias = null)
    {
        if (!this.Table.Columns.Contains(column))
            throw new ArgumentException($"Column '{column.DbName}' does not belong to table '{Table.DbName}'");

        this.OrderByList.Add(new OrderBy(column, alias, false));

        return this;
    }

    public SqlQuery<T> Limit(int limit)
    {
        if (limit < 0)
            throw new ArgumentException($"Argument 'rows' must be positive");

        this.limit = limit;

        return this;
    }

    public SqlQuery<T> Limit(int limit, int offset)
    {
        if (limit < 0)
            throw new ArgumentException($"Argument 'rows' must be positive");

        this.limit = limit;
        this.offset = offset;

        return this;
    }

    public SqlQuery<T> Offset(int offset)
    {
        if (offset < 0)
            throw new ArgumentException($"Argument 'rows' must be positive");

        this.offset = offset;

        return this;
    }

    internal Sql GetLimit(Sql sql)
    {
        return DataSource.Provider.GetLimitOffset(sql, limit, offset);
    }

    internal Sql GetSet(Sql sql, string? paramPrefix)
    {
        int length = SetList.Count;
        if (length == 0)
            return sql;

        int i = 0;
        foreach (var with in SetList)
        {
            DataSource.Provider.GetParameter(sql, paramPrefix + "v" + i, with.Value);
            DataSource.Provider.GetParameterComparison(sql, with.Key, Relation.Equal, [paramPrefix + "v" + i]);

            if (i + 1 < length)
                sql.AddText(",");

            i++;
        }

        return sql;
    }

    public SqlQuery<T> Set<V>(string key, V value)
    {
        SetList.Add(key, value);
        return this;
    }


    public SqlQuery<T> What(IEnumerable<ColumnDefinition> columns)
    {
        return What(columns.Select(x => $"{EscapeCharacter}{x.DbName}{EscapeCharacter}"));
    }

    public SqlQuery<T> What(IEnumerable<string> selectors)
    {
        WhatList ??= [];
        WhatList.AddRange(selectors.Select(x => Table.Columns.Any(y => y.DbName == x) ? $"{EscapeCharacter}{x}{EscapeCharacter}" : x));

        return this;
    }

    public SqlQuery<T> What(params string[] selectors)
    {
        return What(selectors.AsEnumerable());
    }

    public SqlQuery<T> AddLastIdQuery()
    {
        this.LastIdQuery = true;

        return this;
    }
}

================
File: src/DataLinq/Query/Update.cs
================
using System;
using System.Data;

namespace DataLinq.Query;

public class Update<T> : IQuery
{
    private readonly SqlQuery<T> query;

    public Update(SqlQuery<T> query)
    {
        this.query = query;
    }

    public IDbCommand ToDbCommand()
    {
        throw new System.NotImplementedException();
    }

    public Sql ToSql(string? paramPrefix = null)
    {
        var sql = new Sql();

        sql.AddText("UPDATE ");
        query.AddTableName(sql, query.Table.DbName, query.Alias);
        sql.AddText(" SET ");
        query.GetSet(sql, paramPrefix);
        sql.AddText(" \n");
        query.GetWhere(sql, paramPrefix);

        return sql;
    }

    public QueryResult Execute()
    {
        throw new NotImplementedException();
    }
}

================
File: src/DataLinq/Query/Where.cs
================
using System.Collections.Generic;
using System.Linq;
using DataLinq.Extensions.Helpers;

namespace DataLinq.Query;

public enum Relation
{
    Equal,
    EqualNull,
    NotEqual,
    NotEqualNull,
    Like,
    GreaterThan,
    GreaterThanOrEqual,
    LessThan,
    LessThanOrEqual,
    In,
    NotIn
}

public interface IWhere<T> : IQueryPart
{
    //IWhere<T> And(string columnName);

    //IWhere<T> Or(string columnName);
    //WhereContinuation<T> EqualTo<V>(V value);
    //WhereContinuation<T> EqualTo<V>(V value, bool isValue);
    //WhereContinuation<T> NotEqualTo<V>(V value);
    //WhereContinuation<T> Like<V>(V value);
    //WhereContinuation<T> GreaterThan<V>(V value);
    //WhereContinuation<T> GreaterThanOrEqual<V>(V value);
    //WhereContinuation<T> LessThan<V>(V value);
    //WhereContinuation<T> LessThanOrEqual<V>(V value);
}

public class Where<T> : IWhere<T>
{
    private string? Key;
    private object?[]? Value;
    private Relation Relation;
    internal bool IsValue = true;
    internal bool IsNegated = false;
    protected WhereGroup<T> WhereGroup;
    private string? KeyAlias;
    private string? ValueAlias;

    private string KeyName => string.IsNullOrEmpty(KeyAlias)
        ? $"{WhereGroup.Query.EscapeCharacter}{Key}{WhereGroup.Query.EscapeCharacter}"
        : $"{KeyAlias}.{WhereGroup.Query.EscapeCharacter}{Key}{WhereGroup.Query.EscapeCharacter}";

    private string ValueName => string.IsNullOrEmpty(ValueAlias)
        ? $"{WhereGroup.Query.EscapeCharacter}{Value?[0] as string}{WhereGroup.Query.EscapeCharacter}"
        : $"{ValueAlias}.{WhereGroup.Query.EscapeCharacter}{Value?[0]}{WhereGroup.Query.EscapeCharacter}";

    internal Where(WhereGroup<T> group, string key, string? keyAlias, bool isValue = true, bool isNegated = false)
    {
        if (keyAlias == null)
            (key, keyAlias) = QueryUtils.ParseColumnNameAndAlias(key);

        WhereGroup = group;
        Key = key;
        IsValue = isValue;
        IsNegated = isNegated;
        KeyAlias = keyAlias;
    }

    internal Where(WhereGroup<T> group)
    {
        WhereGroup = group;
    }

    internal Where<T> AddKey(string key, string? alias, bool isValue = true)
    {
        Key = key;
        IsValue = isValue;
        KeyAlias = alias;

        return this;
    }

    public WhereGroup<T> EqualTo<V>(V value)
    {
        return SetAndReturn(value, value == null ? Relation.EqualNull : Relation.Equal);
    }

    public WhereGroup<T> EqualToNull()
    {
        return SetAndReturnNull(Relation.EqualNull);
    }

    public WhereGroup<T> EqualToColumn(string column, string? alias = null)
    {
        return SetAndReturnColumn(column, alias, Relation.Equal);
    }

    public WhereGroup<T> NotEqualTo<V>(V value)
    {
        return SetAndReturn(value, value == null ? Relation.NotEqualNull : Relation.NotEqual);
    }

    public WhereGroup<T> NotEqualToNull()
    {
        return SetAndReturnNull(Relation.NotEqualNull);
    }

    public WhereGroup<T> NotEqualToColumn(string column, string? alias = null)
    {
        return SetAndReturnColumn(column, alias, Relation.NotEqual);
    }

    public WhereGroup<T> Like<V>(V value)
    {
        return SetAndReturn(value, Relation.Like);
    }

    public WhereGroup<T> LikeColumn(string column, string? alias = null)
    {
        return SetAndReturnColumn(column, alias, Relation.Like);
    }

    public WhereGroup<T> GreaterThan<V>(V value)
    {
        return SetAndReturn(value, Relation.GreaterThan);
    }

    public WhereGroup<T> GreaterThanColumn(string column, string? alias = null)
    {
        return SetAndReturnColumn(column, alias, Relation.GreaterThan);
    }

    public WhereGroup<T> GreaterThanOrEqual<V>(V value)
    {
        return SetAndReturn(value, Relation.GreaterThanOrEqual);
    }

    public WhereGroup<T> GreaterThanOrEqualToColumn(string column, string? alias = null)
    {
        return SetAndReturnColumn(column, alias, Relation.GreaterThanOrEqual);
    }

    public WhereGroup<T> LessThan<V>(V value)
    {
        return SetAndReturn(value, Relation.LessThan);
    }

    public WhereGroup<T> LessThanColumn(string column, string? alias = null)
    {
        return SetAndReturnColumn(column, alias, Relation.LessThan);
    }

    public WhereGroup<T> LessThanOrEqual<V>(V value)
    {
        return SetAndReturn(value, Relation.LessThanOrEqual);
    }

    public WhereGroup<T> LessThanOrEqualToColumn(string column, string? alias = null)
    {
        return SetAndReturnColumn(column, alias, Relation.LessThanOrEqual);
    }

    public WhereGroup<T> In<V>(IEnumerable<V> values) =>
        In(values.ToArray());

    public WhereGroup<T> In<V>(params V[] values)
    {
        return SetAndReturn(values, Relation.In);
    }

    public WhereGroup<T> NotIn<V>(IEnumerable<V> values) =>
        NotIn(values.ToArray());

    public WhereGroup<T> NotIn<V>(params V[] values)
    {
        return SetAndReturn(values, Relation.NotIn);
    }

    protected WhereGroup<T> SetAndReturn<V>(V[] value, Relation relation)
    {
        Value = value.Cast<object>().ToArray();
        Relation = relation;

        return this.WhereGroup;
    }

    protected WhereGroup<T> SetAndReturn<V>(V? value, Relation relation)
    {
        Value = [value];
        Relation = relation;

        return this.WhereGroup;
    }

    protected WhereGroup<T> SetAndReturnNull(Relation relation)
    {
        Value = null;
        Relation = relation;

        return this.WhereGroup;
    }

    protected WhereGroup<T> SetAndReturnColumn(string column, string? alias, Relation relation)
    {
        if (alias == null)
            (column, alias) = QueryUtils.ParseColumnNameAndAlias(column);

        Value = [column];
        ValueAlias = alias;
        IsValue = false;
        Relation = relation;

        return this.WhereGroup;
    }

    public void AddCommandString(Sql sql, string prefix, bool addCommandParameter = true, bool addParentheses = false)
    {
        addParentheses = addParentheses || IsNegated; // || Relation == Relation.In || Relation == Relation.NotIn;

        var indexList = addCommandParameter ? GetCommandParameter(sql, prefix).ToArray() : ([sql.Index]);

        if (IsNegated)
            sql.AddText("NOT ");

        if (addParentheses)
            sql.AddText("(");

        if (IsValue)
            WhereGroup.Query.DataSource.Provider.GetParameterComparison(sql, KeyName, Relation, indexList.Select(x => prefix + "w" + x).ToArray());
        else
            sql.AddFormat("{0} {1} {2}", KeyName, Relation.ToSql(), ValueName);

        if (addParentheses)
            sql.AddText(")");
    }

    protected IEnumerable<int> GetCommandParameter(Sql sql, string prefix)
    {
        if (IsValue)
        {
            if (Value == null)
            {
                yield return sql.Index;
                WhereGroup.Query.DataSource.Provider.GetParameter(sql, prefix + "w" + sql.IndexAdd(), null);
            }
            else
            {
                foreach (var value in Value)
                {
                    yield return sql.Index;
                    WhereGroup.Query.DataSource.Provider.GetParameter(sql, prefix + "w" + sql.IndexAdd(), value);
                }
            }
        }
    }

    public override string ToString()
    {
        var sql = new Sql();
        AddCommandString(sql, "");

        return sql.ToString();
    }
}

================
File: src/DataLinq/Query/WhereGroup.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using DataLinq.Metadata;
using DataLinq.Mutation;

namespace DataLinq.Query;

public enum BooleanType
{
    And,
    Or
}

public class WhereGroup<T> : IWhere<T>
{
    public readonly SqlQuery<T> Query;
    protected List<(IWhere<T> where, BooleanType type)>? whereList;

    private bool IsNegated = false;

    public Transaction Transaction => throw new NotImplementedException();

    internal WhereGroup(SqlQuery<T> query, bool isNegated = false)
    {
        Query = query;
        IsNegated = isNegated;
    }

    public void AddCommandString(Sql sql, string prefix = "", bool addCommandParameter = true, bool addParentheses = false)
    {
        int length = whereList?.Count ?? 0;
        if (length == 0)
            return;

        if (IsNegated)
            sql.AddText("NOT ");

        if (addParentheses || IsNegated)
            sql.AddText("(");

        //if (whereList!.All(x => x.type == BooleanType.Or && x.where is Where<T> w && w.IsValue && !w.IsNegated))
        //{
        //    sql.AddText("IN (");
        //    whereList.Select(x => Query.DataSource.Provider.GetParameterValue(sql, x.where.)
        //    sql.AddText("IN )");
        //}
        //else
        //{
            for (int i = 0; i < length; i++)
            {
                if (i != 0)
                {
                    if (whereList?[i].type == BooleanType.And)
                        sql.AddText(" AND ");
                    else if (whereList?[i].type == BooleanType.Or)
                        sql.AddText(" OR ");
                    else
                        throw new NotImplementedException();
                }

                whereList?[i].where.AddCommandString(sql, prefix, addCommandParameter, whereList[i].where is WhereGroup<T>);
            }
        //}

        if (addParentheses || IsNegated)
            sql.AddText(")");
    }

    public Where<T> AddWhere(string columnName, string? alias, BooleanType type)
    {
        return AddWhere(new Where<T>(this, columnName, alias), type);
    }

    public Where<T> AddWhereNot(string columnName, string? alias, BooleanType type)
    {
        return AddWhere(new Where<T>(this, columnName, alias, isNegated: true), type);
    }

    internal Where<T> AddWhere(Where<T> where, BooleanType type)
    {
        if (whereList == null)
            whereList = new List<(IWhere<T> where, BooleanType type)>();

        whereList.Add((where, type));

        return where;
    }

    internal WhereGroup<T> AddWhereGroup(WhereGroup<T> group, BooleanType type)
    {
        if (whereList == null)
            whereList = new List<(IWhere<T> where, BooleanType type)>();

        whereList.Add((group, type));

        return group;
    }

    public Where<T> And(string columnName, string? alias = null)
    {
        return AddWhere(new Where<T>(this, columnName, alias), BooleanType.And);
    }

    public WhereGroup<T> And(Func<Func<string, Where<T>>, WhereGroup<T>> func)
    {
        var group = AddWhereGroup(new WhereGroup<T>(this.Query), BooleanType.And);

        var where = new Where<T>(group);
        group.AddWhere(where, BooleanType.And);
        func(columnName => where.AddKey(columnName, null));

        return this;
    }

    public Where<T> Or(string columnName, string? alias = null)
    {
        return AddWhere(new Where<T>(this, columnName, alias), BooleanType.Or);
    }

    public WhereGroup<T> Or(Func<Func<string, Where<T>>, WhereGroup<T>> func)
    {
        var group = AddWhereGroup(new WhereGroup<T>(this.Query), BooleanType.Or);

        var where = new Where<T>(group);
        group.AddWhere(where, BooleanType.And);
        func(columnName => where.AddKey(columnName, null));

        return this;
    }

    public SqlQuery<T> Set<V>(string key, V value)
    {
        return Query.Set(key, value);
    }

    public IEnumerable<T> Select()
    {
        return Query.Select();
    }

    public QueryResult Delete()
    {
        return Query.Delete();
    }

    public QueryResult Insert()
    {
        return Query.Insert();
    }

    public QueryResult Update()
    {
        return Query.Update();
    }

    public Select<T> SelectQuery()
    {
        return new Select<T>(Query);
    }

    public Insert<T> InsertQuery()
    {
        return new Insert<T>(Query);
    }

    public Where<T> Where(string columnName, string? alias = null)
    {
        return Query.Where(columnName, alias);
    }

    public WhereGroup<T> Where(IEnumerable<(string columnName, object? value)> wheres, BooleanType type = BooleanType.And, string? alias = null)
    {
        return Query.Where(wheres, type, alias);
    }

    public WhereGroup<T> WhereNot(IEnumerable<(string columnName, object? value)> wheres, BooleanType type = BooleanType.And, string? alias = null)
    {
        return Query.WhereNot(wheres, type, alias);
    }

    public SqlQuery<T> OrderBy(string columnName, string? alias = null, bool ascending = true)
    {
        return Query.OrderBy(columnName, alias, ascending);
    }

    public SqlQuery<T> OrderBy(ColumnDefinition column, string? alias = null, bool ascending = true)
    {
        return Query.OrderBy(column, alias, ascending);
    }

    public SqlQuery<T> OrderByDesc(string columnName, string? alias = null)
    {
        return Query.OrderByDesc(columnName, alias);
    }

    public SqlQuery<T> OrderByDesc(ColumnDefinition column, string? alias = null)
    {
        return Query.OrderByDesc(column, alias);
    }

    public SqlQuery<T> Limit(int rows)
    {
        return Query.Limit(rows);
    }

    public Join<T> Join(string tableName, string? alias = null)
    {
        return Query.Join(tableName, alias);
    }

    public Join<T> LeftJoin(string tableName, string? alias = null)
    {
        return Query.Join(tableName, alias);
    }

    public Join<T> RightJoin(string tableName, string? alias = null)
    {
        return Query.Join(tableName, alias);
    }

    public override string ToString()
    {
        var sql = new Sql();
        AddCommandString(sql);

        return sql.ToString();
    }
}

================
File: src/DataLinq/Utils/FileSizeFormatProvider.cs
================
using System;

namespace DataLinq.Utils;

public class FileSizeFormatProvider : IFormatProvider, ICustomFormatter
{
    public object? GetFormat(Type? formatType)
    {
        if (formatType == typeof(ICustomFormatter))
            return this;

        return null;
    }

    private const string fileSizeFormat = "fs";
    private const decimal OneKiloByte = 1024M;
    private const decimal OneMegaByte = OneKiloByte * 1024M;
    private const decimal OneGigaByte = OneMegaByte * 1024M;

    public string Format(string? format, object? arg, IFormatProvider? formatProvider)
    {
        if (format?.StartsWith(fileSizeFormat) != true)
        {
            return DefaultFormat(format, arg, formatProvider);
        }

        if (arg is string)
        {
            return DefaultFormat(format, arg, formatProvider);
        }

        decimal size;

        try
        {
            size = Convert.ToDecimal(arg);
        }
        catch (InvalidCastException)
        {
            return DefaultFormat(format, arg, formatProvider);
        }

        string suffix;
        if (size > OneGigaByte)
        {
            size /= OneGigaByte;
            suffix = "GB";
        }
        else if (size > OneMegaByte * 10)
        {
            size /= OneMegaByte;
            suffix = "MB";
        }
        else if (size > OneKiloByte)
        {
            size /= OneKiloByte;
            suffix = "KB";
        }
        else
        {
            suffix = "B";
        }

        var precision = format.Substring(2);
        if (string.IsNullOrEmpty(precision))
            precision = "2";

        return string.Format("{0:N" + precision + "} {1}", size, suffix);
    }

    private static string DefaultFormat(string? format, object? arg, IFormatProvider? formatProvider)
    {
        if (arg is IFormattable formattableArg)
            return formattableArg.ToString(format, formatProvider);

        return arg?.ToString() ?? "";
    }
}

public static class FileSizeExtensions
{
    public static string ToFileSize(this long l, bool hideEmpty = false)
    {
        if (hideEmpty && l == 0)
            return "";

        return string.Format(new FileSizeFormatProvider(), "{0:fs0}", l);
    }
}

================
File: src/DataLinq/Utils/NonNegativeInt.cs
================
using System;

namespace DataLinq.Utils;

public class NonNegativeInt
{
    private int value;

    public NonNegativeInt(int initialValue = 0)
    {
        if (initialValue < 0)
            throw new ArgumentException("Initial value cannot be negative.");

        value = initialValue;
    }

    public int Value => value;

    public int Increment()
    {
        return value++;
    }

    public int Decrement()
    {
        return value > 0
            ? value--
            : value;
    }

    public override string ToString() => value.ToString();
}

================
File: src/DataLinq/Utils/TypeUtils.cs
================
using System;
using System.Collections.Concurrent;
using System.ComponentModel;

namespace DataLinq.Utils;

public static class TypeUtils
{
    private static readonly ConcurrentDictionary<Type, Type> nullableTypes = new ConcurrentDictionary<Type, Type>();

    public static Type GetNullableConversionType(Type returnType)
    {
        if (returnType.IsGenericType && returnType.GetGenericTypeDefinition().Equals(typeof(Nullable<>)))
        {
            if (!nullableTypes.TryGetValue(returnType, out Type? nullableType))
            {
                nullableType = new NullableConverter(returnType).UnderlyingType;
                nullableTypes.TryAdd(returnType, nullableType);
            }

            return nullableType;
        }

        return returnType;
    }
}

================
File: src/DataLinq/Workers/ThreadWorker.cs
================
using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using DataLinq.Interfaces;

namespace DataLinq.Workers;

public enum WorkerStatus
{
    Stopped,
    Stopping,
    Running,
    WaitingForJob,
    WaitingUntilTime
}

public interface IThreadCreator
{
    void CreateNewThread(Action<CancellationToken> arbete);
}

//public static class ThreadCreator
//{
//    public static IThreadCreator Tradskapare { get; set; } = new LongRunningTaskCreator();

//    public static void CreateNewThread(Action<CancellationToken> arbete) =>
//        Tradskapare.CreateNewThread(arbete);
//}

public class LongRunningTaskCreator : IThreadCreator
{
    public void CreateNewThread(Action<CancellationToken> arbete) =>
        Task.Factory.StartNew(() => arbete(new CancellationToken()), TaskCreationOptions.LongRunning);
}

public abstract class ThreadWorker<T> : IDisposable
{
    public WorkerStatus Status { get; private set; }
    protected IThreadCreator ThreadCreator { get; }
    protected IWorkQueue<T> WorkQueue { get; } = WorkQueue<T>.NewStandardQueue();
    private CancellationToken CancellationToken => CancellationTokenSource.Token;
    private CancellationTokenSource CancellationTokenSource { get; set; }
    private CancellationToken VantaCancellationToken => VantaCancellationTokenSource.Token;
    private CancellationTokenSource VantaCancellationTokenSource { get; set; }
    public DateTime? WaitingUntil { get; private set; }

    public ThreadWorker(IThreadCreator threadCreator)
    {
        this.ThreadCreator = threadCreator;
    }

    public void AddWork(T work)
    {
        WorkQueue.Add(work);
    }

    public void Start()
    {
        if (Status != WorkerStatus.Stopped)
            return;

        SetStatus(WorkerStatus.WaitingForJob);

        ThreadCreator.CreateNewThread(ct => WorkLoop(WorkQueue, ct));
    }

    public void Stop()
    {
        SetStatus(WorkerStatus.Stopping);
        CancellationTokenSource.Cancel();
    }

    public void Run()
    {
        if (Status != WorkerStatus.WaitingUntilTime)
            return;

        VantaCancellationTokenSource?.Cancel();
    }

    protected void Wait(TimeSpan tid)
    {
        if (CancellationToken.IsCancellationRequested || VantaCancellationToken.IsCancellationRequested)
            return;

        if (tid == TimeSpan.MinValue)
            return;

        WaitingUntil = DateTime.Now.Add(tid);
        SetStatus(WorkerStatus.WaitingUntilTime);

        VantaCancellationToken.WaitHandle.WaitOne(tid);
    }

    protected void SetStatus(WorkerStatus status)
    {
        Status = status;
    }

    protected void WorkLoop(IWorkQueue<T> queue, CancellationToken ct)
    {
        CancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(ct);

        try
        {
            while (!CancellationToken.IsCancellationRequested)
            {
                VantaCancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(CancellationToken, new CancellationToken());
                SetStatus(WorkerStatus.WaitingForJob);
                var varde = queue.Take(CancellationToken);
                SetStatus(WorkerStatus.Running);
                DoWork(varde);
            }
        }
        catch (OperationCanceledException)
        {
            //TODO: Logging
        }
        catch (Exception)
        {
            //TODO: Logging
        }

        SetStatus(WorkerStatus.Stopped);
    }

    protected abstract void DoWork(T value);

    public void Dispose()
    {
        Stop();
    }
}

public class CleanCacheWorker : ThreadWorker<int>
{
    public TimeSpan WaitTime { get; private set; }
    protected IDatabaseProvider DatabaseProvider { get; }

    public CleanCacheWorker(IDatabaseProvider database, IThreadCreator threadCreator, TimeSpan waitTime) : base(threadCreator)
    {
        this.DatabaseProvider = database;
        this.WaitTime = waitTime;

        AddWork(0);
    }

    protected override void DoWork(int value)
    {
        var rows = DatabaseProvider.State?.Cache.RemoveRowsBySettings().ToList();
        //TODO: Logging

        if (WorkQueue.Count == 0)
        {
            Wait(WaitTime);
            AddWork(++value);
        }
    }
}

================
File: src/DataLinq/Workers/WorkQueue.cs
================
using System.Collections.Concurrent;
using System.Threading;

namespace DataLinq.Workers;

public interface IWorkQueue<T>
{
    int Count { get; }

    void Add(T varde);

    T Take(CancellationToken ct);

    T[] Values();
}

public class WorkQueue<T> : IWorkQueue<T>
{
    public int Count => Queue.Count;
    private BlockingCollection<T> Queue { get; }

    public WorkQueue(IProducerConsumerCollection<T> collection)
    {
        Queue = new BlockingCollection<T>(collection);
    }

    public static WorkQueue<T> NewStandardQueue() => new WorkQueue<T>(new ConcurrentQueue<T>());

    public void Add(T varde) => Queue.Add(varde);

    public T Take(CancellationToken ct) => Queue.Take(ct);

    public T[] Values() => Queue.ToArray();
}



================================================================
End of Codebase
================================================================
