using System;
using System.Collections.Generic;
using System.Linq;
using DataLinq.SourceGenerators;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;

namespace DataLinq.Generators.Tests;

public abstract class GeneratorTestBase
{
    protected IEnumerable<SyntaxTree> RunGenerator(IEnumerable<SyntaxTree> syntaxTrees, CSharpParseOptions? parseOptions = null)
    {
        // Set up compilation
        // Get all assembly references from the current AppDomain to create a valid compilation.
        var references = AppDomain.CurrentDomain.GetAssemblies()
            .Where(a => !a.IsDynamic && !string.IsNullOrEmpty(a.Location))
            .Select(a => MetadataReference.CreateFromFile(a.Location))
            .ToList();

        references.AddRange(
        [
            MetadataReference.CreateFromFile(typeof(object).Assembly.Location), // System.Private.CoreLib.dll
            MetadataReference.CreateFromFile(typeof(Enumerable).Assembly.Location), // System.Linq.dll
        ]);

        var compilation = CSharpCompilation.Create("TestAssembly",
            syntaxTrees,
            references,
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)
                .WithNullableContextOptions(NullableContextOptions.Enable));

        // This check is now robust because all references are included.
        //var preGenDiagnostics = compilation.GetDiagnostics().Where(d => d.Severity == DiagnosticSeverity.Error).ToList();
        //if (preGenDiagnostics.Any())
        //{
        //    Assert.Fail($"Test source has compilation errors before generator run:\n{string.Join('\n', preGenDiagnostics.Select(e => e.ToString()))}");
        //}

        var generator = new ModelGenerator();
        ModelGeneratorHoist host = new(generator);
        var driver = CSharpGeneratorDriver.Create(host); //.WithParseOptions(parseOptions);
        driver.RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out var diagnostics);

        var generatorErrors = diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error).ToList();
        if (generatorErrors.Any())
        {
            Assert.Fail($"Generator produced errors:\n{string.Join('\n', generatorErrors.Select(e => e.ToString()))}");
        }

        // Return only the new syntax trees generated by the source generator.
        return outputCompilation.SyntaxTrees.Where(st => !syntaxTrees.Any(t => t.FilePath == st.FilePath && t.ToString() == st.ToString()));
    }
}